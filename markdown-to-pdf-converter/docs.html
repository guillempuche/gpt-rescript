<style>body {word-wrap: break-word;}</style><h1>docs</h1><p>This document contains the full ReScript version 11 official documentation dated in December 2023.</p><h1>introduction</h1><hr />
<p>title: "Introduction"
description: "GenType - Interoperability between ReScript and TypeScript / Flow"
canonical: "/docs/gentype/latest/introduction"</p>
<hr />
<h1>GenType</h1>
<p><code>genType</code> is a code generation tool that lets you export ReScript values and types to use in TypeScript (TS), and import TS values and types into ReScript.</p>
<p>Converter functions between the two runtime representations are generated when required based on the type of the values.
In particular, conversion of <a href="/docs/react/latest/introduction">rescript-react</a> components both ways is supported, with automatic generation of the wrappers.</p>
<p>Here's an article describing how to use <code>genType</code> as part of a migration strategy where a tree of components is gradually converted to ReScript bottom-up (old article containing Reason / BuckleScript): <a href="https://medium.com/p/c514265b466d">Adopting Reason: strategies, dual sources of truth, and why genType is a big deal</a>.</p>
<p>The implementation of genType performs a type-directed transformation of ReScript programs after compilation. The transformed programs operate on data types idiomatic to JS.</p>
<p>For example, a ReScript function operating on a ReScript variant <code>type t = | A(int) | B(string)</code> (which is represented as custom objects with tags at runtime) is exported to a JS function operating on the corresponding JS object of type <code>{ tag: "A"; value: number }
  | { tag: "B"; value: string }</code>.</p>
<h2>A Quick Example</h2>
<p>Let's assume we are working on a TypeScript codebase and we want to integrate a single rescript-react component.</p>
<p>We want to be able to import the rescript-react component like any other React component in our existing TS code, but we also want to preserve all the ReScript types in the TS type system (and convert incompatible values if necessary).</p>
<p><strong>That's exactly what genType was made for!</strong></p>
<p>First we'll set up a rescript-react component:</p>
<pre class="codehilite"><code class="language-res">/* src/MyComp.res */

@genType
type color =
  | Red
  | Blue;

@genType
@react.component
let make = (~name: string, ~color: color) =&gt; {
  let colorStr =
    switch (color) {
    | Red =&gt; &quot;red&quot;
    | Blue =&gt; &quot;blue&quot;
    };

  &lt;div className={&quot;color-&quot; ++ colorStr}&gt; {React.string(name)} &lt;/div&gt;;
};
</code></pre>

<p>On a successful compile, <code>genType</code> will convert <code>src/MyComp.res</code> to a TS file called <code>src/MyComp.gen.tsx</code> which will look something like this:</p>
<pre class="codehilite"><code class="language-ts">// src/MyComp.gen.tsx

/* TypeScript file generated from MyComp.res by genType. */
/* eslint-disable import/first */


import * as React from 'react';

const $$toRE818596289: { [key: string]: any } = {&quot;Red&quot;: 0, &quot;Blue&quot;: 1};

// tslint:disable-next-line:no-var-requires
const MyCompBS = require('./MyComp.bs');

// tslint:disable-next-line:interface-over-type-literal
export type color = &quot;Red&quot; | &quot;Blue&quot;;

// tslint:disable-next-line:interface-over-type-literal
export type Props = { readonly color: color; readonly name: string };

export const make: React.ComponentType&lt;{ readonly color: color; readonly name: string }&gt; = function MyComp(Arg1: any) {
  const $props = {color:$$toRE818596289[Arg1.color], name:Arg1.name};
  const result = React.createElement(MyCompBS.make, $props);
  return result
};
</code></pre>

<p>genType automatically maps the <code>color</code> variant to TS via a string union type <code>color = "Red" | "Blue"</code>, and also provides all the converters to convert between the ReScript &amp; TS representation as well.</p>
<p>Therefore way we can seamlessly use ReScript specific data structures within TS without writing the converter code by hand!</p>
<p>Within our TypeScript application, we can now import and use the React component in the following manner:</p>
<pre class="codehilite"><code class="language-ts">// src/App.ts
import { make as MyComp } from &quot;./MyComp.gen.tsx&quot;;

const App = () =&gt; {
  return (&lt;div&gt;
    &lt;h1&gt; My Component &lt;/h1&gt;
    &lt;MyComp color=&quot;Blue&quot; name=&quot;ReScript &amp; TypeScript&quot; /&gt;
  &lt;/div&gt;);
};
</code></pre>

<p>That's it for our quick example.</p>
<p>For detailed information, head to the <a href="getting-started">Getting Started</a> or <a href="usage">Usage</a> section.</p>
<h2>Development</h2>
<p>Since ReScript v10.1, genType is part of the compiler's <a href="https://github.com/rescript-lang/rescript-compiler">GitHub repository</a>.</p><h1>getting-started</h1><hr />
<p>title: "Getting Started"
description: "How to get started with genType in your ReScript projects"
canonical: "/docs/gentype/latest/getting-started"</p>
<hr />
<h1>Getting Started</h1>
<h2>Setup</h2>
<p>Since compiler v10.1, there's no need to install anything. For compiler 10.0 or older, install the binaries via <code>npm</code> (or <code>yarn</code>):</p>
<pre class="codehilite"><code>npm install gentype --save-dev

# Verify installed gentype binary
npx gentype --help
</code></pre>

<p>Add a <code>gentypeconfig</code> section to your <code>rescript.json</code> (See <a href="#configuration">Configuration</a> for details):</p>
<pre class="codehilite"><code>&quot;gentypeconfig&quot;: {
    &quot;language&quot;: &quot;typescript&quot;,
    &quot;shims&quot;: {},
    &quot;generatedFileExtension&quot;: &quot;.gen.tsx&quot;,
    &quot;module&quot;: &quot;es6&quot;,
    &quot;debug&quot;: {
      &quot;all&quot;: false,
      &quot;basic&quot;: false
    }
}
</code></pre>

<h2>Configuration</h2>
<p>Every <code>genType</code> powered project requires a configuration item <code>"gentypeconfig"</code>
at top level in the project's <code>rescript.json</code>. The configuration has following
structure:</p>
<pre class="codehilite"><code class="language-js">  //...
  &quot;gentypeconfig&quot;: {
    &quot;language&quot;: &quot;typescript&quot;,
    &quot;generatedFileExtension&quot;: &quot;.gen.tsx&quot;,
    &quot;module&quot;: &quot;es6&quot; | &quot;commonjs&quot;,
    &quot;shims&quot;: {
      &quot;ReasonReact&quot;: &quot;ReactShim&quot;
    }
  }
</code></pre>

<ul>
<li><strong>generatedFileExtension</strong></li>
<li>
<p>File extension used for genType generated files (defaults to <code>.gen.tsx</code>)</p>
</li>
<li>
<p><strong>language</strong></p>
</li>
<li>
<p><code>"typescript"</code> : the <code>language</code> setting is not required from compiler v10.1</p>
</li>
<li>
<p><strong>module</strong></p>
</li>
<li>
<p>Module format used for the generated <code>*.gen.tsx</code> files (supports <code>"es6"</code> and <code>"commonjs"</code>)</p>
</li>
<li>
<p><strong>shims</strong></p>
</li>
<li>Required only if one needs to export certain basic ReScript data types to JS when one cannot modify the sources to add annotations (e.g. exporting ReScript lists), and if the types are not first-classed in genType.</li>
<li>Example: <code>Array&lt;string&gt;</code> with format: <code>"RescriptModule=JavaScriptModule"</code></li>
</ul>
<h2>Adding Shims</h2>
<p>A shim is a TS file that provides user-provided definitions for library types.</p>
<p>Configure your shim files within <code>"gentypeconfig"</code> in your <a href="https://github.com/rescript-lang/rescript-compiler/blob/master/jscomp/gentype_tests/typescript-react-example/rescript.json"><code>rescript.json</code></a>, and add relevant <code>.shims.ts</code> files in a directory which is visible by ReScript e.g.  <a href="https://github.com/rescript-lang/rescript-compiler/tree/master/jscomp/gentype_tests/typescript-react-example/src/shims"><code>src/shims/</code></a>. An example shim to export ReactEvent can be found <a href="https://github.com/rescript-lang/rescript-compiler/blob/master/jscomp/gentype_tests/typescript-react-example/src/shims/ReactEvent.shim.ts">here</a>.</p>
<h2>Testing the Whole Setup</h2>
<p>Open any relevant <code>*.res</code> file and add <code>@genType</code> annotations to any bindings / values / functions to be used from JavaScript. If an annotated value uses a type, the type must be annotated too. See e.g.  <a href="https://github.com/reason-association/genType/blob/master/examples/typescript-react-example/src/Hooks.res">Hooks.res</a>.</p>
<p>Save the file and rebuild the project via <code>npm run bs:build</code> or similar. You should now see a <code>*.gen.tsx</code> file with the same name (e.g. <code>MyComponent.res</code> -&gt; <code>MyComponent.gen.tsx</code>).</p>
<p>Any values exported from <code>MyComponent.res</code> can then be imported from JS. For example:</p>
<pre class="codehilite"><code class="language-js">import MyComponent from &quot;./components/MyComponent.gen&quot;;
</code></pre>

<h2>Examples</h2>
<p>We prepared some examples to give you an idea on how to integrate <code>genType</code> in your own project. Check out the READMEs of the listed projects.</p>
<ul>
<li><a href="https://github.com/rescript-lang/rescript-compiler/tree/master/jscomp/gentype_tests/typescript-react-example">typescript-react-example</a></li>
</ul>
<h2>Experimental features</h2>
<p>These features are for experimentation only. They could be changed/removed any time, and not be considered breaking changes.</p>
<ul>
<li>
<p>Export object and record types as interfaces. To activate, add <code>"exportInterfaces": true</code> to the configuration. The types are also renamed from <code>name</code> to <code>Iname</code>.</p>
</li>
<li>
<p>Emit prop types for the untyped back-end. To activate, add <code>"propTypes": true</code> and <code>"language": "untyped"</code> to the configuration.</p>
</li>
</ul>
<h2>Limitations</h2>
<ul>
<li>
<p><strong>in-source = true</strong>. Currently only supports ReScript projects with <a href="/docs/manual/latest/build-configuration#package-specs">in-source generation</a> and <code>.bs.js</code> file suffix.</p>
</li>
<li>
<p><strong>Limited namespace support</strong>. Currently there's limited <a href="/docs/manual/latest/build-configuration#name-namespace">namespace</a> support, and only <code>namespace:true</code> is possible, not e.g. <code>namespace:"custom"</code>.</p>
</li>
</ul><h1>supported-types</h1><hr />
<p>title: "Supported Types"
description: "Supported types and value convertion in GenType"
canonical: "/docs/gentype/latest/supported-types"</p>
<hr />
<h1>Supported Types</h1>
<p><Intro></p>
<p>Some types and values in ReScript do not map directly to JavaScript and need to be converted whenever a value crosses the boundary. This document gives an overview on how <code>genType</code>'s convertion works on different types.</p>
<p></Intro></p>
<h2>Int</h2>
<p>ReScript values e.g. <code>1</code>, <code>2</code>, <code>3</code> are unchanged. So they are exported to JS values of type <code>number</code>.</p>
<h2>Float</h2>
<p>ReScript values e.g. <code>1.0</code>, <code>2.0</code>, <code>3.0</code> are unchanged. So they are exported to JS values of type <code>number</code>.</p>
<h2>String</h2>
<p>ReScript values e.g. <code>"a"</code>, <code>"b"</code>, <code>"c"</code> are unchanged. So they are exported to JS values of type <code>string</code>.</p>
<h2>Optionals</h2>
<p>ReScript values of type e.g. <code>option&lt;int&gt;</code>, such as <code>None</code>, <code>Some(0)</code>, <code>Some(1)</code>, <code>Some(2)</code>, are exported to JS values <code>null</code>, <code>undefined</code>, <code>0</code>, <code>1</code>, <code>2</code>.
The JS values are unboxed, and <code>null</code>/<code>undefined</code> are conflated.
So the option type is exported to JS type <code>null</code> or <code>undefined</code> or <code>number</code>.</p>
<h2>Nullables</h2>
<p>ReScript values of type e.g. <code>Js.Nullable.t&lt;int&gt;</code>, such as <code>Js.Nullable.null</code>, <code>Js.Nullable.undefined</code>, <code>Js.Nullable.return(0)</code>, <code>Js.Nullable.return(1)</code>, <code>Js.Nullable.return(2)</code>, are exported to JS values <code>null</code>, <code>undefined</code>, <code>0</code>, <code>1</code>, <code>2</code>.
The JS values are identical: there is no conversion unless the argument type needs conversion.</p>
<h2>Records</h2>
<p>ReScript record values of type e.g. <code>{x: int}</code> such as <code>{x: 0}</code>, <code>{x: 1}</code>, are exported to JS values of type <code>{x: number}</code> without runtime conversion.</p>
<p>Since records are immutable by default, their fields will be exported to readonly property types in Flow/TS. Mutable fields are specified in ReScript by e.g. <code>{mutable mutableField: string}</code>.</p>
<p>The <code>@as</code> annotation can be used to change the name of a field on the JS side of things. So e.g. <code>{@as("y") x: int}</code> is exported as JS type <code>{y: number}</code>.</p>
<p>If one field of the ReScript record has option type, this is exported to an optional JS field. So for example ReScript type <code>{x: option&lt;int&gt;}</code> is exported as JS type <code>{x?: number}</code>.</p>
<h2>Objects</h2>
<p>ReScript object values of type e.g. <code>{. "x":int}</code> such as <code>{"x": 0}</code>, <code>{"x": 1}</code>, <code>{"x": 2}</code>, are exported as identical JS object values <code>{x:0}</code>, <code>{x:1}</code>, <code>{x:2}</code>. This requires no conversion. So they are exported to JS values of type <code>{x:number}</code>.
A conversion is required only when the type of some field requires conversions.</p>
<p>Since objects are immutable by default, their fields will be exported to readonly property types in Flow/TS. Mutable fields are specified in ReScript by e.g. <code>{ @set "mutableField": string }</code>.</p>
<p>It is possible to mix object and option types, so for example the ReScript type <code>{. "x":int, "y":option&lt;string&gt;}</code> exports to JS type <code>{x:number, ?y: string}</code>, requires no conversion, and allows option pattern matching on the ReScript side.</p>
<h2>Tuples</h2>
<p>ReScript tuple values of type e.g. <code>(int, string)</code> are exported as identical JS values of type <code>[number, string]</code>. This requires no conversion, unless one of types of the tuple items does.
While the type of ReScript tuples is immutable, there's currently no mature enforcement in TS/Flow, so they're currenty exported to mutable tuples.</p>
<h2>Variants</h2>
<p>Ordinary variants (with capitalized cases, e.g. <code>| A | B(int)</code>) and polymorphic variants (with a backtick, e.g. <code>| `A | `B(int)</code>) are represented in the same way, so there's no difference from the point of view of JavaScript. Polymorphic variants don't have to be capitalized.</p>
<p>Variants can have an <em>unboxed</em>, or a <em>boxed</em> representation. The unboxed representation is used when there is at most one case with a payload, and that payload has object type; otherwise, a boxed representation is used. Object types are arrays, objects, records and tuples.</p>
<p>Variants without payloads are essentially sequences of identifiers.
E.g. type <code>@genType type days = Monday | Tuesday</code>.
The corresponding JS representation is <code>"Monday"</code>, <code>"Tuesday"</code>.
Similarly, polymorphic variant type <code>@genType type days = [#Monday | #Tuesday]</code> has the same JS representation.</p>
<p>When at most one variant case has a payload, and if the payload is of object type, e.g.
<code>Unnamed | Named({. "name": string, "surname": string})</code>
then the representation is unboxed: JS values are e.g. <code>"Unnamed"</code> and
<code>{name: "hello", surname: "world"}</code>. Similarly for polymorphic variants.
Note that this unboxed representation does not use the label <code>"Named"</code> of the variant case with payload, because that value is distinguished from the other payload-less cases by its type: an object.</p>
<p>If there is more than one case with payload, or if the single payload has not type object, a boxed representation is used. The boxed representation has shape <code>{tag: "someTag", value: someValue}</code>.
For example, type <code>| A | B(int) | C(string)</code> has values such as <code>"A"</code> and
<code>{tag: "B", value: 42}</code> and <code>{tag: "C", value: "hello"}</code>.
Polymorhphic variants are treated similarly. Notice that payloads for polymorphic variants are always unary: <code>`Pair(int,int)</code> has a single payload of type <code>(int,int)</code>. Instead, ordinary variants distinguish between unary <code>Pair((int,int))</code> and binary <code>Pair(int,int)</code> payloads. All those cases are represented in JS as <code>{tag: "Pair", value: [3, 4]}</code>, and the conversion functions take care of the different ReScript representations.</p>
<p>The <code>@genType.as</code> annotation can be used to modify the name emitted for a variant case on the JS side. So e.g. <code>| @genType.as("Arenamed") A</code> exports ReScript value <code>A</code> to JS value <code>"Arenamed"</code>.
Boolean/integer/float constants can be expressed as <code>| @genType.as(true) True</code> and <code>| @genType.as(20) Twenty</code> and <code>| @genType.as(0.5) Half</code>. Similarly for polymorphic variants.
The <code>@genType.as</code> annotation can also be used on variants with payloads to determine what appears in <code>{ tag: ... }</code>.</p>
<p>For more examples, see <a href="https://github.com/reason-association/genType/tree/master/examples/typescript-react-example/src/Variants.res">Variants.res</a> and <a href="https://github.com/reason-association/genType/tree/master/examples/typescript-react-example/src/VariantsWithPayload.res">VariantsWithPayload.res</a>.</p>
<p><strong>NOTE:</strong> When exporting/importing values that have polymorphic variant type, you have to use type annotations, and cannot rely on type inference. So instead of <code>let monday = `Monday</code>, use <code>let monday : days = `Monday</code>. The former does not work, as the type checker infers a type without annotations.</p>
<h2>Arrays</h2>
<p>Arrays with elements of ReScript type <code>t</code> are exported to JS arrays with elements of the corresponding JS type. If a conversion is required, a copy of the array is performed.</p>
<p>Immutable arrays are supported with the additional ReScript library
<a href="https://github.com/reason-association/genType/tree/master/examples/typescript-react-example/src/ImmutableArray.resi">ImmutableArray.res/.resi</a>, which currently needs to be added to your project.
The type <code>ImmutableArray.t&lt;+'a&gt;</code> is covariant, and is mapped to readonly array types in TS/Flow. As opposed to TS/Flow, <code>ImmutableArray.t</code> does not allow casting in either direction with normal arrays. Instead, a copy must be performed using <code>fromArray</code> and <code>toArray</code>.</p>
<h2>Functions and Function Components</h2>
<p>ReScript functions are exported as JS functions of the corresponding type.
So for example a ReScript function <code>foo : int =&gt; int</code> is exported as a JS function from numbers to numbers.</p>
<p>If named arguments are present in the ReScript type, they are grouped and exported as JS objects. For example <code>foo : (~x:int, ~y:int) =&gt; int</code> is exported as a JS function from objects of type <code>{x:number, y:number}</code> to numbers.</p>
<p>In case of mixed named and unnamed arguments, consecutive named arguments form separate groups. So e.g. <code>foo : (int, ~x:int, ~y:int, int, ~z:int) =&gt; int</code> is exported to a JS function of type <code>(number, {x:number, y:number}, number, {z:number}) =&gt; number</code>.</p>
<p>Function components are exported and imported exactly like normal functions. For example:</p>
<pre class="codehilite"><code class="language-rescript">@genType
@react.component
let make = (~name) =&gt; React.string(name);
</code></pre>

<h2>Imported Types</h2>
<p>It's possible to import an existing TS/Flow type as an opaque type in ReScript. For example,</p>
<pre class="codehilite"><code class="language-res">@genType.import(&quot;./SomeFlowTypes&quot;) type weekday
</code></pre>

<p>defines a type which maps to <code>weekday</code> in <code>SomeFlowTypes.js</code>.
See for example <a href="https://github.com/reason-association/genType/tree/master/examples/flow-react-example/src/Types.res">Types.res</a> and <a href="https://github.com/reason-association/genType/tree/master/examples/flow-react-example/src/SomeFlowTypes.js">SomeFlowTypes.js</a>.</p>
<h2>Recursive Types</h2>
<p>Recursive types which do not require a conversion are fully supported.
If a recursive type requires a conversion, only a shallow conversion is performed, and a warning comment is included in the output. (The alternative would be to perform an expensive conversion down a data structure of arbitrary size).
See for example <a href="https://github.com/reason-association/genType/tree/master/examples/typescript-react-example/src/nested/Types.res">Types.res</a>.</p>
<h2>First Class Modules</h2>
<p>ReScript first class modules are converted from their array ReScript runtime representation to JS Object types.
For example,</p>
<pre class="codehilite"><code class="language-res">module type MT = {
  let x: int
  let y: string
}
module M = {
  let y = &quot;abc&quot;
  let x = 42
}

@genType
let firstClassModule: module(MT) = module(M)
</code></pre>

<p>is exported as a JS object of type</p>
<pre class="codehilite"><code class="language-res">{&quot;x&quot;: number, &quot;y&quot;: string}
</code></pre>

<p>Notice how the order of elements in the exported JS object is determined by the module type <code>MT</code> and not the module implementation <code>M</code>.</p>
<h2>Polymorphic Types</h2>
<p>If a ReScript type contains a type variable, the corresponding value is not converted. In other words, the conversion is the identity function. For example, a ReScript function of type <code>{payload: 'a} =&gt; 'a</code> must treat the value of the payload as a black box, as a consequence of parametric polymorphism. If a typed back-end is used, the ReScript type is converted to the corresponding generic type.</p>
<h3>Exporting Values from Polymorphic Types with Hidden Type Variables</h3>
<p>For cases when a value that contains a hidden type variable needs to be converted, a function can be used to produce the appropriate output:</p>
<p><strong>Doesn't work</strong></p>
<pre class="codehilite"><code class="language-res">@genType
let none = None
</code></pre>

<pre class="codehilite"><code class="language-js">export const none: ?T1 = OptionBS.none; // Errors out as T1 is not defined
</code></pre>

<p><strong>Works</strong></p>
<pre class="codehilite"><code class="language-res">@genType
let none = () =&gt; None
</code></pre>

<pre class="codehilite"><code class="language-js">const none = &lt;T1&gt;(a: T1): ?T1 =&gt; OptionBS.none;
</code></pre>

<h2>Promises</h2>
<p>Values of type <code>Js.Promise.t&lt;arg&gt;</code> are exported to JS promises of type <code>Promise&lt;argJS&gt;</code> where <code>argJS</code> is the JS type corresponding to <code>arg</code>.
If a conversion for the argument is required, the conversion functions are chained via <code>.then(promise =&gt; ...)</code>.</p><h1>usage</h1><h1>Usage</h1>
<p><Intro></p>
<p><code>genType</code> operates on two kinds of entities: <em>types</em> and <em>values</em>.
Each can be <em>exported</em> from ReScript to JS, or <em>imported</em> into ReScript from JS.
The main annotation is <code>@genType</code>, which by default means <em>export</em>.</p>
<p></Intro></p>
<h2>Export and Import Types</h2>
<p>The following exports a function type <code>callback</code> to JS:</p>
<pre class="codehilite"><code class="language-res">@genType
type callback = ReactEvent.Mouse.t =&gt; unit
</code></pre>

<p>To instead import a type called <code>complexNumber</code> from JS module <code>MyMath.ts</code> (or <code>MyMath.js</code>), use the <code>@genType.import</code> annotation:</p>
<pre class="codehilite"><code class="language-res">@genType.import(&quot;./MyMath&quot;)
type complexNumber
</code></pre>

<p>This imported type will be treated as opaque by ReScript.</p>
<h2>Export and Import Values</h2>
<p>To export a function <code>callback</code> to JS:</p>
<pre class="codehilite"><code class="language-res">@genType
let callback = _ =&gt; Js.log(&quot;Clicked&quot;);
</code></pre>

<p>To rename the function and export it as <code>CB</code> on the JS side, use</p>
<pre class="codehilite"><code class="language-res">@genType
@genType.as(&quot;CB&quot;)
let callback = _ =&gt; Js.log(&quot;Clicked&quot;);
</code></pre>

<p>or the more compact</p>
<pre class="codehilite"><code class="language-res">@genType(&quot;CB&quot;)
let callback = _ =&gt; Js.log(&quot;Clicked&quot;);
</code></pre>

<p>To import a function <code>realValue</code> from JS module <code>MyMath.ts</code> (or <code>MyMath.js</code>):</p>
<pre class="codehilite"><code class="language-res">@genType.import(&quot;./MyMath&quot;) /* JS module to import from. */
/* Name and type of the JS value to import. */
external realValue: complexNumber =&gt; float = &quot;realValue&quot;;
</code></pre>

<blockquote>
<p><strong>Note:</strong> With genType &lt; 2.17.0 or bucklescript &lt; 5.0.0, one had to add a line with <code>@bs.module</code> and the current file name. See the older <a href="https://github.com/cristianoc/genType/blob/v2.16.0/README.md">README</a>.</p>
</blockquote>
<p>Because of the <code>external</code> keyword, it's clear from context that this is an import, so you can also just use <code>@genType</code> and omit <code>.import</code>.</p>
<p>To import a default JS export, use a second argument to <code>@genType.import</code> e.g. <code>@genType.import(("./MyMath", "default"))</code>.</p>
<p>Similarly, to import a value with a different JS name, use e.g. <code>@genType.import(("./MyMath", "ValueStartingWithUpperCaseLetter"))</code>.</p>
<p>To import nested values, e.g. <code>Some.Nested.value</code>, use e.g. <code>@genType.import(("./MyMath", "Some.Nested.value"))</code>.</p>
<h2>Interface (.resi) and Implementation (.res) files</h2>
<p>If both <code>Foo.resi</code> and <code>Foo.res</code> exist, the annotations are taken from <code>Foo.resi</code>. The same happens with local modules: if present, the module type gets precedence.</p>
<p>The behaviour can be overridden by adding annotation <code>@genType.ignoreInterface</code> at the top of <code>Foo.resi</code>. Use case: expose implementation details to JS but not to ReScript.</p>
<h2>Type Expansion and @genType.opaque</h2>
<p>If an exported type <code>persons</code> references other types in its definition, those types are also exported by default, as long as they are defined in the same file:</p>
<pre class="codehilite"><code class="language-res">type name = string
type surname = string
type person = {name: name, surname: surname}

@genType
type persons = array&lt;person&gt;;
</code></pre>

<p>If however you wish to hide from JS the fact that <code>name</code> and <code>surname</code> are strings, you can do it with the <code>@genType.opaque</code> annotation:</p>
<pre class="codehilite"><code class="language-res">@genType.opaque
type name = string

@genType.opaque
type surname = string

type person = {
  name,
  surname,
};

@genType
type persons = array&lt;person&gt;;
</code></pre>

<h2>Renaming, @genType.as, and object mangling convention.</h2>
<p><strong>NOTE:</strong> Starting from ReScript 7.0.0, <code>@genType.as</code> on record fields will be discouraged,
as it incurs a runtime conversion cost. Use a runtime free <code>@as</code> instead.</p>
<p><strong>NOTE:</strong> Starting from ReScript 11.0.0, the object mangling is removed.</p>
<p>By default, entities with a given name are exported/imported with the same name. However, you might wish to change the appearence of the name on the JS side.</p>
<p>For example, to use a reserved keyword <code>type</code> as a record field:</p>
<pre class="codehilite"><code class="language-res">@genType
type shipment = {
  date: float,
  @genType.as(&quot;type&quot;)
  type_: string,
}
</code></pre>

<p>Object field names follow ReScript's mangling convention:</p>
<pre class="codehilite"><code>Remove trailing &quot;__&quot; if present.
Otherwise remove leading &quot;_&quot; when followed by an uppercase letter, or keyword.
</code></pre>

<p>This means that the analogous example with objects is:</p>
<pre class="codehilite"><code class="language-res">@genType
type shipment = {
  &quot;date&quot;: float,
  &quot;_type&quot;: string,
}
</code></pre>

<p>or the equivalent <code>"type__": string</code>.</p>
<p>Functions and function components also follow the mangling convention for labeled arguments:</p>
<pre class="codehilite"><code class="language-res">@genType
let exampleFunction = (~_type) =&gt; &quot;type: &quot; ++ _type

@genType
@react.component
let exampleComponent = (~_type) =&gt; React.string(&quot;type: &quot; ++ _type)
</code></pre>

<p>It is possible to use <code>@genType.as</code> for functions, though this is only maintained for backwards compatibility, and cannot be used on function components:</p>
<pre class="codehilite"><code class="language-res">@genType
let functionWithGenTypeAs =
  (~date: float) =&gt; @genType.as(&quot;type&quot;) (~type_: string) =&gt; ...
</code></pre>

<p><strong>NOTE:</strong> For technical reasons, it is not possible to use <code>@genType.as</code> on the first argument of a function.</p>
<h2>Dependent Projects / Libraries</h2>
<p>ReScript dependencies are specified in <code>bs-dependencies</code>.
For example, if the dependencies are <code>"bs-dependencies": ["somelibrary"]</code> and <code>somelibrary</code> contains <code>Common.res</code>, this looks up the types of <code>foo</code> in the library:</p>
<pre class="codehilite"><code class="language-res">@genType
let z = Common.foo;
</code></pre>

<p>Scoped packages of the form e.g. <code>@demo/somelibrary</code> are also supported.</p>
<p><strong>NOTE:</strong> The library must have been published with the <code>.gen.ts</code> files created by genType.</p><h1>components-and-props</h1><hr />
<p>title: Components and Props
description: "Basic concepts for components and props in ReScript &amp; React"
canonical: "/docs/react/latest/components-and-props"</p>
<hr />
<h1>Components and Props</h1>
<p><Intro></p>
<p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. </p>
<p></Intro></p>
<h2>What is a Component?</h2>
<p>A React component is a function describing a UI element that receives a <code>props</code> object as a parameter (data describing the dynamic parts of the UI) and returns a <code>React.element</code>. </p>
<p>The nice thing about this concept is that you can solely focus on the input and output. The component function receives some data and returns some opaque <code>React.element</code> that is managed by the React framework to render your UI.</p>
<blockquote>
<p>If you want to know more about the low level details on how a component interface is implemented, refer to the <a href="./beyond-jsx">Beyond JSX</a> page.</p>
</blockquote>
<h2>Component Example</h2>
<p>Let's start with a first example to see how a ReScript React component looks like:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// src/Greeting.res
@react.component
let make = () =&gt; {
  &lt;div&gt;
    {React.string(&quot;Hello ReScripters!&quot;)}
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">import * as React from &quot;react&quot;;

function Greeting(props) {
  return React.createElement(&quot;div&quot;, undefined, &quot;Hello ReScripters!&quot;);
}

var make = Greeting;
</code></pre>

<p></CodeTab></p>
<p><strong>Important:</strong> Always make sure to name your component function <code>make</code>.</p>
<p>We've created a <code>Greeting.res</code> file that contains a <code>make</code> function that doesn't receive any props (the function doesn't receive any parameters), and returns a <code>React.element</code> that represents <code>&lt;div&gt; Hello ReScripters! &lt;/div&gt;</code> in the rendered DOM.</p>
<p>You can also see in the the JS output that the function we created was directly translated into the pure JS version of a ReactJS component. Note how a  <code>&lt;div&gt;</code> transforms into a <code>React.createElement("div",...)</code> call in JavaScript.</p>
<h2>Defining Props</h2>
<p>In ReactJS, props are usually described as a single <code>props</code> record. In ReScript, we use <a href="/docs/manual/latest/function#labeled-arguments">labeled arguments</a> to define our props parameters instead. Here's an example:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// src/Article.res
@react.component
let make = (~title: string, ~visitorCount: int, ~children: React.element) =&gt; {
  let visitorCountMsg = &quot;You are visitor number: &quot; ++ Belt.Int.toString(visitorCount);
  &lt;div&gt;
    &lt;div&gt; {React.string(title)} &lt;/div&gt;
    &lt;div&gt; {React.string(visitorCountMsg)} &lt;/div&gt;
    children
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">import * as React from &quot;react&quot;;

function Article(props) {
  var visitorCountMsg = &quot;You are visitor number: &quot; + String(props.visitorCount);
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;div&quot;, undefined, props.title), React.createElement(&quot;div&quot;, undefined, visitorCountMsg), props.children);
}

var make = Article;
</code></pre>

<p></CodeTab></p>
<h3>Optional Props</h3>
<p>We can leverage the full power of labeled arguments to define optional props as well:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Greeting.res
@react.component
let make = (~name: option&lt;string&gt;=?) =&gt; {
  let greeting = switch name {
  | Some(name) =&gt; &quot;Hello &quot; ++ name ++ &quot;!&quot;
  | None =&gt; &quot;Hello stranger!&quot;
  }
  &lt;div&gt; {React.string(greeting)} &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function Greeting(props) {
  var name = props.name;
  var greeting = name !== undefined ? &quot;Hello &quot; + name + &quot;!&quot; : &quot;Hello stranger!&quot;;
  return React.createElement(&quot;div&quot;, undefined, greeting);
}
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> The <code>@react.component</code> attribute implicitly adds the last <code>()</code> parameter to our <code>make</code> function for us (no need to do it ourselves). </p>
<p>In JSX, you can apply optional props with some special syntax:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let name = Some(&quot;Andrea&quot;)

&lt;Greeting ?name /&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">var name = &quot;Andrea&quot;;

React.createElement(Greeting, {
  name: name
});
</code></pre>

<p></CodeTab></p>
<h3>Special Props <code>key</code> and <code>ref</code></h3>
<p>You can't define any props called <code>key</code> or <code>ref</code>. React treats those props differently and the compiler will yield an error whenever you try to define a <code>~key</code> or <code>~ref</code> argument in your component function.</p>
<p>Check out the corresponding <a href="./arrays-and-keys">Arrays and Keys</a> and <a href="./forwarding-refs">Forwarding React Refs</a> sections for more details.</p>
<h3>Handling Invalid Prop Names (e.g. keywords)</h3>
<p>Prop names like <code>type</code> (as in <code>&lt;input type="text" /&gt;</code>) aren't syntactically valid; <code>type</code> is a reserved keyword in ReScript. Use <code>&lt;input type_="text" /&gt;</code> instead. </p>
<p>For <code>aria-*</code> use camelCasing, e.g., <code>ariaLabel</code>. For DOM components, we'll translate it to <code>aria-label</code> under the hood.</p>
<p>For <code>data-*</code> this is a bit trickier; words with <code>-</code> in them aren't valid in ReScript. When you do want to write them, e.g., <code>&lt;div data-name="click me" /&gt;</code>, check out the <a href="./elements-and-jsx#cloning-elements">React.cloneElement</a> or <a href="./elements-and-jsx#creating-dom-elements">React.createDOMElementVariadic</a> section.</p>
<h2>Children Props</h2>
<p>In React <code>props.children</code> is a special attribute to represent the nested elements within a parent element:</p>
<pre class="codehilite"><code class="language-res">let element = &lt;div&gt; child1 child2 &lt;/div&gt;
</code></pre>

<p>By default, whenever you are passing children like in the expression above, <code>children</code> will be treated
as a <code>React.element</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">module MyList = {
  @react.component
  let make = (~children: React.element) =&gt; {
    &lt;ul&gt;
      children
    &lt;/ul&gt;
  }
}

&lt;MyList&gt;
  &lt;li&gt; {React.string(&quot;Item 1&quot;)} &lt;/li&gt;
  &lt;li&gt; {React.string(&quot;Item 2&quot;)} &lt;/li&gt;
&lt;/MyList&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">function MyList(props) {
  return React.createElement(&quot;ul&quot;, undefined, props.children);
}

var MyList = {
  make: MyList
};

React.createElement(MyList, {
    children: null
  }, React.createElement(&quot;li&quot;, undefined, &quot;Item 1&quot;),
    React.createElement(&quot;li&quot;, undefined, &quot;Item 2&quot;));
</code></pre>

<p></CodeTab></p>
<p>Interestingly, it doesn't matter if you are passing just one element, or several, React will always collapse its children to a single <code>React.element</code>.</p>
<p>It is also possible to redefine the <code>children</code> type as well. Here are some examples:</p>
<p><strong>Component with a mandatory <code>string</code> as children:</strong></p>
<pre class="codehilite"><code class="language-res">module StringChildren = {
  @react.component
  let make = (~children: string) =&gt; {
    &lt;div&gt;
      {React.string(children)}
    &lt;/div&gt;
  }
}

&lt;StringChildren&gt; &quot;My Child&quot; &lt;/StringChildren&gt;

// This will cause a type check error
&lt;StringChildren/&gt;
</code></pre>

<p><strong>Component with an optional <code>React.element</code> as children:</strong></p>
<pre class="codehilite"><code class="language-res">module OptionalChildren = {
  @react.component
  let make = (~children: option&lt;React.element&gt;=?) =&gt; {
    &lt;div&gt;
      {switch children {
      | Some(element) =&gt; element
      | None =&gt; React.string(&quot;No children provided&quot;)
      }}
    &lt;/div&gt;
  }
}

&lt;div&gt;
  &lt;OptionalChildren /&gt;
  &lt;OptionalChildren&gt; &lt;div /&gt; &lt;/OptionalChildren&gt;
&lt;/div&gt;
</code></pre>

<p><strong>Component that doesn't allow children at all:</strong></p>
<pre class="codehilite"><code class="language-res">module NoChildren = {
  @react.component
  let make = () =&gt; {
    &lt;div&gt;
      {React.string(&quot;I don't accept any children params&quot;)}
    &lt;/div&gt;
  }
}

// The compiler will raise a type error here
&lt;NoChildren&gt; &lt;div/&gt; &lt;/NoChildren&gt;
</code></pre>

<p>Children props are really tempting to be abused as a way to model hierarchies, e.g. <code>&lt;List&gt; &lt;ListHeader/&gt; &lt;Item/&gt; &lt;/List&gt;</code> (<code>List</code> should only allow <code>Item</code> / <code>ListHeader</code> elements), but this kind of constraint is hard to enforce because all components end up being a <code>React.element</code>, so it would require notorious runtime checking within <code>List</code> to verify that all children are in fact of type <code>Item</code> or <code>ListHeader</code>.</p>
<p>The best way to approach this kind of issue is by using props instead of children, e.g. <code>&lt;List header="..." items=[{id: "...", text: "..."}]/&gt;</code>. This way it's easy to type check the constraints, and it also spares component consumers from memorizing and remembering component constraints.</p>
<p><strong>The best use-case for <code>children</code> is to pass down <code>React.element</code>s without any semantic order or implementation details!</strong></p>
<h2>Props &amp; Type Inference</h2>
<p>The ReScript type system is really good at inferring the prop types just by looking at its prop usage. </p>
<p>For simple cases, well-scoped usage, or experimentation, it's still fine to omit type annotations:</p>
<pre class="codehilite"><code class="language-res">// Button.res

@react.component
let make = (~onClick, ~msg, ~children) =&gt; {
  &lt;div onClick&gt;
    {React.string(msg)}
    children
  &lt;/div&gt;
}
</code></pre>

<p>In the example above, <code>onClick</code> will be inferred as <code>ReactEvent.Mouse.t =&gt; unit</code>, <code>msg</code> as <code>string</code> and <code>children</code> as <code>React.element</code>. Type inference is especially useful when you just forward values to some smaller (privately scoped) functions.</p>
<p>Even though type inference spares us a lot of keyboard typing, we still recommend to explicitly type your props (just like with any public API) for better type visibility and to prevent confusing type errors.</p>
<h2>Using Components in JSX</h2>
<p>Every ReScript component can be used in JSX. For example, if we want to use our <code>Greeting</code> component within our <code>App</code> component, we can do this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// src/App.res

@react.component
let make = () =&gt; {
  &lt;div&gt;
    &lt;Greeting/&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">var React = require(&quot;react&quot;);
var Greeting = require(&quot;./Greeting.js&quot;)

function App(Props) {
  return React.createElement(&quot;div&quot;, undefined, React.createElement(Greeting.make, {}));
}

var make = App;
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> React components are capitalized; primitive DOM elements like <code>div</code> or <code>button</code> are uncapitalized. More infos on the JSX specifics and code transformations can be found in our <a href="/docs/manual/latest/jsx#capitalized-tag">JSX language manual section</a>.</p>
<h3>Handwritten Components</h3>
<p>You don't need to use the <code>@react.component</code> decorator to write components that can be used in JSX. Instead you can write the <code>make</code> function with type <code>props</code> and these will always work as React components. But then you will have the issue with the component name being "make" in the React dev tools.</p>
<p>For example:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">module Link = {
  type props = {href: string, children: React.element};

  let make = (props: props) =&gt; { 
    &lt;a href={props.href}&gt;
     {props.children}
    &lt;/a&gt;
  }
}

&lt;Link href=&quot;/docs&quot;&gt; {React.string(&quot;Docs&quot;)} &lt;/Link&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">function make(props) {
  return React.createElement(
    &quot;a&quot;,
    { href: props.href },
    props.children
  );
}

var Link = {
  make: make,
};

React.createElement(make, {
  href: &quot;/docs&quot;,
  children: &quot;Docs&quot;,
});
</code></pre>

<p></CodeTab></p>
<p>More details on the <code>@react.component</code> decorator and its generated interface can be found in our <a href="./beyond-jsx">Beyond JSX</a> page.</p>
<h2>Submodule Components</h2>
<p>We can also represent React components as submodules, which makes it very convenient to build more complex UI without the need to create multiple files for each composite component (that's probably only used by the parent component anyways): </p>
<pre class="codehilite"><code class="language-res">// src/Button.res
module Label = {
  @react.component
  let make = (~title: string) =&gt; {
    &lt;div className=&quot;myLabel&quot;&gt; {React.string(title)} &lt;/div&gt;
  }
}

@react.component
let make = (~children) =&gt; {
  &lt;div&gt;
    &lt;Label title=&quot;Getting Started&quot; /&gt;
    children
  &lt;/div&gt;
}
</code></pre>

<p>The <code>Button.res</code> file defined above is now containing a <code>Label</code> component, that can also be used by other components, either by writing the fully qualified module name (<code>&lt;Button.Label title="My Button"/&gt;</code>) or by using a module alias to shortcut the full qualifier:</p>
<pre class="codehilite"><code class="language-res">module Label = Button.Label

let content = &lt;Label title=&quot;Test&quot;/&gt;
</code></pre>

<h2>Component Naming</h2>
<p>Because components are actually a pair of functions, they have to belong to a module to be used in JSX. It makes sense to use these modules for identification purposes as well. <code>@react.component</code> automatically adds the name for you based on the module you are in.</p>
<pre class="codehilite"><code class="language-res">// File.res

// will be named `File` in dev tools
@react.component
let make = ...

// will be named `File$component` in dev tools
@react.component
let component = ...

module Nested = {
  // will be named `File$Nested` in dev tools
  @react.component
  let make = ...
};
</code></pre>

<p>If you need a dynamic name for higher-order components or you would like to set your own name you can use <code>React.setDisplayName(make, "NameThatShouldBeInDevTools")</code>.</p>
<h2>Tips &amp; Tricks</h2>
<ul>
<li>Start with one component file and utilize submodule components as your component grows. Consider splitting up in multiple files when really necessary.</li>
<li>Keep your directory hierarchy flat. Instead of <code>article/Header.res</code> use <code>ArticleHeader.res</code> etc. Filenames are unique across the codebase, so filenames tend to be very specific <code>ArticleUserHeaderCard.res</code>, which is not necessarily a bad thing, since it clearly expresses the intent of the component within its name, and makes it also very easy to find, match and refactor across the whole codebase.</li>
</ul><h1>hooks-ref</h1><hr />
<p>title: useRef Hook
description: "Details about the useRef React hook in ReScript"
canonical: "/docs/react/latest/hooks-ref"</p>
<hr />
<h1>useRef</h1>
<p><Intro></p>
<p>The <code>useRef</code> hooks creates and manages mutable containers inside your React component.</p>
<p></Intro></p>
<h2>Usage</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let refContainer = React.useRef(initialValue);
</code></pre>

<pre class="codehilite"><code class="language-js">  var button = React.useRef(null);
  React.useRef(0);
</code></pre>

<p></CodeTab></p>
<p><code>React.useRef</code> returns a mutable ref object whose <code>.current</code> record field is initialized to the passed argument (<code>initialValue</code>). The returned object will persist for the full lifetime of the component.</p>
<p>Essentially, a <code>React.ref</code> is like a "box" that can hold a mutable value in its <code>.current</code> record field.</p>
<p>You might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with <code>&lt;div ref={ReactDOM.Ref.domRef(myRef)} /&gt;</code>, React will set its <code>.current</code> property to the corresponding DOM node whenever that node changes.</p>
<p>However, <code>useRef()</code> is useful for more than the ref attribute. It's handy for keeping any mutable value around similar to how you’d use instance fields in classes.</p>
<p>This works because <code>useRef()</code> creates a plain JavaScript object. The only difference between <code>useRef()</code> and creating a <code>{current: ...}</code> object yourself is that useRef will give you the same ref object on every render.</p>
<p>Keep in mind that <code>useRef</code> doesn’t notify you when its content changes. Mutating the <code>.current</code> record field doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a <a href="./refs-and-the-dom#callback-refs">callback ref</a> instead.</p>
<p>More infos on direct DOM manipulation can be found in the <a href="./refs-and-the-dom">Refs and the DOM</a> section.</p>
<h2>Examples</h2>
<h3>Managing Focus for a Text Input</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// TextInputWithFocusButton.res

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

@react.component
let make = () =&gt; {
  let inputEl = React.useRef(Js.Nullable.null)

  let onClick = _ =&gt; {
    inputEl.current
    -&gt;Js.Nullable.toOption
    -&gt;Belt.Option.forEach(input =&gt; input-&gt;focus)
  }

  &lt;&gt;
    &lt;input ref={ReactDOM.Ref.domRef(inputEl)} type_=&quot;text&quot; /&gt;
    &lt;button onClick&gt; {React.string(&quot;Focus the input&quot;)} &lt;/button&gt;
  &lt;/&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function TextInputWithFocusButton(Props) {
  var inputEl = React.useRef(null);
  var onClick = function (param) {
    return Belt_Option.forEach(Caml_option.nullable_to_opt(inputEl.current), (function (input) {
                  input.focus();

                }));
  };
  return React.createElement(React.Fragment, undefined, React.createElement(&quot;input&quot;, {
                  ref: inputEl,
                  type: &quot;text&quot;
                }), React.createElement(&quot;button&quot;, {
                  onClick: onClick
                }, &quot;Focus the input&quot;));
}
</code></pre>

<p></CodeTab></p>
<h3>Using a Callback Ref</h3>
<p>Reusing the example from our <a href="./refs-and-the-dom#callback-refs">Refs and the DOM</a> section:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// CustomTextInput.res

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

@react.component
let make = () =&gt; {
  let textInput = React.useRef(Js.Nullable.null)
  let setTextInputRef = element =&gt; {
    textInput.current = element;
  }

  let focusTextInput = _ =&gt; {
    textInput.current
    -&gt;Js.Nullable.toOption
    -&gt;Belt.Option.forEach(input =&gt; input-&gt;focus)
  }

  &lt;div&gt;
    &lt;input type_=&quot;text&quot; ref={ReactDOM.Ref.callbackDomRef(setTextInputRef)} /&gt;
    &lt;input
      type_=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={focusTextInput}
    /&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function CustomTextInput(Props) {
  var textInput = React.useRef(null);
  var setTextInputRef = function (element) {
    textInput.current = element;

  };
  var focusTextInput = function (param) {
    return Belt_Option.forEach(Caml_option.nullable_to_opt(textInput.current), (function (input) {
                  input.focus();

                }));
  };
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;input&quot;, {
                  ref: setTextInputRef,
                  type: &quot;text&quot;
                }), React.createElement(&quot;input&quot;, {
                  type: &quot;button&quot;,
                  value: &quot;Focus the text input&quot;,
                  onClick: focusTextInput
                }));
}
</code></pre>

<p></CodeTab></p><h1>hooks-overview</h1><hr />
<p>title: Hooks &amp; State Management Overview
description: "Overview state management and hooks in ReScript and React"
canonical: "/docs/react/latest/hooks-overview"</p>
<hr />
<h1>Hooks Overview</h1>
<p><Intro></p>
<p>Hooks are an essential mechanism to introduce and manage state and effects in React components.</p>
<p></Intro></p>
<h2>What is a Hook?</h2>
<p>In the previous chapters we learned how React components are just a simple function representing UI based on specific prop values. For an application to be useful we still need a way to manipulate those props interactively either via user input or via requests loading in data from a server.</p>
<p>That's where Hooks come in. A Hook is a function that allows us to introduce component state and trigger side-effects for different tasks, such as HTTP requests, direct HTML DOM access, querying window sizes, etc. </p>
<p>In other words: <strong>It allows us to "hook into" React features.</strong></p>
<h3>Example: The <code>useState</code> Hook</h3>
<p>Just for a quick look, here is an example of a <code>Counter</code> component that allows a user to click a button and increment an <code>count</code> value that will immediately be rendered on each button click: </p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Counter.res
@react.component
let make = () =&gt; {
  let (count, setCount) = React.useState(_ =&gt; 0);

  let onClick = (_evt) =&gt; {
    setCount(prev =&gt; prev + 1)
  };

  let msg = &quot;You clicked&quot; ++ Belt.Int.toString(count) ++  &quot;times&quot;

  &lt;div&gt;
    &lt;p&gt;{React.string(msg)}&lt;/p&gt;
    &lt;button onClick&gt; {React.string(&quot;Click me&quot;)} &lt;/button&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function Counter(Props) {
  var match = React.useState(function () {
        return 0;
      });
  var setCount = match[1];
  var onClick = function (_evt) {
    return Curry._1(setCount, (function (prev) {
                  return prev + 1 | 0;
                }));
  };
  var msg = &quot;You clicked&quot; + String(match[0]) + &quot;times&quot;;
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;p&quot;, undefined, msg), React.createElement(&quot;button&quot;, {
                  onClick: onClick
                }, &quot;Click me&quot;));
}
</code></pre>

<p></CodeTab></p>
<p>Here we are using the <code>React.useState</code> Hook. We call it inside a component function to add some local state to it. React will preserve this state between re-renders. <code>React.useState</code> returns a tuple: the current state value (<code>count</code>) and a function that lets you update it (<code>setCount</code>). You can call this function from an event handler or pass it down to other components to call the function. </p>
<p>The only argument to <code>React.useState</code> is a function that returns the initial state (<code>_ =&gt; 0</code>). In the example above, it is 0 because our counter starts from zero. Note that your state can be any type you want and <code>ReScript</code> will make sure to infer the types for you (only make sure to return an initial state that matches your type). The initial state argument is only used during the first render.</p>
<p>This was just a quick example on our first hook usage. We will go into more detail in a dedicated <a href="./hooks-state">useState</a> section.</p>
<h2>Available Hooks</h2>
<p><strong>Note:</strong> All hooks are part of the <code>React</code> module (e.g. <code>React.useState</code>).</p>
<h3>Basic Hooks:</h3>
<ul>
<li><a href="./hooks-state">useState</a>: Adds local state to your component</li>
<li><a href="./hooks-effect">useEffect</a>: Runs side-effectual code within your component</li>
<li><a href="./hooks-context">useContext</a>: Gives your component to a React Context value</li>
</ul>
<h3>Additional Hooks:</h3>
<ul>
<li><a href="./hooks-reducer">useReducer</a>: An alternative to <code>useState</code>. Uses the state / action / reduce pattern.</li>
</ul>
<!-- - [useCallback](./hooks-callback): Returns a memoized callback -->
<!-- - [useMemo](./hooks-memo): Returns a memoized value -->
<ul>
<li><a href="./hooks-ref">useRef</a>: Returns a mutable React-Ref value</li>
</ul>
<!-- - [useImperativeHandle](./hooks-imperative-handle): Customizes the instance value that is exposed to parent components when using `ref` -->
<!-- - [useLayoutEffect](./hooks-layout-effect): Identical to useEffect, but it fires synchronously after all DOM mutations. -->

<h2>Rules of Hooks</h2>
<p>Hooks are just simple functions, but you need to follow <em>two rules</em> when using them. ReScript doesn't enforce those rules within the compiler, so if you really want to enforce correct hooks conventions, you can use an <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin</a> to check your compiled JS output.</p>
<h3>Rule 1) Only Call Hooks at the Top Level</h3>
<p><strong>Don’t call Hooks inside loops, conditions, or nested functions.</strong> Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That’s what allows React to correctly preserve the state of Hooks between multiple <code>useState</code> and <code>useEffect</code> calls. (If you’re curious, you can check out the in depth explanation in the <a href="https://reactjs.org/docs/hooks-rules.html#explanation">ReactJS Hooks docs</a>)</p>
<h3>Rule 2) Only Call Hooks from React Functions</h3>
<p><strong>Don't call Hooks from regular functions.</strong> Instead, you can:</p>
<ul>
<li>✅ Call Hooks from React function components.</li>
<li>✅ Call Hooks from custom Hooks (we’ll learn about them in our <a href="./hooks-custom">custom hooks</a> section).</li>
</ul>
<p>By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.</p><h1>refs-and-the-dom</h1><hr />
<p>title: Refs and the DOM
description: "Using Refs and DOM elements in ReScript and React"
canonical: "/docs/react/latest/refs-and-the-dom"</p>
<hr />
<h1>Refs and the DOM</h1>
<p><Intro></p>
<p>Refs provide a way to access DOM nodes or React elements created within your <code>make</code> component function.</p>
<p></Intro></p>
<p>In the typical React dataflow, <a href="./components-and-props">props</a> are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an <code>React.element</code>, or it could be a <code>Dom.element</code>. For both of these cases, React provides an escape hatch.</p>
<p>A <code>React.ref</code> is defined like this:</p>
<pre class="codehilite"><code class="language-res">type t&lt;'value&gt; = { mutable current: 'value }
</code></pre>

<blockquote>
<p><em>Note that the <code>Ref.ref</code> should not to be confused with the builtin <a href="/docs/manual/latest/mutation">ref type</a>, the language feature that enables mutation.</em></p>
</blockquote>
<h2>When to use Refs</h2>
<p>There are a few good use cases for refs:</p>
<ul>
<li>Managing state that <em>should not trigger</em> any re-render.</li>
<li>Managing focus, text selection, or media playback.</li>
<li>Triggering imperative animations.</li>
<li>Integrating with third-party DOM libraries.</li>
</ul>
<p>Avoid using refs for anything that can be done declaratively.</p>
<h2>Creating Refs</h2>
<p>A React ref is represented as a <code>React.ref('value)</code> type, a container managing a mutable value of type <code>'value</code>. You can create this kind of ref with the <a href="./hooks-ref">React.useRef</a> hook:</p>
<pre class="codehilite"><code class="language-res">@react.component
let make = () =&gt; {
  let clicks = React.useRef(0);

  let onClick = (_) =&gt; {
    clicks.current = clicks.current + 1;
  };

  &lt;div onClick&gt;
    {Belt.Int.toString(clicks.current)-&gt;React.string}
  &lt;/div&gt;
}
</code></pre>

<p>The example above defines a binding <code>clicks</code> of type <code>React.ref(int)</code>. Note how changing the value <code>clicks.current</code> doesn't trigger any re-rendering of the component.</p>
<h2>Accessing Refs</h2>
<p>When a ref is passed to an element during render, a reference to the node becomes accessible at the current attribute of the ref.</p>
<pre class="codehilite"><code class="language-res">let value = myRef.current
</code></pre>

<p>The value of the ref differs depending on the type of the node:
- When the ref attribute is used on an HTML element, the ref passed via <code>ReactDOM.Ref.domRef</code> receives the underlying DOM element as its current property (type of <code>React.ref&lt;Js.Nullable.t&lt;Dom.element&gt;&gt;</code>)
- In case of interop, when the ref attribute is used on a custom class component (based on JS classes), the ref object receives the mounted instance of the component as its current (not discussed in this document).
- <strong>You may not use the ref attribute on component functions</strong> because they don’t have instances (we don't expose JS classes in ReScript).</p>
<p>Here are some examples:</p>
<h3>Adding a Ref to a DOM Element</h3>
<p>This code uses a <code>React.ref</code> to store a reference to an <code>input</code> DOM node to put focus on a text field when a button was clicked:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// CustomTextInput.res

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

@react.component
let make = () =&gt; {
  let textInput = React.useRef(Js.Nullable.null)

  let focusInput = () =&gt;
    switch textInput.current-&gt;Js.Nullable.toOption {
    | Some(dom) =&gt; dom-&gt;focus
    | None =&gt; ()
    }

  let onClick = _ =&gt; focusInput()

  &lt;div&gt;
    &lt;input type_=&quot;text&quot; ref={ReactDOM.Ref.domRef(textInput)} /&gt;
    &lt;input type_=&quot;button&quot; value=&quot;Focus the text input&quot; onClick /&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function CustomTextInput(Props) {
  var textInput = React.useRef(null);
  var onClick = function (param) {
    var dom = textInput.current;
    if (!(dom == null)) {
      dom.focus();
      return ;
    }

  };
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;input&quot;, {
                  ref: textInput,
                  type: &quot;text&quot;
                }), React.createElement(&quot;input&quot;, {
                  type: &quot;button&quot;,
                  value: &quot;Focus the text input&quot;,
                  onClick: onClick
                }));
}
</code></pre>

<p></CodeTab></p>
<p>A few things happened here, so let's break them down:</p>
<ul>
<li>We initialize our <code>textInput</code> ref as a <code>Js.Nullable.null</code></li>
<li>We register our <code>textInput</code> ref in our <code>&lt;input&gt;</code> element with <code>ReactDOM.Ref.domRef(textInput)</code></li>
<li>In our <code>focusInput</code> function, we need to first verify that our DOM element is set, and then use the <code>focus</code> binding to set the focus</li>
</ul>
<p>React will assign the <code>current</code> field with the DOM element when the component mounts, and assign it back to null when it unmounts.</p>
<h3>Refs and Component Functions</h3>
<p>In React, you <strong>can't</strong> pass a <code>ref</code> attribute to a component function:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">module MyComp = {
  @react.component
  let make = (~ref) =&gt; &lt;input /&gt;
}

@react.component
let make = () =&gt; {
  let textInput = React.useRef(Js.Nullable.null)

  // This will **not** work
  &lt;MyComp ref={ReactDOM.Ref.domRef(textInput)} /&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">// Compiler Error:
// Ref cannot be passed as a normal prop. Please use `forwardRef`
// API instead
</code></pre>

<p></CodeTab></p>
<p>The snippet above will not compile and output an error that looks like this: <code>"Ref cannot be passed as a normal prop. Please use forwardRef API instead."</code>.</p>
<p>As the error message implies, If you want to allow people to take a ref to your component function, you can use <a href="./forwarding-refs">ref forwarding</a> (possibly in conjunction with useImperativeHandle) instead.</p>
<h2>Exposing DOM Refs to Parent Components</h2>
<p>In rare cases, you might want to have access to a child’s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.</p>
<p>we recommend to use <a href="./forwarding-refs">ref forwarding</a> for these cases. <strong>Ref forwarding lets components opt into exposing any child component’s ref as their own</strong>. You can find a detailed example of how to expose a child’s DOM node to a parent component in the ref forwarding documentation.</p>
<h2>Callback Refs</h2>
<p>React also supports another way to set refs called “callback refs” (<code>React.Ref.callbackDomRef</code>), which gives more fine-grain control over when refs are set and unset.</p>
<p>Instead of passing a ref value created by <code>React.useRef()</code>, you can pass in a callback function. The function receives the target <code>Dom.element</code> as its argument, which can be stored and accessed elsewhere.</p>
<p><strong>Note:</strong> Usually we'd use <code>React.Ref.domRef()</code> to pass a ref value, but for callback refs, we use <code>React.Ref.callbackDomRef()</code> instead.</p>
<p>The example below implements a common pattern: using the ref callback to store a reference to a DOM node in an instance property.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// CustomTextInput.res

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

@react.component
let make = () =&gt; {
  let textInput = React.useRef(Js.Nullable.null)
  let setTextInputRef = element =&gt; {
    textInput.current = element;
  }

  let focusTextInput = _ =&gt; {
    textInput.current
    -&gt;Js.Nullable.toOption
    -&gt;Belt.Option.forEach(input =&gt; input-&gt;focus)
  }

  &lt;div&gt;
    &lt;input type_=&quot;text&quot; ref={ReactDOM.Ref.callbackDomRef(setTextInputRef)} /&gt;
    &lt;input
      type_=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={focusTextInput}
    /&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function CustomTextInput(Props) {
  var textInput = React.useRef(null);
  var setTextInputRef = function (element) {
    textInput.current = element;

  };
  var focusTextInput = function (param) {
    return Belt_Option.forEach(Caml_option.nullable_to_opt(textInput.current), (function (input) {
                  input.focus();

                }));
  };
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;input&quot;, {
                  ref: setTextInputRef,
                  type: &quot;text&quot;
                }), React.createElement(&quot;input&quot;, {
                  type: &quot;button&quot;,
                  value: &quot;Focus the text input&quot;,
                  onClick: focusTextInput
                }));
}
</code></pre>

<p></CodeTab></p>
<p>React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts.</p>
<p>You can pass callback refs between components like you can with object refs that were created with <code>React.useRef()</code>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Parent.res

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

module CustomTextInput = {
  @react.component
  let make = (~setInputRef) =&gt; {
    &lt;div&gt;
      &lt;input type_=&quot;text&quot; ref={ReactDOM.Ref.callbackDomRef(setInputRef)} /&gt;
    &lt;/div&gt;
  }
}

@react.component
let make = () =&gt; {
  let textInput = React.useRef(Js.Nullable.null)
  let setInputRef = element =&gt; { textInput.current = element}

  &lt;CustomTextInput setInputRef/&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function CustomTextInput(Props) {
  var setInputRef = Props.setInputRef;
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;input&quot;, {
                  ref: setInputRef,
                  type: &quot;text&quot;
                }));
}

var CustomTextInput = {
  make: CustomTextInput
};

function Parent(Props) {
  var textInput = React.useRef(null);
  var setInputRef = function (element) {
    textInput.current = element;

  };
  return React.createElement(CustomTextInput, {
              setInputRef: setInputRef
            });
}
</code></pre>

<p></CodeTab></p>
<p>In the example above, <code>Parent</code> passes its ref callback as an <code>setInputRef</code> prop to the <code>CustomTextInput</code>, and the <code>CustomTextInput</code> passes the same function as a special ref attribute to the <code>&lt;input&gt;</code>. As a result, the <code>textInput</code> ref in Parent will be set to the DOM node corresponding to the <code>&lt;input&gt;</code> element in the <code>CustomTextInput</code>.</p><h1>arrays-and-keys</h1><hr />
<p>title: Arrays and Keys
description: "Rendering arrays and handling keys in ReScript and React"
canonical: "/docs/react/latest/arrays-and-keys"</p>
<hr />
<h1>Arrays and Keys</h1>
<p><Intro></p>
<p>Whenever we are transforming data into an array of elements and put it in our React tree, we need to make sure to give every element an unique identifier to help React distinguish elements for each render. This page will explain the <code>key</code> attribute and how to apply it whenever we need to map data to <code>React.element</code>s.</p>
<p></Intro></p>
<h2>Keys &amp; Rendering Arrays</h2>
<p>Keys help React identify which elements have been changed, added, or removed throughout each render. Keys should be given to elements inside the array to give the elements a stable identity:</p>
<pre class="codehilite"><code class="language-res">let numbers = [1, 2, 3, 4, 5];

let items = Belt.Array.map(numbers, (number) =&gt; {
  &lt;li key={Belt.Int.toString(number)}&gt; {React.int(number)} &lt;/li&gt;
})
</code></pre>

<p>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</p>
<pre class="codehilite"><code class="language-res">type todo = {id: string, text: string}

let todos = [
  {id: &quot;todo1&quot;, text: &quot;Todo 1&quot;},
  {id: &quot;todo2&quot;, text: &quot;Todo 2&quot;}
]

let items = Belt.Array.map(todos, todo =&gt; {
  &lt;li key={todo.id}&gt; {React.string(todo.text)} &lt;/li&gt;
})
</code></pre>

<p>If you don’t have stable IDs for rendered items, you may use the item index as a key as a last resort:</p>
<p>```res {1..3}
let items = Belt.Array.mapWithIndex(todos, (i, todo) =&gt; {
  // Only do this if items have no stable id
<br />
<li key={Belt.Int.toString(i)}>
    {todo.text}
  </li></p>
<p>});</p>
<pre class="codehilite"><code>### Keys Must Only Be Unique Among Siblings

Keys used within arrays should be unique among their siblings. However they don’t need to be globally unique. We can use the same keys when we produce two different arrays:

```res {6,10,17,18,25,27}
type post = {id: string, title: string, content: string}

module Blog = {
  @react.component
  let make = (~posts: array&lt;post&gt;) =&gt; {
    let sidebar =
      &lt;ul&gt;
        {
          Belt.Array.map(posts, (post) =&gt; {
            &lt;li key={post.id}&gt;
              {React.string(post.title)}
            &lt;/li&gt;
          })-&gt;React.array
        }
      &lt;/ul&gt;

    let content = Belt.Array.map(posts, (post) =&gt; {
        &lt;div key={post.id}&gt;
          &lt;h3&gt;{React.string(post.title)}&lt;/h3&gt;
          &lt;p&gt;{React.string(post.content)}&lt;/p&gt;
        &lt;/div&gt;
    });

      &lt;div&gt;
      {sidebar}
      &lt;hr /&gt;
      {React.array(content)}
    &lt;/div&gt;
  }
}

let posts = [
  {id: &quot;1&quot;, title: &quot;Hello World&quot;, content: &quot;Welcome to learning ReScript &amp; React!&quot;},
  {id: &quot;2&quot;, title: &quot;Installation&quot;, content: &quot;You can install reason-react from npm.&quot;}
]

let blog = &lt;Blog posts/&gt;
</code></pre>

<h2>Rendering <code>list</code> Values</h2>
<p>In case you ever want to render a <code>list</code> of items, you can do something like this:</p>
<pre class="codehilite"><code class="language-res">type todo = {id: string, text: string}

@react.component
let make = () =&gt; {
  let todoList = list{
    {id: &quot;todo1&quot;, text: &quot;Todo 1&quot;},
    {id: &quot;todo2&quot;, text: &quot;Todo 2&quot;},
  }

  let items =
    todoList
    -&gt;Belt.List.toArray
    -&gt;Belt.Array.map(todo =&gt; {
      &lt;li key={todo.id}&gt; {React.string(todo.text)} &lt;/li&gt;
    })

  &lt;div&gt; {React.array(items)} &lt;/div&gt;
}
</code></pre>

<p>We use <code>Belt.List.toArray</code> to convert our list to an array before creating our <code>array&lt;React.element&gt;</code>. Please note that using <code>list</code> has performance impact due to extra conversion costs.</p>
<p>99% of the time you'll want to use arrays (seamless interop, faster JS code), but in some cases it might make sense to use a <code>list</code> to leverage advanced pattern matching features etc.</p><h1>beyond-jsx</h1><hr />
<p>title: Beyond JSX
description: "Details on how to use ReScript and React without JSX"
canonical: "/docs/react/latest/beyond-jsx"</p>
<hr />
<h1>Beyond JSX</h1>
<p><Intro></p>
<p>JSX is a syntax sugar that allows us to use React components in an HTML like manner. A component needs to adhere to certain interface conventions, otherwise it can't be used in JSX. This section will go into detail on how the JSX transformation works and what React APIs are used underneath.</p>
<p></Intro></p>
<p><strong>Note:</strong> This section requires knowledge about the low level apis for <a href="./elements-and-jsx#creating-elements-from-component-functions">creating elements</a>, such as <code>React.createElement</code> or <code>ReactDOM.createDOMElementVariadic</code>.</p>
<blockquote>
<p><strong>Note:</strong> This page assumes your <code>bsconfig.json</code> to be set to <code>"jsx": { "version": 4 }</code> to apply the right JSX transformations. </p>
</blockquote>
<h2>Component Types</h2>
<p>A plain React component is defined as a <code>('props) =&gt; React.element</code> function. You can also express a component more efficiently with our shorthand type <code>React.component&lt;'props&gt;</code>. </p>
<p>Here are some examples on how to define your own component types (often useful when interoping with existing JS code, or passing around components):</p>
<pre class="codehilite"><code class="language-res">// Plain function type
type friend = {name: string, online: bool}
type friendComp = friend =&gt; React.element

// Equivalent to
// ({padding: string, children: React.element}) =&gt; React.element
type props = {padding: string, children: React.element}
type containerComp = React.component&lt;props&gt;
</code></pre>

<p>The types above are pretty low level (basically the JS representation of a React component), but since ReScript React has its own ways of defining React components in a more language specific way, let's have a closer look on the anatomy of such a construct.</p>
<h2>JSX Component Interface</h2>
<p>A ReScript React component needs to be a (sub-)module with a <code>make</code> function and <code>props</code> type to be usable in JSX. To make things easier, we provide a <code>@react.component</code> decorator to create those functions for you:</p>
<p><CodeTab labels={["Decorated", "Expanded"]}></p>
<pre class="codehilite"><code class="language-res">module Friend = {
  @react.component
  let make = (~name: string, ~children) =&gt; {
    &lt;div&gt;
      {React.string(name)}
      children
    &lt;/div&gt;
  }
}
</code></pre>

<pre class="codehilite"><code class="language-res">module Friend = {
  type props&lt;'name, 'children&gt; = {
    name: 'name,
    children: 'children,
  }

  let make = ({name, children, _}: props&lt;string, 'children&gt;) =&gt; {
    ReactDOM.createDOMElementVariadic(&quot;div&quot;, [{React.string(name)}, children])
  }
}
</code></pre>

<p></CodeTab></p>
<p>In the expanded output:</p>
<ul>
<li><code>props</code>: A generated record type that has fields according to the labeled arguments of the <code>make</code> function</li>
<li><code>make</code>: A converted <code>make</code> function that complies to the component interface <code>(props) =&gt; React.element</code></li>
</ul>
<h3>Special Case React.forwardRef</h3>
<p>The <code>@react.component</code> decorator also works for <code>React.forwardRef</code> calls:</p>
<p><CodeTab labels={["Decorated", "Expanded"]}></p>
<pre class="codehilite"><code class="language-res">module FancyInput = {
  @react.component
  let make = React.forwardRef((~className=?, ~children, ref) =&gt;
    &lt;div&gt;
      // use ref here
    &lt;/div&gt;
  )
}
</code></pre>

<pre class="codehilite"><code class="language-res">// Simplified Output
type props&lt;'className, 'children, 'ref&gt; = {
  className?: 'className,
  children: 'children,
  ref?: 'ref,
}

let make = (
  {?className, children, _}: props&lt;'className, 'children, ReactRef.currentDomRef&gt;,
  ref: Js.Nullable.t&lt;ReactRef.currentDomRef&gt;,
) =&gt;
  make(~className, ~children, ~ref, ())
</code></pre>

<p></CodeTab></p>
<p>As shown in the expanded output above, our decorator desugars the function passed to <code>React.forwardRef</code> in the same manner as a typical component <code>make</code> function. It also creates a <code>props</code> type with an optional <code>ref</code> field, so we can use it in our JSX call (<code>&lt;FancyInput ref=.../&gt;</code>).</p>
<p>So now that we know how the ReScript React component transformation works, let's have a look on how ReScript transforms our JSX constructs.</p>
<h2>JSX Under the Hood</h2>
<p>Whenever we are using JSX with a custom component ("capitalized JSX"), we are actually using <code>React.createElement</code> to create a new element. Here is an example of a React component without children: </p>
<p><CodeTab labels={["JSX", "Without JSX", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;Friend name=&quot;Fred&quot; age=20 /&gt;
</code></pre>

<pre class="codehilite"><code class="language-res">// classic
React.createElement(Friend.make, {name: &quot;Fred&quot;, age:20})

// automatic
React.jsx(Friend.make, {name: &quot;Fred&quot;, age: 20})
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(Playground$Friend, { name: &quot;Fred&quot;, age: 20 });
</code></pre>

<p></CodeTab></p>
<p>As you can see, it uses <code>Friend.make</code> to call the <code>React.createElement</code> API. In case you are providing children, it will use <code>React.createElementVariadic</code> instead (which is just a different binding for <code>React.createElement</code>):</p>
<p><CodeTab labels={["JSX", "Without JSX", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;Container width=200&gt;
  {React.string(&quot;Hello&quot;)}
  {React.string(&quot;World&quot;)}
&lt;/Container&gt;
</code></pre>

<pre class="codehilite"><code class="language-res">// classic
React.createElementVariadic(
  Container.make,
  {width: 200, children: React.null},
  [{React.string(&quot;Hello&quot;)}, {React.string(&quot;World&quot;)}],
)

// automatic
React.jsxs(
  Container.make,
  {width: 200, children: React.array([{React.string(&quot;Hello&quot;)}, {React.string(&quot;World&quot;)}])},
)
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(Container, { width: 200, children: null }, &quot;Hello&quot;, &quot;World&quot;);
</code></pre>

<p></CodeTab></p>
<p>Note that the <code>children: React.null</code> field has no relevance since React will only care about the children array passed as a third argument.</p>
<h3>Dom Elements</h3>
<p>"Uncapitalized JSX" expressions are treated as DOM elements and will be converted to <code>ReactDOM.createDOMElementVariadic</code> calls: </p>
<p><CodeTab labels={["JSX", "Without JSX", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;div title=&quot;test&quot;/&gt;
</code></pre>

<pre class="codehilite"><code class="language-res">// classic
ReactDOM.createDOMElementVariadic(&quot;div&quot;, ~props={title: &quot;test&quot;}, [])

// automatic
ReactDOM.jsx(&quot;div&quot;, {title: &quot;test&quot;})
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(&quot;div&quot;, { title: &quot;test&quot; });
</code></pre>

<p></CodeTab></p>
<p>The same goes for uncapitalized JSX with children:</p>
<p><CodeTab labels={["JSX", "Without JSX", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;div title=&quot;test&quot;&gt;
  &lt;span/&gt;
&lt;/div&gt;
</code></pre>

<pre class="codehilite"><code class="language-res">// classic
ReactDOM.createDOMElementVariadic(
  &quot;div&quot;,
  ~props={title: &quot;test&quot;},
  [ReactDOM.createDOMElementVariadic(&quot;span&quot;, [])],
)

// automatic
ReactDOM.jsx(&quot;div&quot;, {title: &quot;test&quot;, children: ?ReactDOM.someElement(ReactDOM.jsx(&quot;span&quot;, {}))})
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(&quot;div&quot;, { title: &quot;test&quot; }, React.createElement(&quot;span&quot;, undefined));
</code></pre>

<p></CodeTab></p><h1>elements-and-jsx</h1><hr />
<p>title: Elements &amp; JSX
description: "Basic concepts for React elements and how to use them in JSX"
canonical: "/docs/react/latest/elements-and-jsx"</p>
<hr />
<h1>Elements &amp; JSX</h1>
<p><Intro></p>
<p>Elements are the smallest building blocks of React apps. This page will explain how to handle <code>React.element</code>s in your React app with our dedicated JSX syntax.</p>
<p></Intro></p>
<blockquote>
<p><strong>Note:</strong> This page assumes your <code>bsconfig.json</code> to be set to <code>"jsx": { "version": 4 }</code>, otherwise your JSX will not be transformed to its React specific form. </p>
</blockquote>
<h2>Element Basics</h2>
<p>Let's start out by creating our first React element.</p>
<pre class="codehilite"><code class="language-res">let element = &lt;h1&gt; {React.string(&quot;Hello World&quot;)} &lt;/h1&gt;
</code></pre>

<p>The binding <code>element</code> and the expression <code>{React.string("Hello World")}</code> are both of type <code>React.element</code>, the fundamental type for representing React elements within a React application. An element describes what you see on the screen whenever you render your application to the DOM.</p>
<p>Let's say you want to create a function that handles another React element, such as <code>children</code>, you can annotate it as <code>React.element</code>:</p>
<pre class="codehilite"><code class="language-res">let wrapChildren = (children: React.element) =&gt; {
  &lt;div&gt;
    &lt;h1&gt; {React.string(&quot;Overview&quot;)} &lt;/h1&gt;
    children
  &lt;/div&gt;
}

wrapChildren(&lt;div&gt; {React.string(&quot;Let's use React with ReScript&quot;)} &lt;/div&gt;)
</code></pre>

<p>Understanding the definition of a <code>React.element</code> is essential since it is heavily used within the React APIs, such as <code>ReactDOM.Client.Root.render(..., element)</code>, etc. Be aware that JSX doesn't do any automatic <code>string</code> to <code>React.element</code> conversion for you (ReScript forces explicit type conversion). For example <code>&lt;div&gt; Hello World &lt;/div&gt;</code> will not type-check (which is actually a good thing because it's also a huge source for subtle bugs!), you need to convert your <code>"Hello World"</code> with the <code>React.string</code> function first.</p>
<p>Fortunately our React bindings bring all necessary functionality to represent all relevant data types as <code>React.element</code>s.</p>
<h2>Using Elements within JSX</h2>
<p>You can compose elements into more complex structures by using JSX:</p>
<pre class="codehilite"><code class="language-res">let greeting = React.string(&quot;Hello &quot;)
let name = React.string(&quot;Stranger&quot;);


// element is also of type React.element
let element = &lt;div className=&quot;myElement&quot;&gt; greeting name &lt;/div&gt;
</code></pre>

<p>JSX is the main way to express your React application as a tree of elements.</p>
<p>Sometimes, when doing a lot of interop with existing ReactJS codebases, you'll find yourself in a situation where you can't use JSX syntax due to syntactic restrictions. Check out the <a href="#escape-hatches">Escape Hatches</a> chapter later on for workarounds.</p>
<h2>Creating Elements</h2>
<h3>Creating Elements from <code>string</code>, <code>int</code>, <code>float</code>, <code>array</code></h3>
<p>Apart from using JSX to create our React elements or React components, the <code>React</code> module offers various functions to create elements from primitive data types:</p>
<pre class="codehilite"><code class="language-res">React.string(&quot;Hello&quot;) // new element representing &quot;Hello&quot;

React.int(1) // new element representing &quot;1&quot;

React.float(1.0) // new element representing &quot;1.0&quot;
</code></pre>

<p>It also offers <code>React.array</code> to represent multiple elements as one single element (useful for rendering a list of data, or passing children):</p>
<pre class="codehilite"><code class="language-res">let element = React.array([
  React.string(&quot;element 1&quot;),
  React.string(&quot;element 2&quot;),
  React.string(&quot;element 3&quot;)
])
</code></pre>

<p><strong>Note:</strong> We don't offer a <code>React.list</code> function because a <code>list</code> value would impose runtime overhead. ReScript cares about clean, idiomatic JS output. If you want to transform a <code>list</code> of elements to a single React element, combine the output of <code>Belt.List.toArray</code> with <code>React.array</code> instead.</p>
<h3>Creating Null Elements</h3>
<p>ReScript doesn't allow <code>element || null</code> constraints due to it's strongly typed nature. Whenever you are expressing conditionals where a value might, or might not be rendered, you will need the <code>React.null</code> constant to represent <em>Nothingness</em>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let name = Some(&quot;Andrea&quot;)

let element = switch name {
  | Some(name) =&gt; &lt;div&gt; {React.string(&quot;Hello &quot; ++ name)} &lt;/div&gt;
  | None =&gt; React.null
}

&lt;div&gt; element &lt;/div&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">var name = &quot;Andrea&quot;;

var element = name !== undefined ? React.createElement(&quot;div&quot;, undefined, &quot;Hello &quot; + name) : null;

React.createElement(&quot;div&quot;, undefined, element);
</code></pre>

<p></CodeTab></p>
<h2>Escape Hatches</h2>
<p><strong>Note:</strong> This chapter features low level APIs that are used by JSX itself, and should only be used whenever you hit certain JSX syntax limitations. More infos on the JSX internals can be found in our <a href="./beyond-jsx">Beyond JSX</a> section.</p>
<h3>Creating Elements from Component Functions</h3>
<p><strong>Note:</strong> Details on components and props will be described in the <a href="./components-and-props">next chapter</a>.</p>
<p>Sometimes it's necessary to pass around component functions to have more control over <code>React.element</code> creation. Use the <code>React.createElement</code> function to instantiate your elements:</p>
<pre class="codehilite"><code class="language-res">type props = {name: string}

let render = (myComp: props =&gt; React.element) =&gt; {
  &lt;div&gt; {React.createElement(myComp, {name: &quot;Franz&quot;})} &lt;/div&gt;
}
</code></pre>

<p>This feature is often used when interacting with existing JS / ReactJS code. In pure ReScript React applications, you would rather pass a function that does the rendering for you (also called a "render prop"):</p>
<pre class="codehilite"><code class="language-res">let render = (renderMyComp: (~name: string) =&gt; React.element) =&gt; {
  &lt;div&gt; {renderMyComp(~name=&quot;Franz&quot;)} &lt;/div&gt;
}
</code></pre>

<h4>Pass Variadic Children</h4>
<p>There is also a <code>React.createElementVariadic</code> function, which takes an array of children as a third parameter:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type props = {title: string, children: React.element}

let render = (article: props =&gt; React.element) =&gt; {
  let children = [React.string(&quot;Introduction&quot;), React.string(&quot;Body&quot;)]

  let props = {title: &quot;Article #1&quot;, children: React.null}

  {React.createElementVariadic(article, props, children)}
}
</code></pre>

<pre class="codehilite"><code class="language-js">function render(article) {
  var children = [
    &quot;Introduction&quot;,
    &quot;Body&quot;
  ];
  var props = {
    title: &quot;Article #1&quot;,
    children: null
  };
  return Caml_splice_call.spliceApply(React.createElement, [
              article,
              props,
              children
            ]);
}
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> Here we are passing a prop <code>"children": React.null</code> to satisfy the type checker. React will ignore the children prop in favor of the children array.</p>
<p>This function is mostly used by our JSX transformations, so usually you want to use <code>React.createElement</code> and pass a children prop instead.</p>
<h3>Creating DOM Elements</h3>
<p>To create DOM elements (<code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>, etc.), use <code>ReactDOM.createDOMElementVariadic</code>:</p>
<pre class="codehilite"><code class="language-res">ReactDOM.createDOMElementVariadic(&quot;div&quot;, ~props={className: &quot;card&quot;}, [])
</code></pre>

<p>ReScript can make sure that we are only passing valid dom props. You can find an exhaustive list of all available props in the <a href="https://github.com/rescript-lang/rescript-compiler/blob/3bc159f33a3534280bbc26be88fa37ea2114dafe/jscomp/others/jsxDOM.res#L31">JsxDOM</a> module.</p>
<h3>Cloning Elements</h3>
<p><strong>Note:</strong> This is an escape hatch feature and will only be useful for interoping with existing JS code / libraries.</p>
<p>Sometimes it's required to clone an existing element to set, overwrite or add prop values to a new instance, or if you want to set invalid prop names such as <code>data-name</code>. You can use <code>React.cloneElement</code> for that: </p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let original = &lt;div className=&quot;hello&quot;/&gt;

// Will return a new React.element with className set to &quot;world&quot;
React.cloneElement(original, {&quot;className&quot;: &quot;world&quot;, &quot;data-name&quot;: &quot;some name&quot;});
</code></pre>

<pre class="codehilite"><code class="language-js">var original = React.createElement(&quot;div&quot;, {
      className: &quot;hello&quot;
    });

React.cloneElement(original, {
      className: &quot;world&quot;,
      &quot;data-name&quot;: &quot;some name&quot;
    });
</code></pre>

<p></CodeTab></p>
<p>The feature mentioned above could also replicate <code>props spreading</code>, a practise commonly used in ReactJS codebases, but we strongly discourage the usage due to its unsafe nature and its incorrectness (e.g. adding undefined extra props to a component doesn't make sense, and causes hard to find bugs).</p>
<p>In ReScript, we rather pass down required props explicitly to leaf components or use a renderProp instead. We introduced <a href="/docs/manual/latest/jsx#punning">JSX punning</a> syntax to make the process of passing down props more convenient.</p><h1>migrate-react</h1><hr />
<p>title: Migrate from JSX v3
description: "Migrate from JSX v3"
canonical: "/docs/react/latest/migrate-react"</p>
<hr />
<h1>Migrate from JSX v3</h1>
<p>JSX v4 introduces a new idiomatic record-based representation of components which is incompatible with v3. Because of this, either the entire project or dependencies need to be compiled in V4 mode, or some compatibility features need to be used to mix V3 and V4 in the same project. This page describes how to migrate from v3 to v4.</p>
<h2>Configuration</h2>
<p>Remove the existing JSX configuration from <code>bsconfig.json</code>:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;reason&quot;: { &quot;react-jsx&quot;: 3 }
}
</code></pre>

<p>Then add the new JSX configuration:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;jsx&quot;: { &quot;version&quot;: 4 }
}
</code></pre>

<p><strong>Note</strong> JSX v4 requires the rescript compiler 10.1 or higher, and rescript-react version 0.11 or higher. In addition, react version 18.0 is required.</p>
<h3>Classic and Automatic Mode</h3>
<p>Classic mode is the default and generates calls to <code>React.createElement</code> just as with V3.</p>
<pre class="codehilite"><code class="language-json">{
  &quot;jsx&quot;: { &quot;version&quot;: 4, &quot;mode&quot;: &quot;classic&quot; }
}
</code></pre>

<p>Automatic mode is an experimental mode that generate calls to <code>_jsx</code> functions (similar to TypeScript's <code>react-jsx</code> mode)</p>
<pre class="codehilite"><code class="language-json">{
  &quot;jsx&quot;: { &quot;version&quot;: 4, &quot;mode&quot;: &quot;automatic&quot; }
}
</code></pre>

<h3>File-level config</h3>
<p>The top-level attribute <code>@@jsxConfig</code> is used to update the <code>jsx</code> config for the rest of the file (or until the next config update). Only the values mentioned are updated, the others are left unchanged.</p>
<pre class="codehilite"><code class="language-res">@@jsxConfig({ version: 4, mode: &quot;automatic&quot; })

module Wrapper = {
  module R1 = {
    @react.component  // V4 and new _jsx transform
    let make = () =&gt; body
  }

  @@jsxConfig({ version: 4, mode: &quot;classic&quot; })

  module R2 = {
    @react.component  // V4 with `React.createElement`
    let make = () =&gt; body
  }
}

@@jsxConfig({ version: 3 })

@react.component  // V3
let make = () =&gt; body
</code></pre>

<h3>v3 compatible mode</h3>
<p>JSX v3 is still available with the latest version of compiler and rescript-react.</p>
<pre class="codehilite"><code class="language-json">{
  &quot;jsx&quot;: { &quot;version&quot;: 3, &quot;v3-dependencies&quot;: [&quot;rescript-relay&quot;] },
  &quot;bsc-flags&quot;: [&quot;-open ReactV3&quot;]
}
</code></pre>

<p>To build certain dependencies in V3 compatibility mode, whatever the version used in the root project, use <code>"v3-dependencies"</code>. The listed dependencies will be built in V3 mode, and in addition <code>-open ReactV3</code> is added to the compiler options.</p>
<h2>Migration of V3 components</h2>
<p>Some components in existing projects are written in a way that is dependent on the v3 internal representation. Here are a few examples of how to convert them to v4.</p>
<h3><code>makeProps</code> does not exist in v4</h3>
<p>Rewrite this:</p>
<pre class="codehilite"><code class="language-res">// V3
module M = {
  @obj external makeProps: (~msg: 'msg, ~key: string=?, unit) =&gt; {&quot;msg&quot;: 'msg} = &quot;&quot;

  let make = (~msg) =&gt; &lt;div&gt; {React.string(msg)} &lt;/div&gt;
}
</code></pre>

<p>To this:</p>
<pre class="codehilite"><code class="language-res">// V4
module M = {
  type props&lt;'msg&gt; = {msg: 'msg}
  let make = props =&gt; &lt;div&gt; {React.string(props.msg)} &lt;/div&gt;
}
</code></pre>

<h3>React.Context</h3>
<p>Rewrite this:</p>
<pre class="codehilite"><code class="language-res">module Context = {
  let context = React.createContext(() =&gt; ())

  module Provider = {
    let provider = React.Context.provider(context)

    @react.component
    let make = (~value, ~children) =&gt; {
      React.createElement(provider, {&quot;value&quot;: value, &quot;children&quot;: children}) // Error
    }
  }
}
</code></pre>

<p>To this:</p>
<pre class="codehilite"><code class="language-res">module Context = {
  let context = React.createContext(() =&gt; ())

  module Provider = {
    let make = React.Context.provider(context)
  }
}
</code></pre>

<h3>React.forwardRef (Discouraged)</h3>
<p>Rewrite this:</p>
<pre class="codehilite"><code class="language-res">module FancyInput = {
  @react.component
  let make = React.forwardRef((
    ~className=?,
    ~children,
    ref_, // argument
  ) =&gt;
    &lt;div&gt;
      &lt;input
        type_=&quot;text&quot;
        ?className
        ref=?{ref_-&gt;Js.Nullable.toOption-&gt;Belt.Option.map(ReactDOM.Ref.domRef)}
      /&gt;
      children
    &lt;/div&gt;
  )
}

@react.component
let make = () =&gt; {
  let input = React.useRef(Js.Nullable.null)

  &lt;div&gt;
    &lt;FancyInput ref=input&gt; // prop
      &lt;button onClick&gt; {React.string(&quot;Click to focus&quot;)} &lt;/button&gt;
    &lt;/FancyInput&gt;
  &lt;/div&gt;
}
</code></pre>

<p>To this: In v3, there is an inconsistency between <code>ref</code> as prop and <code>ref_</code> as argument. With JSX V4, <code>ref</code> is only allowed as an argument.</p>
<pre class="codehilite"><code class="language-res">module FancyInput = {
  @react.component
  let make = React.forwardRef((
    ~className=?,
    ~children,
    ref, // only `ref` is allowed
  ) =&gt;
    &lt;div&gt;
      &lt;input
        type_=&quot;text&quot;
        ?className
        ref=?{ref-&gt;Js.Nullable.toOption-&gt;Belt.Option.map(ReactDOM.Ref.domRef)}
      /&gt;
      children
    &lt;/div&gt;
  )
}

@react.component
let make = () =&gt; {
  let input = React.useRef(Js.Nullable.null)

  &lt;div&gt;
    &lt;FancyInput ref=input&gt;
      &lt;button onClick&gt; {React.string(&quot;Click to focus&quot;)} &lt;/button&gt;
    &lt;/FancyInput&gt;
  &lt;/div&gt;
}
</code></pre>

<h3>Mangling the prop name</h3>
<p>The prop name was mangled automatically in v3, such as <code>_open</code> becomes <code>open</code> in the generated js code. This is no longer the case in v4 because the internal representation is changed to the record instead object. If you need to mangle the prop name, you can use the <code>@as</code> annotation.</p>
<p>Rewrite this:</p>
<pre class="codehilite"><code class="language-res">module Comp = {
  @react.component
  let make = (~_open, ~_type) =&gt;
    &lt;Modal _open _type&gt;
      &lt;Description /&gt;
    &lt;/Modal&gt;
}
</code></pre>

<p>To this:</p>
<pre class="codehilite"><code class="language-res">module Comp = {
  @react.component
  let make =
    (@as(&quot;open&quot;) ~_open, @as(&quot;type&quot;) ~_type) =&gt;
      &lt;Modal _open _type&gt;
        &lt;Description /&gt;
      &lt;/Modal&gt;
}
</code></pre>

<h3>Bindings to JS components with optional props</h3>
<p>Previously, you could wrap optional props with an explicit <code>option</code> when writing bindings to JS components. This approach functioned only due to an implementation detail of the ppx in JSX 3; it's not how to correctly write bindings to a function with optional arguments.</p>
<p>Rewrite this:</p>
<pre class="codehilite"><code class="language-res">module Button = {
  @module(&quot;./Button&quot;) @react.component
  external make: (~text: option&lt;string&gt;=?) =&gt; React.element = &quot;default&quot;
}
</code></pre>

<p>To this:</p>
<pre class="codehilite"><code class="language-res">module Button = {
  @module(&quot;./Button&quot;) @react.component
  external make: (~text: string=?) =&gt; React.element = &quot;default&quot;
}
</code></pre><h1>hooks-context</h1><hr />
<p>title: useContext Hook
description: "Details about the useContext React hook in ReScript"
canonical: "/docs/react/latest/hooks-context"</p>
<hr />
<h1>useContext</h1>
<p><Intro></p>
<p>Context provides a way to pass data through the component tree without having to pass props down manually at every level. The <code>useContext</code> hooks gives access to such Context values.</p>
<p></Intro></p>
<blockquote>
<p><strong>Note:</strong> All the details and rationale on React's context feature can be found in <a href="./context">here</a>.</p>
</blockquote>
<h2>Usage</h2>
<pre class="codehilite"><code class="language-res">let value = React.useContext(myContext)
</code></pre>

<p>Accepts a <code>React.Context.t</code> (the value returned from <code>React.createContext</code>) and returns the current context value for that context. The current context value is determined by the value prop of the nearest <code>&lt;MyContext.Provider&gt;</code> above the calling component in the tree.</p>
<h2>Examples</h2>
<h3>A Simple ThemeProvider</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// App.res
module ThemeContext = {
  let context = React.createContext(&quot;light&quot;)

  module Provider = {
    let make = React.Context.provider(context)
  }
}

module ThemedButton = {
  @react.component
  let make = () =&gt; {
    let theme = React.useContext(ThemeContext.context)
    let (color, backgroundColor) = switch theme {
    | &quot;dark&quot; =&gt; (&quot;#ffffff&quot;, &quot;#222222&quot;)
    | &quot;light&quot; | _ =&gt; (&quot;#000000&quot;, &quot;#eeeeee&quot;)
    }

    let style = ReactDOMStyle.make(~color, ~backgroundColor, ())

    &lt;button style&gt; {React.string(&quot;I am a styled button!&quot;)} &lt;/button&gt;
  }
}

module Toolbar = {
  @react.component
  let make = () =&gt; {
    &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt;
  }
}

@react.component
let make = () =&gt; {
  &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
    &lt;div&gt; &lt;Toolbar /&gt; &lt;/div&gt;
  &lt;/ThemeContext.Provider&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">var context = React.createContext(&quot;light&quot;);

var make = context.Provider;

var Provider = {
  make: make
};

var ThemeContext = {
  context: context,
  Provider: Provider
};

function App$ThemedButton(props) {
  var theme = React.useContext(context);
  var match;
  switch (theme) {
    case &quot;dark&quot; :
        match = [
          &quot;#ffffff&quot;,
          &quot;#222222&quot;
        ];
        break;
    case &quot;light&quot; :
        match = [
          &quot;#000000&quot;,
          &quot;#eeeeee&quot;
        ];
        break;
    default:
      match = [
        &quot;#000000&quot;,
        &quot;#eeeeee&quot;
      ];
  }
  var style = {
    backgroundColor: match[1],
    color: match[0]
  };
  return React.createElement(&quot;button&quot;, {
              style: style
            }, &quot;I am a styled button!&quot;);
}

var ThemedButton = {
  make: App$ThemedButton
};

function App$Toolbar(props) {
  return React.createElement(&quot;div&quot;, undefined, React.createElement(App$ThemedButton, {}));
}

var Toolbar = {
  make: App$Toolbar
};

function App(props) {
  return React.createElement(make, {
              value: &quot;dark&quot;,
              children: React.createElement(&quot;div&quot;, undefined, React.createElement(App$Toolbar, {}))
            });
}
</code></pre>

<p></CodeTab></p><h1>hooks-state</h1><hr />
<p>title: useState Hook
description: "Details about the useState React hook in ReScript"
canonical: "/docs/react/latest/hooks-state"</p>
<hr />
<h1>useState</h1>
<p><Intro></p>
<p><code>React.useState</code> returns a stateful value, and a function to update it.</p>
<p></Intro></p>
<h2>Usage</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let (state, setState) = React.useState(_ =&gt; initialState)
</code></pre>

<pre class="codehilite"><code class="language-js">var match = React.useState(function () {
      return initialState;
    });

var state = match[0];

var setState = match[1];
</code></pre>

<p></CodeTab></p>
<p>During the initial render, the returned state <code>state</code> is the same as the value passed as the first argument (initialState).</p>
<p>The <code>setState</code> function can be passed down to other components as well, which is useful for e.g. setting the state of a parent component by its children.</p>
<h2>Examples</h2>
<h3>Using State for a Text Input</h3>
<pre class="codehilite"><code class="language-res">@react.component
let make = () =&gt; {
  let (text, setText) = React.useState(_ =&gt; &quot;&quot;);

  let onChange = evt =&gt; {
    ReactEvent.Form.preventDefault(evt)
    let value = ReactEvent.Form.target(evt)[&quot;value&quot;]
    setText(_prev =&gt; value);
  }

  &lt;div&gt;
    &lt;input onChange value=text /&gt;
  &lt;/div&gt;
};
</code></pre>

<h3>Passing <code>setState</code> to a Child Component</h3>
<p>In this example, we are creating a <code>ThemeContainer</code> component that manages a <code>darkmode</code> boolean state and passes the <code>setDarkmode</code> function to a <code>ControlPanel</code> component to trigger the state changes.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// ThemeContainer.res
module ControlPanel = {
  @react.component
  let make = (~setDarkmode, ~darkmode) =&gt; {
    let onClick = evt =&gt; {
      ReactEvent.Mouse.preventDefault(evt)
      setDarkmode(prev =&gt; !prev)
    }

    let toggleText = &quot;Switch to &quot; ++ ((darkmode ? &quot;light&quot; : &quot;dark&quot;) ++ &quot; theme&quot;)

    &lt;div&gt; &lt;button onClick&gt; {React.string(toggleText)} &lt;/button&gt; &lt;/div&gt;
  }
}

@react.component
let make = (~content) =&gt; {
  let (darkmode, setDarkmode) = React.useState(_ =&gt; false)

  let className = darkmode ? &quot;theme-dark&quot; : &quot;theme-light&quot;

  &lt;div className&gt;
    &lt;section&gt;
      &lt;h1&gt; {React.string(&quot;More Infos about ReScript&quot;)} &lt;/h1&gt; content
    &lt;/section&gt;
    &lt;ControlPanel darkmode setDarkmode /&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function ControlPanel(Props) {
  var setDarkmode = Props.setDarkmode;
  var darkmode = Props.darkmode;
  var onClick = function (evt) {
    evt.preventDefault();
    return Curry._1(setDarkmode, (function (prev) {
                  return !prev;
                }));
  };
  var toggleText = &quot;Switch to &quot; + ((
      darkmode ? &quot;light&quot; : &quot;dark&quot;
    ) + &quot; theme&quot;);
  return React.createElement(&quot;div&quot;, undefined, React.createElement(&quot;button&quot;, {
                  onClick: onClick
                }, toggleText));
}

function ThemeContainer(Props) {
  var content = Props.content;
  var match = React.useState(function () {
        return false;
      });
  var darkmode = match[0];
  var className = darkmode ? &quot;theme-dark&quot; : &quot;theme-light&quot;;
  return React.createElement(&quot;div&quot;, {
              className: className
            }, React.createElement(&quot;section&quot;, undefined, React.createElement(&quot;h1&quot;, undefined, &quot;More Infos about ReScript&quot;), content), React.createElement(Playground$ControlPanel, {
                  setDarkmode: match[1],
                  darkmode: darkmode
                }));
}
</code></pre>

<p></CodeTab></p>
<p>Note that whenever <code>setDarkmode</code> is returning a new value (e.g. switching from <code>true</code> -&gt; <code>false</code>), it will cause a re-render for <code>ThemeContainer</code>'s <code>className</code> and the toggle text of its nested <code>ControlPanel</code>.</p>
<h2>Uncurried Version</h2>
<p>For cleaner JS output, you can use <code>React.Uncurried.useState</code> instead:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let (state, setState) = React.Uncurried.useState(_ =&gt; 0)

setState(. prev =&gt; prev + 1)
</code></pre>

<pre class="codehilite"><code class="language-js">var match = React.useState(function () {
      return 0;
  });

var setState = match[1];

setState(function (prev) {
      return prev + 1 | 0;
    });
</code></pre>

<p></CodeTab></p><h1>extensions-of-props</h1><hr />
<p>title: Extensions of props
description: "Extensions of props in ReScript and React"
canonical: "/docs/react/latest/spread-props"</p>
<hr />
<h1>Extensions of Props</h1>
<blockquote>
<p><strong>Note:</strong> This page assumes your <code>bsconfig.json</code> to be set to <code>"jsx": { "version": 4 }</code> to apply the right JSX transformations.</p>
</blockquote>
<h2>Spread props</h2>
<p>JSX props spread is supported now, but in a stricter way than in JS.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;Comp {...props} a=&quot;a&quot; /&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(Comp, {
  a: &quot;a&quot;,
  b: &quot;b&quot;
});
</code></pre>

<p></CodeTab></p>
<p>Multiple spreads are not allowed:</p>
<p><CodeTab labels={["ReScript"]}></p>
<pre class="codehilite"><code class="language-res">&lt;NotAllowed {...props1} {...props2} /&gt;
</code></pre>

<p></CodeTab></p>
<p>The spread must be at the first position, followed by other props:</p>
<p><CodeTab labels={["ReScript"]}></p>
<pre class="codehilite"><code class="language-res">&lt;NotAllowed a=&quot;a&quot; {...props} /&gt;
</code></pre>

<p></CodeTab></p>
<h2>Shared props</h2>
<p>You can control the definition of the <code>props</code> type by passing as argument to <code>@react.component</code> the body of the type definition of <code>props</code>. The main application is sharing a single type definition across several components. Here are a few examples:</p>
<p><CodeTab labels={["Decorated", "Expanded"]}></p>
<pre class="codehilite"><code class="language-res">type sharedprops&lt;'x, 'y&gt; = {x: 'x, y: 'y, z:string}

module C1 = {
  @react.component(:sharedProps&lt;'a, 'b&gt;)
  let make = (~x, ~y) =&gt; React.string(x ++ y ++ z)
}

module C2 = {
  @react.component(:sharedProps&lt;string, 'b&gt;)
  let make = (~x, ~y) =&gt; React.string(x ++ y ++ z)
}

module C3 = {
  type myProps = sharedProps&lt;int, int&gt;
  @react.component(:myProps)
  let make = (~x, ~y) =&gt; React.int(x + y)
}
</code></pre>

<pre class="codehilite"><code class="language-res">type sharedprops&lt;'x, 'y&gt; = {x: 'x, y: 'y, z: string}

module C1 = {
  type props&lt;'a, 'b&gt; = sharedProps&lt;'a, 'b&gt;
  let make = ({x, y, _}: props&lt;_&gt;) =&gt; React.string(x ++ y ++ z)
}

module C2 = {
  type props&lt;'b&gt; = sharedProps&lt;string, 'b&gt;
  let make = ({x, y, _}: props&lt;_&gt;) =&gt; React.string(x ++ y ++ z)
}

module C3 = {
  type myProps = sharedProps&lt;int, int&gt;
  type props = myProps
  let make = ({x, y, _}: props) =&gt; React.int(x + y)
}
</code></pre>

<p></CodeTab></p>
<p>This feature can be used when the nominally different components are passed to the prop of <code>Screen</code> component in <a href="https://github.com/rescript-react-native/rescript-react-navigation">ReScript React Native Navigation</a>.</p>
<pre class="codehilite"><code class="language-res">type screenProps = { navigation: navigation, route: route }

module Screen: {
  @react.component
  let make: (
    ~name: string,
    ~component: React.component&lt;screenProps&gt;,
    ...
  ) =&gt; React.element
}

&lt;Screen
  name=&quot;SomeScreen&quot;
  component={A.make} // This will cause a type check error
  ...
/&gt;
&lt;Screen
  name=&quot;SomeScreen&quot;
  component={B.make} // This will cause a type check error
  ...
/&gt;
</code></pre>

<p>This example cann't pass the type checker, because the props types of both components are nominally different. You can make the both components having the same props type by passing <code>screenProps</code> type as argument to <code>@react.component</code>.</p>
<pre class="codehilite"><code class="language-res">module A = {
  @react.component(:screenProps)
  let make = (
    ~navigation: navigation,
    ~route: route
  ) =&gt; ...
}

module B = {
  @react.component(:screenProps)
  let make = (
    ~navigation: navigation,
    ~route: route
  ) =&gt; ...
}
</code></pre><h1>introduction</h1><hr />
<p>title: Introduction
description: "Introduction to ReScript &amp; ReactJS"
canonical: "/docs/react/latest/introduction"</p>
<hr />
<h1>ReScript &amp; React</h1>
<p>ReScript offers first class bindings for <a href="https://reactjs.org">ReactJS</a> and is designed and built by people using ReScript and React in large mission critical React codebases. The bindings are compatible with modern React versions (&gt;= v18.0).</p>
<p>The ReScript philosophy is to compile as closely to idiomatic JS code as possible; in the case of ReactJS, we made no exception, so it's not only easy to transfer all the React knowledge to the ReScript platform, but also straightforward to integrate with existing ReactJS codebases and libraries.</p>
<p>All our documented examples can be compiled in our <a href="/try">ReScript Playground</a> as well.</p>
<h2>Feature Overview</h2>
<ul>
<li>No Babel plugins required (JSX is part of the language!)</li>
<li>Comes with all essential React APIs for building production ready apps (<code>useState</code>, <code>useReducer</code>, <code>useEffect</code>, <code>useRef</code>,...)</li>
<li>No component class API (all ReScript &amp; React codebases are built on function components &amp; hooks)</li>
<li>Strong level of type safetiness and type inference for component props and state values</li>
<li><a href="/docs/gentype/latest/introduction">GenType</a> support for importing / exporting React components in TypeScript codebases</li>
</ul>
<blockquote>
<p><strong>This documentation assumes basic knowledge about ReactJS.</strong></p>
<p>Please note that even though we will cover many basic React concepts, it might still be necessary to have a look at the official <a href="https://reactjs.org">ReactJS</a> resources, especially if you are a complete beginner with React.</p>
</blockquote>
<h2>Development</h2>
<ul>
<li>In case you are having any issues or if you want to help us out improving our bindings, check out our <a href="https://github.com/rescript-lang/rescript-react">rescript-react GitHub repository</a>.</li>
<li>For doc related issues, please go to the <a href="https://github.com/reason-association/rescript-lang.org">rescript-lang.org repo</a>.</li>
</ul><h1>hooks-reducer</h1><hr />
<p>title: useReducer Hook
description: "Details about the useReducer React hook in ReScript"
canonical: "/docs/react/latest/hooks-reducer"</p>
<hr />
<h1>useReducer</h1>
<p><Intro></p>
<p><code>React.useReducer</code> helps you express your state in an action / reducer pattern.</p>
<p></Intro></p>
<h2>Usage</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let (state, dispatch) = React.useReducer(reducer, initialState)
</code></pre>

<pre class="codehilite"><code class="language-js">var match = React.useReducer(reducer, initialState);
</code></pre>

<p></CodeTab></p>
<p>An alternative to <a href="./hooks-state">useState</a>. Accepts a reducer of type <code>(state, action) =&gt; newState</code>, and returns the current <code>state</code> paired with a <code>dispatch</code> function <code>(action) =&gt; unit</code>. </p>
<p><code>React.useReducer</code> is usually preferable to <code>useState</code> when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. <code>useReducer</code> also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.</p>
<p><strong>Note:</strong> You will notice that the action / reducer pattern works especially well in ReScript due to its <a href="/docs/manual/latest/record">immutable records</a>, <a href="/docs/manual/latest/variant">variants</a> and <a href="/docs/manual/latest/pattern-matching-destructuring">pattern matching</a> features for easy expression of your action and state transitions.</p>
<h2>Examples</h2>
<h3>Counter Example with <code>React.useReducer</code></h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Counter.res

type action = Inc | Dec
type state = {count: int}

let reducer = (state, action) =&gt; {
  switch action {
  | Inc =&gt; {count: state.count + 1}
  | Dec =&gt; {count: state.count - 1}
  }
}

@react.component
let make = () =&gt; {
  let (state, dispatch) = React.useReducer(reducer, {count: 0})

  &lt;&gt;
    {React.string(&quot;Count:&quot; ++ Belt.Int.toString(state.count))}
    &lt;button onClick={(_) =&gt; dispatch(Dec)}&gt; {React.string(&quot;-&quot;)} &lt;/button&gt;
    &lt;button onClick={(_) =&gt; dispatch(Inc)}&gt; {React.string(&quot;+&quot;)} &lt;/button&gt;
  &lt;/&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function reducer(state, action) {
  if (action) {
    return {
            count: state.count - 1 | 0
          };
  } else {
    return {
            count: state.count + 1 | 0
          };
  }
}

function Counter(Props) {
  var match = React.useReducer(reducer, {
        count: 0
      });
  var dispatch = match[1];
  return React.createElement(React.Fragment, undefined, &quot;Count:&quot; + String(match[0].count), React.createElement(&quot;button&quot;, {
                  onClick: (function (param) {
                      return Curry._1(dispatch, /* Dec */1);
                    })
                }, &quot;-&quot;), React.createElement(&quot;button&quot;, {
                  onClick: (function (param) {
                      return Curry._1(dispatch, /* Inc */0);
                    })
                }, &quot;+&quot;));
}
</code></pre>

<p></CodeTab></p>
<blockquote>
<p>React guarantees that dispatch function identity is stable and won’t change on re-renders. This is why it’s safe to omit from the useEffect or useCallback dependency list.</p>
</blockquote>
<h3>Basic Todo List App with More Complex Actions</h3>
<p>You can leverage the full power of variants to express actions with data payloads to parametrize your state transitions:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// TodoApp.res

type todo = {
  id: int,
  content: string,
  completed: bool,
}

type action =
  | AddTodo(string)
  | RemoveTodo(int)
  | ToggleTodo(int)

type state = {
  todos: array&lt;todo&gt;,
  nextId: int,
}

let reducer = (state, action) =&gt;
  switch action {
  | AddTodo(content) =&gt;
    let todos = Js.Array2.concat(
      state.todos,
      [{id: state.nextId, content: content, completed: false}],
    )
    {todos: todos, nextId: state.nextId + 1}
  | RemoveTodo(id) =&gt;
    let todos = Js.Array2.filter(state.todos, todo =&gt; todo.id !== id)
    {...state, todos: todos}
  | ToggleTodo(id) =&gt;
    let todos = Belt.Array.map(state.todos, todo =&gt;
      if todo.id === id {
        {
          ...todo,
          completed: !todo.completed,
        }
      } else {
        todo
      }
    )
    {...state, todos: todos}
  }

let initialTodos = [{id: 1, content: &quot;Try ReScript &amp; React&quot;, completed: false}]

@react.component
let make = () =&gt; {
  let (state, dispatch) = React.useReducer(
    reducer,
    {todos: initialTodos, nextId: 2},
  )

  let todos = Belt.Array.map(state.todos, todo =&gt;
    &lt;li&gt;
      {React.string(todo.content)}
      &lt;button onClick={_ =&gt; dispatch(RemoveTodo(todo.id))}&gt;
        {React.string(&quot;Remove&quot;)}
      &lt;/button&gt;
      &lt;input
        type_=&quot;checkbox&quot;
        checked=todo.completed
        onChange={_ =&gt; dispatch(ToggleTodo(todo.id))}
      /&gt;
    &lt;/li&gt;
  )

  &lt;&gt; &lt;h1&gt; {React.string(&quot;Todo List:&quot;)} &lt;/h1&gt; &lt;ul&gt; {React.array(todos)} &lt;/ul&gt; &lt;/&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function reducer(state, action) {
  switch (action.TAG | 0) {
    case /* AddTodo */0 :
        var todos = state.todos.concat([{
                id: state.nextId,
                content: action._0,
                completed: false
              }]);
        return {
                todos: todos,
                nextId: state.nextId + 1 | 0
              };
    case /* RemoveTodo */1 :
        var id = action._0;
        var todos$1 = state.todos.filter(function (todo) {
              return todo.id !== id;
            });
        return {
                todos: todos$1,
                nextId: state.nextId
              };
    case /* ToggleTodo */2 :
        var id$1 = action._0;
        var todos$2 = Belt_Array.map(state.todos, (function (todo) {
                if (todo.id === id$1) {
                  return {
                          id: todo.id,
                          content: todo.content,
                          completed: !todo.completed
                        };
                } else {
                  return todo;
                }
              }));
        return {
                todos: todos$2,
                nextId: state.nextId
              };

  }
}

var initialTodos = [{
    id: 1,
    content: &quot;Try ReScript &amp; React&quot;,
    completed: false
  }];

function TodoApp(Props) {
  var match = React.useReducer(reducer, {
        todos: initialTodos,
        nextId: 2
      });
  var dispatch = match[1];
  var todos = Belt_Array.map(match[0].todos, (function (todo) {
          return React.createElement(&quot;li&quot;, undefined, todo.content, React.createElement(&quot;button&quot;, {
                          onClick: (function (param) {
                              return Curry._1(dispatch, {
                                          TAG: /* RemoveTodo */1,
                                          _0: todo.id
                                        });
                            })
                        }, &quot;Remove&quot;), React.createElement(&quot;input&quot;, {
                          checked: todo.completed,
                          type: &quot;checkbox&quot;,
                          onChange: (function (param) {
                              return Curry._1(dispatch, {
                                          TAG: /* ToggleTodo */2,
                                          _0: todo.id
                                        });
                            })
                        }));
        }));
  return React.createElement(React.Fragment, undefined, React.createElement(&quot;h1&quot;, undefined, &quot;Todo List:&quot;), React.createElement(&quot;ul&quot;, undefined, todos));
}
</code></pre>

<p></CodeTab></p>
<h2>Lazy Initialization</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let (state, dispatch) =
  React.useReducerWithMapState(reducer, initialState, initial)
</code></pre>

<pre class="codehilite"><code class="language-js">var match = React.useReducer(reducer, initialState, init);
</code></pre>

<p></CodeTab></p>
<p>You can also create the <code>initialState</code> lazily. To do this, you can use <code>React.useReducerWithMapState</code> and pass an <code>init</code> function as the third argument. The initial state will be set to <code>init(initialState)</code>.</p>
<p>It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Counter.res

type action = Inc | Dec | Reset(int)
type state = {count: int}

let init = initialCount =&gt; {
  {count: initialCount}
}

let reducer = (state, action) =&gt; {
  switch action {
  | Inc =&gt; {count: state.count + 1}
  | Dec =&gt; {count: state.count - 1}
  | Reset(count) =&gt; init(count)
  }
}

@react.component
let make = (~initialCount: int) =&gt; {
  let (state, dispatch) = React.useReducerWithMapState(
    reducer,
    initialCount,
    init,
  )

  &lt;&gt;
    {React.string(&quot;Count:&quot; ++ Belt.Int.toString(state.count))}
    &lt;button onClick={_ =&gt; dispatch(Dec)}&gt; {React.string(&quot;-&quot;)} &lt;/button&gt;
    &lt;button onClick={_ =&gt; dispatch(Inc)}&gt; {React.string(&quot;+&quot;)} &lt;/button&gt;
  &lt;/&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function init(initialCount) {
  return {
          count: initialCount
        };
}

function reducer(state, action) {
  if (typeof action === &quot;number&quot;) {
    if (action !== 0) {
      return {
              count: state.count - 1 | 0
            };
    } else {
      return {
              count: state.count + 1 | 0
            };
    }
  } else {
    return {
            count: action._0
          };
  }
}

function Counter(Props) {
  var initialCount = Props.initialCount;
  var match = React.useReducer(reducer, initialCount, init);
  var dispatch = match[1];
  return React.createElement(React.Fragment, undefined, &quot;Count:&quot; + String(match[0].count), React.createElement(&quot;button&quot;, {
                  onClick: (function (param) {
                      return Curry._1(dispatch, /* Dec */1);
                    })
                }, &quot;-&quot;), React.createElement(&quot;button&quot;, {
                  onClick: (function (param) {
                      return Curry._1(dispatch, /* Inc */0);
                    })
                }, &quot;+&quot;));
}
</code></pre>

<p></CodeTab></p><h1>styling</h1><hr />
<p>title: Styling
description: "Styling in ReScript &amp; React"
canonical: "/docs/react/latest/styling"</p>
<hr />
<h1>Styling</h1>
<p>React comes with builtin support for inline styles, but there are also a number of third party libraries for styling React components. You might be comfortable with a specific setup, like:</p>
<ul>
<li>Global CSS / CSS modules</li>
<li>CSS utility libraries (<code>tailwindcss</code>, <code>tachyons</code>, <code>bootstrap</code> etc.)</li>
<li>CSS-in-JS (<code>styled-components</code>, <code>emotion</code>, etc.)</li>
</ul>
<p>If they work in JS then they almost certainly work in ReScript. In the next few sections, we've shared some ideas for working with popular libraries. If you're interested in working with one you don't see here, search the <a href="https://rescript-lang.org/packages">package index</a> or post in <a href="https://forum.rescript-lang.org">the forum</a>.</p>
<h2>Inline Styles</h2>
<p>This is the most basic form of styling, coming straight from the 90s. You can apply a <code>style</code> attribute to any DOM element with our <code>ReactDOM.Style.make</code> API:</p>
<pre class="codehilite"><code class="language-res">&lt;div style={ReactDOM.Style.make(~color=&quot;#444444&quot;, ~fontSize=&quot;68px&quot;, ())} /&gt;
</code></pre>

<p>It's a <a href="/docs/manual/latest/function#labeled-arguments">labeled</a> (therefore typed) function call that maps to the familiar style object <code>{color: '#444444', fontSize: '68px'}</code>. For every CSS attribute in the CSS specfication, there is a camelCased label in our <code>make</code> function.</p>
<p><strong>Note</strong> that <code>make</code> returns an opaque <code>ReactDOM.Style.t</code> type that you can't read into. We also expose a <code>ReactDOM.Style.combine</code> that takes in two <code>style</code>s and combine them.</p>
<h3>Escape Hatch: <code>unsafeAddProp</code></h3>
<p>The above <code>Style.make</code> API will safely type check every style field! However, we might have missed some more esoteric fields. If that's the case, the type system will tell you that the field you're trying to add doesn't exist. To remediate this, we're exposing a <code>ReactDOM.Style.unsafeAddProp</code> to dangerously add a field to a style:</p>
<pre class="codehilite"><code class="language-res">let style =
  ReactDOM.Style.make(
    ~color=&quot;red&quot;,
    ~padding=&quot;10px&quot;,
    (),
  )-&gt;ReactDOM.Style.unsafeAddProp(&quot;-webkit-animation-name&quot;, &quot;moveit&quot;)
</code></pre>

<h2>Global CSS</h2>
<p>Use a <code>%%raw</code> expression to import CSS files within your ReScript / React component code:</p>
<pre class="codehilite"><code class="language-rescript">// in a CommonJS setup
%%raw(&quot;require('./styles/main.css')&quot;)

// or with ES6
%%raw(&quot;import './styles/main.css'&quot;)
</code></pre>

<h2>CSS Modules</h2>
<p><a href="https://github.com/css-modules/css-modules">CSS modules</a> can be imported like any other JS module. The imported value is a JS object, with attributes equivalent to each classname defined in the CSS file.</p>
<p>As an example, let's say we have a CSS module like this:</p>
<pre class="codehilite"><code class="language-css">/* styles.module.css */

.root {
  color: red
}
</code></pre>

<p>We now need to create a module binding that imports our styles as a JS object: </p>
<pre class="codehilite"><code class="language-res">// {..} means we are handling a JS object with an unknown
// set of attributes
@module external styles: {..} = &quot;./styles.module.css&quot;

// Use the obj[&quot;key&quot;] syntax to access any classname within our object
let app = &lt;div className={styles[&quot;root&quot;]} /&gt;
</code></pre>

<p><strong>Note:</strong> <code>{..}</code> is an open <a href="/docs/manual/latest/object#type-declaration">JS object type</a>, which means the type checker will not type check correct classname usage. If you want to enforce compiler errors, replace <code>{..}</code> with a concrete JS object type, such as <code>{"root": string}</code>.</p>
<h2>CSS Utility Libraries</h2>
<h3>Tailwind</h3>
<p>CSS utility libraries like <a href="https://tailwindcss.com">TailwindCSS</a> usually require some globally imported CSS.</p>
<p>First, create your TailwindCSS main entrypoint file:</p>
<pre class="codehilite"><code class="language-css">/* main.css */

@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>

<p>Then, import your <code>main.css</code> file in your ReScript / React application:</p>
<pre class="codehilite"><code class="language-res">// src/App.res

%%raw(&quot;import './main.css'&quot;)
</code></pre>

<p>Utilize ReScript's pattern matching and string interpolations to combine different classnames:</p>
<pre class="codehilite"><code class="language-res">@react.component
let make = (~active: bool) =&gt; {
  let activeClass = if active {
    &quot;text-green-600&quot;
  }
  else {
    &quot;text-red-600&quot;
  }

  &lt;div className={`border-1 border-black ${activeClass}`}&gt;
    {React.string(&quot;Hello World&quot;)}
  &lt;/div&gt;
}
</code></pre>

<blockquote>
<p><strong>Hint:</strong> <code>rescript-lang.org</code> actually uses TailwindCSS under the hood! Check out our <a href="https://github.com/rescript-association/rescript-lang.org">codebase</a> to get some more inspiration on usage patterns.</p>
</blockquote>
<h2>CSS-in-JS</h2>
<p>There's no way we could recommend a definitive CSS-in-JS workflow, since there are many different approaches on how to bind to CSS-in-JS libraries (going from simple to very advanced).</p>
<p>For demonstration purposes, let's create some simple bindings to e.g. <a href="https://emotion.sh/docs/introduction"><code>emotion</code></a> (as described <a href="https://github.com/bloodyowl/rescript-react-starter-kit/blob/eca7055c59ba578b2d1994fc928d8f541a423e74/src/shared/Emotion.res">here</a>):</p>
<pre class="codehilite"><code class="language-res">// src/Emotion.res

@module(&quot;@emotion/css&quot;) external css: {..} =&gt; string = &quot;css&quot;
@module(&quot;@emotion/css&quot;) external rawCss: string =&gt; string = &quot;css&quot;
@module(&quot;@emotion/css&quot;) external keyframes: {..} =&gt; string = &quot;css&quot;
@module(&quot;@emotion/css&quot;) external cx: array&lt;string&gt; =&gt; string = &quot;cx&quot;

@module(&quot;@emotion/css&quot;) external injectGlobal: string =&gt; unit = &quot;injectGlobal&quot;
</code></pre>

<p>This will give you straight-forward access to <code>emotion</code>'s apis. Here's how you'd use them in your app code:</p>
<pre class="codehilite"><code class="language-res">let container = Emotion.css({
  &quot;color&quot;: &quot;#fff&quot;,
  &quot;backgroundColor&quot;: &quot;red&quot;
})

let app = &lt;div className={container} /&gt;
</code></pre>

<p>You can also use submodules to organize your styles more easily:</p>
<pre class="codehilite"><code class="language-res">module Styles = {
  open Emotion
  let container = css({
    &quot;color&quot;: &quot;#fff&quot;,
    &quot;backgroundColor&quot;: &quot;red&quot;
  })
  // your other declarations
}

let app = &lt;div className={Styles.container} /&gt;
</code></pre>

<p>Please note that this approach will not check for invalid css attribute names. If you e.g. want to make sure that only valid CSS attributes are being passed, you could define your <code>css</code> function like this as well:</p>
<pre class="codehilite"><code class="language-res">@module(&quot;@emotion/css&quot;) external css: ReactDOM.Style.t =&gt; string = &quot;css&quot;

// Usage is slightly different (and probably less ergonomic)
let container = ReactDOM.Style.make(~padding=&quot;20px&quot;, ())-&gt;css;

let app = &lt;div
  className={container}
/&gt;
</code></pre>

<p>Here we used the already existing <code>React.Style.t</code> type to enforce valid CSS attribute names. 
Last but not least, you can also bind to functions that let you use raw CSS directly:</p>
<pre class="codehilite"><code class="language-res">let container = Emotion.rawCss(`
  color: #fff;
  background-color: red;
`)

let app = &lt;div className={container} /&gt;
</code></pre>

<p>Please keep in mind that there's a spectrum on how type-safe an API can be (while being more / less complex to handle), so choose a solution that fits to your team's needs.</p><h1>hooks-custom</h1><hr />
<p>title: Build A Custom Hook
description: "How to build your own hooks in ReScript &amp; React"
canonical: "/docs/react/latest/hooks-custom"</p>
<hr />
<h1>Build A Custom Hook</h1>
<p><Intro></p>
<p>React comes with a few fundamental hooks out-of-the-box, such as <code>React.useState</code> or <code>React.useEffect</code>. Here you will learn how to build your own, higher-level hooks for your React use-cases.</p>
<p></Intro></p>
<h2>Why Custom Hooks?</h2>
<p>Custom hooks let you extract existing component logic into reusable, separate functions.</p>
<p>Let's go back to a previous example from our <a href="./hooks-effect">React.useEffect section</a> where we built a component for a chat application that displays a message, indicating whether a friend is online or offline:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res {16-31}
// FriendStatus.res</p>
<p>module ChatAPI = {
  // Imaginary globally available ChatAPI for demo purposes
  type status = { isOnline: bool };
  @val external subscribeToFriendStatus: (string, status =&gt; unit) =&gt; unit = "subscribeToFriendStatus";
  @val external unsubscribeFromFriendStatus: (string, status =&gt; unit) =&gt; unit = "unsubscribeFromFriendStatus";
}</p>
<p>type state = Offline | Loading | Online;</p>
<p>@react.component
let make = (~friendId: string) =&gt; {
  let (state, setState) = React.useState(_ =&gt; Offline)</p>
<p>React.useEffect(() =&gt; {
    let handleStatusChange = (status) =&gt; {
      setState(_ =&gt; {
        status.ChatAPI.isOnline ? Online : Offline
      })
    }</p>
<pre class="codehilite"><code>ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange);
setState(_ =&gt; Loading);

let cleanup = () =&gt; {
  ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)
}

Some(cleanup)
</code></pre>

<p>})</p>
<p>let text = switch(state) {
    | Offline =&gt; friendId ++ " is offline"
    | Online =&gt; friendId ++ " is online"
    | Loading =&gt; "loading..."
  }</p>
<div>
    {React.string(text)}
  </div>
<p>}</p>
<pre class="codehilite"><code>```js
function FriendStatus(Props) {
  var friendId = Props.friendId;
  var match = React.useState(function () {
        return /* Offline */0;
      });
  var setState = match[1];
  React.useEffect(function () {
        var handleStatusChange = function (status) {
          return Curry._1(setState, (function (param) {
                        if (status.isOnline) {
                          return /* Online */2;
                        } else {
                          return /* Offline */0;
                        }
                      }));
        };
        subscribeToFriendStatus(friendId, handleStatusChange);
        Curry._1(setState, (function (param) {
                return /* Loading */1;
              }));
        return (function (param) {
                  unsubscribeFromFriendStatus(friendId, handleStatusChange);

                });
      });
  var text;
  switch (match[0]) {
    case /* Offline */0 :
        text = friendId + &quot; is offline&quot;;
        break;
    case /* Loading */1 :
        text = &quot;loading...&quot;;
        break;
    case /* Online */2 :
        text = friendId + &quot; is online&quot;;
        break;

  }
  return React.createElement(&quot;div&quot;, undefined, text);
}
</code></pre>

<p></CodeTab></p>
<p>Now let’s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our <code>FriendListItem</code> component but it wouldn’t be ideal:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res {15-30}
// FriendListItem.res
type state = Offline | Loading | Online;</p>
<p>// module ChatAPI = {...}</p>
<p>type friend = {
  id: string,
  name: string
};</p>
<p>@react.component
let make = (~friend: friend) =&gt; {
  let (state, setState) = React.useState(_ =&gt; Offline)</p>
<p>React.useEffect(() =&gt; {
    let handleStatusChange = (status) =&gt; {
      setState(_ =&gt; {
        status.ChatAPI.isOnline ? Online : Offline
      })
    }</p>
<pre class="codehilite"><code>ChatAPI.subscribeToFriendStatus(friend.id, handleStatusChange);
setState(_ =&gt; Loading);

let cleanup = () =&gt; {
  ChatAPI.unsubscribeFromFriendStatus(friend.id, handleStatusChange)
}

Some(cleanup)
</code></pre>

<p>})</p>
<p>let color = switch(state) {
    | Offline =&gt; "red"
    | Online =&gt; "green"
    | Loading =&gt; "grey"
  }</p>
<li style={ReactDOMStyle.make(~color,())}>
      {React.string(friend.name)}
  </li>
<p>}</p>
<pre class="codehilite"><code>```js
function FriendListItem(Props) {
  var friend = Props.friend;
  var match = React.useState(function () {
        return /* Offline */0;
      });
  var setState = match[1];
  React.useEffect(function () {
        var handleStatusChange = function (status) {
          return Curry._1(setState, (function (param) {
                        if (status.isOnline) {
                          return /* Online */2;
                        } else {
                          return /* Offline */0;
                        }
                      }));
        };
        subscribeToFriendStatus(friend.id, handleStatusChange);
        Curry._1(setState, (function (param) {
                return /* Loading */1;
              }));
        return (function (param) {
                  unsubscribeFromFriendStatus(friend.id, handleStatusChange);

                });
      });
  var color;
  switch (match[0]) {
    case /* Offline */0 :
        color = &quot;red&quot;;
        break;
    case /* Loading */1 :
        color = &quot;grey&quot;;
        break;
    case /* Online */2 :
        color = &quot;green&quot;;
        break;

  }
  return React.createElement(&quot;li&quot;, {
              style: {
                color: color
              }
            }, friend.name);
}
</code></pre>

<p></CodeTab></p>
<p>Instead, we’d like to share this logic between <code>FriendStatus</code> and <code>FriendListItem</code>.</p>
<p>Traditionally in React, we’ve had two popular ways to share stateful logic between components: render props and higher-order components. We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.</p>
<h2>Extracting a Custom Hook</h2>
<p>Usually when we want to share logic between two functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!</p>
<p><strong>A custom Hook is a function whose name starts with ”use” and that may call other Hooks.</strong> For example, <code>useFriendStatus</code> below is our first custom Hook (we create a new file <code>FriendStatusHook.res</code> to encapsulate the <code>state</code> type as well):</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// FriendStatusHook.res

// module ChatAPI {...}

type state = Offline | Loading | Online

let useFriendStatus = (friendId: string): state =&gt; {
  let (state, setState) = React.useState(_ =&gt; Offline)

  React.useEffect(() =&gt; {
    let handleStatusChange = status =&gt; {
      setState(_ =&gt; {
        status.ChatAPI.isOnline ? Online : Offline
      })
    }

    ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange)
    setState(_ =&gt; Loading)

    let cleanup = () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)
    }

    Some(cleanup)
  })

  state
}
</code></pre>

<pre class="codehilite"><code class="language-js">function useFriendStatus(friendId) {
  var match = React.useState(function () {
        return /* Offline */0;
      });
  var setState = match[1];
  React.useEffect(function () {
        var handleStatusChange = function (status) {
          return Curry._1(setState, (function (param) {
                        if (status.isOnline) {
                          return /* Online */2;
                        } else {
                          return /* Offline */0;
                        }
                      }));
        };
        subscribeToFriendStatus(friendId, handleStatusChange);
        Curry._1(setState, (function (param) {
                return /* Loading */1;
              }));
        return (function (param) {
                  unsubscribeFromFriendStatus(friendId, handleStatusChange);

                });
      });
  return match[0];
}
</code></pre>

<p></CodeTab></p>
<p>There’s nothing new inside of it — the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.</p>
<p>Unlike a React component, a custom Hook doesn’t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it’s just like a normal function. Its name should always start with use so that you can tell at a glance that the rules of Hooks apply to it.</p>
<p>The purpose of our <code>useFriendStatus</code> Hook is to subscribe us to a friend’s status. This is why it takes <code>friendId</code> as an argument, and returns the online state like <code>Online</code>, <code>Offline</code> or <code>Loading</code>:</p>
<pre class="codehilite"><code class="language-res">let useFriendStatus = (friendId: string): status {
  let (state, setState) = React.useState(_ =&gt; Offline);

  // ...

  state
}
</code></pre>

<p>Now let’s use our custom Hook.</p>
<h2>Using a Custom Hook</h2>
<p>In the beginning, our stated goal was to remove the duplicated logic from the <code>FriendStatus</code> and <code>FriendListItem</code> components. Both of them want to know the online state of a friend.</p>
<p>Now that we’ve extracted this logic to a useFriendStatus hook, we can just use it:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res {6}
// FriendStatus.res
type friend = { id: string };</p>
<p>@react.component
let make = (~friend: friend) =&gt; {
  let onlineState = FriendStatusHook.useFriendStatus(friend.id);</p>
<p>let status = switch(onlineState) {
    | FriendStatusHook.Online =&gt; "Online"
    | Loading =&gt; "Loading"
    | Offline =&gt; "Offline"
  }</p>
<p>React.string(status);
}</p>
<pre class="codehilite"><code>```js
function FriendStatus(Props) {
  var friend = Props.friend;
  var onlineState = useFriendStatus(friend.id);
  var color;
  switch (onlineState) {
    case /* Offline */0 :
        color = &quot;red&quot;;
        break;
    case /* Loading */1 :
        color = &quot;grey&quot;;
        break;
    case /* Online */2 :
        color = &quot;green&quot;;
        break;

  }
  return React.createElement(&quot;li&quot;, {
              style: {
                color: color
              }
            }, friend.name);
}
</code></pre>

<p></CodeTab></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res {4}
// FriendListItem.res
@react.component
let make = (~friend: friend) =&gt; {
  let onlineState = FriendStatusHook.useFriendStatus(friend.id);</p>
<p>let color = switch(onlineState) {
    | Offline =&gt; "red"
    | Online =&gt; "green"
    | Loading =&gt; "grey"
  }</p>
<li style={ReactDOMStyle.make(~color,())}>
      {React.string(friend.name)}
  </li>
<p>}</p>
<pre class="codehilite"><code>```js
function FriendListItem(Props) {
  var friend = Props.friend;
  var onlineState = useFriendStatus(friend.id);
  var color;
  switch (onlineState) {
    case /* Offline */0 :
        color = &quot;red&quot;;
        break;
    case /* Loading */1 :
        color = &quot;grey&quot;;
        break;
    case /* Online */2 :
        color = &quot;green&quot;;
        break;

  }
  return React.createElement(&quot;li&quot;, {
              style: {
                color: color
              }
            }, friend.name);
}
</code></pre>

<p></CodeTab></p>
<p><strong>Is this code equivalent to the original examples?</strong> Yes, it works in exactly the same way. If you look closely, you’ll notice we didn’t make any changes to the behavior. All we did was to extract some common code between two functions into a separate function. Custom Hooks are a convention that naturally follows from the design of Hooks, rather than a React feature.</p>
<p><strong>Do I have to name my custom Hooks starting with “use”?</strong> Please do. This convention is very important. Without it, we wouldn’t be able to automatically check for violations of rules of Hooks because we couldn’t tell if a certain function contains calls to Hooks inside of it.</p>
<p><strong>Do two components using the same Hook share state?</strong> No. Custom Hooks are a mechanism to reuse stateful logic (such as setting up a subscription and remembering the current value), but every time you use a custom Hook, all state and effects inside of it are fully isolated.</p>
<p><strong>How does a custom Hook get isolated state?</strong> Each call to a Hook gets isolated state. Because we call useFriendStatus directly, from React’s point of view our component just calls useState and useEffect. And as we learned earlier, we can call useState and useEffect many times in one component, and they will be completely independent.</p>
<h3>Tip: Pass Information Between Hooks</h3>
<p>Since Hooks are functions, we can pass information between them.</p>
<p>To illustrate this, we’ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res {11,12,14-18,22}
type friend = {id: string, name: string}</p>
<p>let friendList = [
  {id: "1", name: "Phoebe"},
  {id: "2", name: "Rachel"},
  {id: "3", name: "Ross"},
]</p>
<p>@react.component
let make = () =&gt; {
  let (recipientId, setRecipientId) = React.useState(_ =&gt; "1")
  let recipientOnlineState = FriendStatusHook.useFriendStatus(recipientId)</p>
<p>let color = switch recipientOnlineState {
  | FriendStatusHook.Offline =&gt; Circle.Red
  | Online =&gt; Green
  | Loading =&gt; Grey
  }</p>
<p>let onChange = evt =&gt; {
    let value = ReactEvent.Form.target(evt)["value"]
    setRecipientId(value)
  }</p>
<p>let friends = Belt.Array.map(friendList, friend =&gt; {
    <option key={friend.id} value={friend.id}>
      {React.string(friend.name)}
    </option>
  })</p>
<p>&lt;&gt;
    <Circle color />
    <select value={recipientId} onChange>
      {React.array(friends)}
    </select>
<br />
}</p>
<pre class="codehilite"><code>```js
var friendList = [
  {
    id: &quot;1&quot;,
    name: &quot;Phoebe&quot;
  },
  {
    id: &quot;2&quot;,
    name: &quot;Rachel&quot;
  },
  {
    id: &quot;3&quot;,
    name: &quot;Ross&quot;
  }
];

function Playground(Props) {
  var match = React.useState(function () {
        return &quot;1&quot;;
      });
  var setRecipientId = match[1];
  var recipientId = match[0];
  var recipientOnlineState = useFriendStatus(recipientId);
  var color;
  switch (recipientOnlineState) {
    case /* Offline */0 :
        color = /* Red */0;
        break;
    case /* Loading */1 :
        color = /* Grey */2;
        break;
    case /* Online */2 :
        color = /* Green */1;
        break;

  }
  var onChange = function (evt) {
    return Curry._1(setRecipientId, evt.target.value);
  };
  var friends = Belt_Array.map(friendList, (function (friend) {
          return React.createElement(&quot;option&quot;, {
                      key: friend.id,
                      value: friend.id
                    }, friend.name);
        }));
  return React.createElement(React.Fragment, undefined, React.createElement(Playground$Circle, {
                  color: color
                }), React.createElement(&quot;select&quot;, {
                  value: recipientId,
                  onChange: onChange
                }, friends));
}
</code></pre>

<p></CodeTab></p>
<p>We keep the currently chosen friend ID in the <code>recipientId</code> state variable, and update it if the user chooses a different friend in the <code>&lt;select&gt;</code> picker.</p>
<p>Because the useState Hook call gives us the latest value of the <code>recipientId</code> state variable, we can pass it to our custom <code>FriendStatusHook.useFriendStatus</code> Hook as an argument:</p>
<pre class="codehilite"><code class="language-res">let (recipientId, setRecipientId) = React.useState(_ =&gt; &quot;1&quot;)
let recipientOnlineState = FriendStatusHook.useFriendStatus(recipientId)
</code></pre>

<p>This lets us know whether the currently selected friend is online. If we pick a different friend and update the <code>recipientId</code> state variable, our <code>FriendStatus.useFriendStatus</code> Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.</p>
<h2>Use Your Imagination</h2>
<p>Custom Hooks offer the flexibility of sharing logic. You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven’t considered. What’s more, you can build Hooks that are just as easy to use as React’s built-in features.</p>
<p>Try to resist adding abstraction too early. It's pretty common that components grow pretty big when there is enough stateful logic handling involved. This is normal — don’t feel like you have to immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.</p><h1>rendering-elements</h1><hr />
<p>title: Rendering Elements
description: "How to render React elements to the DOM"
canonical: "/docs/react/latest/rendering-elements"</p>
<hr />
<h1>Rendering Elements</h1>
<p><Intro></p>
<p>In our previous section <a href="./elements-and-jsx">React Elements &amp; JSX</a> we learned how to create and handle React elements. In this section we will learn how to put our elements into action by rendering them into the DOM.</p>
<p></Intro></p>
<p>As we mentioned before, a <code>React.element</code> describes what you see on the screen:</p>
<pre class="codehilite"><code class="language-res">let element = &lt;h1&gt; {React.string(&quot;Hello World&quot;)} &lt;/h1&gt;
</code></pre>

<p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
<h2>Rendering Elements to the DOM</h2>
<p>Let's assume we've got an HTML file that contains a <code>div</code> like this:</p>
<pre class="codehilite"><code class="language-html">&lt;div id=&quot;root&quot;/&gt;
</code></pre>

<p>We call this a “root” DOM node because everything inside it will be managed by React DOM.</p>
<p>Plain React applications usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p>
<p>To render our React application into the <code>root</code> div, we need to do two things:
- Find our DOM node with <code>ReactDOM.querySelector</code>
- Render our React element to our queried <code>Dom.element</code> with <code>ReactDOM.render</code></p>
<p>Here is a full example rendering our application in our <code>root</code> div:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Dom access can actually fail. ReScript
// is really explicit about handling edge cases!
switch ReactDOM.querySelector(&quot;#root&quot;) {
| Some(rootElement) =&gt; {
    let root = ReactDOM.Client.createRoot(rootElement)
    ReactDOM.Client.Root.render(root, &lt;div /&gt;)
  }
| None =&gt; ()
}
</code></pre>

<pre class="codehilite"><code class="language-js">var root = document.querySelector(&quot;#root&quot;);

if (!(root == null)) {
  ReactDom.render(React.createElement(&quot;div&quot;, undefined, &quot;Hello Andrea&quot;), root);
}
</code></pre>

<p></CodeTab></p>
<p>React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p>
<p>At this point we would need to understand a few more concepts, such as React components and state management to be able to update the rendered elements after the initial <code>ReactDOM.Client.Root.render</code>. For now, just imagine your React application as a tree of elements, whereby some elements may get replaced during the lifetime of your application.</p>
<p>React will automatically recognize any element changes and will only apply the DOM updates necessary to bring the DOM to the desired state.</p><h1>hooks-effect</h1><hr />
<p>title: useEffect Hook
description: "Details about the useEffect React hook in ReScript"
canonical: "/docs/react/latest/hooks-effect"</p>
<hr />
<h1>useEffect</h1>
<p><Intro></p>
<p>The <em>Effect</em> Hook lets you perform side effects in function components.</p>
<p></Intro></p>
<h2>What are Effects?</h2>
<p>Common examples for (side) effects are data fetching, setting up a subscription, and manually changing the DOM in React components.</p>
<p>There are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. We'll look into the distinction later on in our examples, but first let's see how the interface looks like.</p>
<h2>Basic Usage</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Runs after every completed render
React.useEffect(() =&gt; {
  // Run effects
  None // or Some(() =&gt; {})
})


// Runs only once right after mounting the component
React.useEffect0(() =&gt; {
  // Run effects
  None // or Some(() =&gt; {})
})

// Runs everytime `prop1` has changed
React.useEffect1(() =&gt; {
  // Run effects based on prop1
  None
}, [prop1])

// Runs everytime `prop1` or `prop2` has changed
React.useEffect2(() =&gt; {
  // Run effects based on prop1 / prop2
  None
}, (prop1, prop2))

React.useEffect3(() =&gt; {
  None
}, (prop1, prop2, prop3));

// useEffect4...7 with according dependency
// tuple just like useEffect3
</code></pre>

<pre class="codehilite"><code class="language-js">React.useEffect(function () { });
React.useEffect((function () { }), []);
React.useEffect((function () { }), [prop1]);
React.useEffect((function () { }), [ prop1, prop2 ]);
React.useEffect((function () { }), [ prop1, prop2, prop3 ]);
</code></pre>

<p></CodeTab></p>
<p><code>React.useEffect</code> receives a function that contains imperative, possibly effectful code, and returns a value <code>option&lt;unit =&gt; unit&gt;</code> as a potential cleanup function.</p>
<p>A <code>useEffect</code> call may receive an additional array of dependencies (see <code>React.useEffect1</code> / <code>React.useEffect2...7</code>). The effect function will run whenever one of the provided dependencies has changed. More details on why this is useful <a href="#effect-dependencies">down below</a>.</p>
<p><strong>Note:</strong> You probably wonder why <code>React.useEffect1</code> receives an <code>array</code>, and <code>useEffect2</code> etc require a <code>tuple</code> (e.g. <code>(prop1, prop2)</code>) for the dependency list. That's because a tuple can receive multiple values of different types, whereas an <code>array</code> only accepts values of identical types. It's possible to replicate <code>useEffect2</code> by doing <code>React.useEffect1(fn, [1, 2])</code>, on other hand the type checker wouldn't allow <code>React.useEffect1(fn, [1, "two"])</code>.</p>
<p><code>React.useEffect</code> will run its function after every completed render, while <code>React.useEffect0</code> will only run the effect on the first render (when the component has mounted).</p>
<h2>Examples</h2>
<h3>Effects without Cleanup</h3>
<p>Sometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them.</p>
<p>As an example, let's write a counter component that updates <code>document.title</code> on every render:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Counter.res
module Document = {
  type t;
  @val external document: t = &quot;document&quot;;
  @set external setTitle: (t, string) =&gt; unit = &quot;title&quot;
}

@react.component
let make = () =&gt; {
  let (count, setCount) = React.useState(_ =&gt; 0);

  React.useEffect(() =&gt; {
    open Document
    document-&gt;setTitle(`You clicked ${Belt.Int.toString(count)} times!`)
    None
  }, );

  let onClick = (_evt) =&gt; {
    setCount(prev =&gt; prev + 1)
  };

  let msg = &quot;You clicked&quot; ++ Belt.Int.toString(count) ++  &quot;times&quot;

  &lt;div&gt;
    &lt;p&gt;{React.string(msg)}&lt;/p&gt;
    &lt;button onClick&gt; {React.string(&quot;Click me&quot;)} &lt;/button&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function Counter(Props) {
  var match = React.useState(function () {
        return 0;
      });
  var setCount = match[1];
  var count = match[0];
  React.useEffect(function () {
        document.title = &quot;You clicked &quot; + String(count) + &quot; times!&quot;;

      });
  var onClick = function (_evt) {
    return Curry._1(setCount, (function (prev) {
                  return prev + 1 | 0;
                }));
  };
  var msg = &quot;You clicked&quot; + String(count) + &quot;times&quot;;
  return React.createElement(&quot;div&quot;, undefined,
    React.createElement(&quot;p&quot;, undefined, msg),
      React.createElement(&quot;button&quot;, {
                  onClick: onClick
                }, &quot;Click me&quot;));
}
</code></pre>

<p></CodeTab></p>
<p>In case we want to make the effects dependent on <code>count</code>, we can just use following <code>useEffect</code> call instead:</p>
<pre class="codehilite"><code class="language-res"> React.useEffect1(() =&gt; {
    open Document
    document-&gt;setTitle(`You clicked ${Belt.Int.toString(count)} times!`)
    None
  }, [count]);
</code></pre>

<p>Now instead of running an effect on every render, it will only run when <code>count</code> has a different value than in the render before.</p>
<h3>Effects with Cleanup</h3>
<p>Earlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak!</p>
<p>Let's look at an example that gracefully subscribes, and later on unsubscribes from some subscription API:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// FriendStatus.res

module ChatAPI = {
  // Imaginary globally available ChatAPI for demo purposes
  type status = { isOnline: bool };
  @val external subscribeToFriendStatus: (string, status =&gt; unit) =&gt; unit = &quot;subscribeToFriendStatus&quot;;
  @val external unsubscribeFromFriendStatus: (string, status =&gt; unit) =&gt; unit = &quot;unsubscribeFromFriendStatus&quot;;
}

type state = Offline | Loading | Online;

@react.component
let make = (~friendId: string) =&gt; {
  let (state, setState) = React.useState(_ =&gt; Offline)

  React.useEffect(() =&gt; {
    let handleStatusChange = (status) =&gt; {
      setState(_ =&gt; {
        status.ChatAPI.isOnline ? Online : Offline
      })
    }

    ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange);
    setState(_ =&gt; Loading);

    let cleanup = () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)
    }

    Some(cleanup)
  })

  let text = switch(state) {
    | Offline =&gt; friendId ++ &quot; is offline&quot;
    | Online =&gt; friendId ++ &quot; is online&quot;
    | Loading =&gt; &quot;loading...&quot;
  }

  &lt;div&gt;
    {React.string(text)}
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function FriendStatus(Props) {
  var friendId = Props.friendId;
  var match = React.useState(function () {
        return /* Offline */0;
      });
  var setState = match[1];
  React.useEffect(function () {
        var handleStatusChange = function (status) {
          return Curry._1(setState, (function (param) {
                        if (status.isOnline) {
                          return /* Online */2;
                        } else {
                          return /* Offline */0;
                        }
                      }));
        };
        subscribeToFriendStatus(friendId, handleStatusChange);
        Curry._1(setState, (function (param) {
                return /* Loading */1;
              }));
        return (function (param) {
                  unsubscribeFromFriendStatus(friendId, handleStatusChange);

                });
      });
  var text;
  switch (match[0]) {
    case /* Offline */0 :
        text = friendId + &quot; is offline&quot;;
        break;
    case /* Loading */1 :
        text = &quot;loading...&quot;;
        break;
    case /* Online */2 :
        text = friendId + &quot; is online&quot;;
        break;

  }
  return React.createElement(&quot;div&quot;, undefined, text);
}
</code></pre>

<p></CodeTab></p>
<h2>Effect Dependencies</h2>
<p>In some cases, cleaning up or applying the effect after every render might create a performance problem. Let's look at a concrete example to see what <code>useEffect</code> does:</p>
<pre class="codehilite"><code class="language-res">// from a previous example above
React.useEffect1(() =&gt; {
  open Document
  document-&gt;setTitle(`You clicked ${Belt.Int.toString(count)} times!`)
  None;
}, [count]);
</code></pre>

<p>Here, we pass <code>[count]</code> to <code>useEffect1</code> as a dependency. What does this mean? If the <code>count</code> is 5, and then our component re-renders with count still equal to 5, React will compare <code>[5]</code> from the previous render and <code>[5]</code> from the next render. Because all items within the array are the same (5 === 5), React would skip the effect. That’s our optimization.</p>
<p>When we render with count updated to 6, React will compare the items in the <code>[5]</code> array from the previous render to items in the <code>[6]</code> array from the next render. This time, React will re-apply the effect because <code>5 !== 6</code>. If there are multiple items in the array, React will re-run the effect even if just one of them is different.</p>
<p>This also works for effects that have a cleanup phase:</p>
<pre class="codehilite"><code class="language-res">// from a previous example above
React.useEffect1(() =&gt; {
  let handleStatusChange = (status) =&gt; {
    setState(_ =&gt; {
      status.ChatAPI.isOnline ? Online : Offline
    })
  }

  ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange);
  setState(_ =&gt; Loading);

  let cleanup = () =&gt; {
    ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)
  }

  Some(cleanup)
}, [friendId]) // Only re-subscribe if friendId changes
</code></pre>

<p><strong>Important:</strong> If you use this optimization, make sure the array includes all values from the component scope (such as props and state) that change over time and that are used by the effect. Otherwise, your code will reference stale values from previous renders</p>
<p>If you want to run an effect and clean it up only once (on mount and unmount), use <code>React.useEffect0</code>.</p>
<p>If you are interested in more performance optmization related topics, have a look at the ReactJS <a href="https://reactjs.org/docs/hooks-faq.html#performance-optimizations">Performance Optimization Docs</a> for more detailed infos.</p><h1>router</h1><hr />
<p>title: Router
description: "Basic concepts for navigation and routing in ReScript &amp; React"
canonical: "/docs/react/latest/router"</p>
<hr />
<h1>Router</h1>
<p>RescriptReact comes with a router! We've leveraged the language and library features in order to create a router that's:</p>
<ul>
<li>The simplest, thinnest possible.</li>
<li>Easily pluggable anywhere into your existing code.</li>
<li>Performant and tiny.</li>
</ul>
<h2>How does it work?</h2>
<p>The available methods are listed here:
  - <code>RescriptReactRouter.push(string)</code>: takes a new path and update the URL.
  - <code>RescriptReactRouter.replace(string)</code>: like <code>push</code>, but replaces the current URL.
  - <code>RescriptReactRouter.watchUrl(f)</code>: start watching for URL changes. Returns a subscription token. Upon url change, calls the callback and passes it the <code>RescriptReactRouter.url</code> record.
  - <code>RescriptReactRouter.unwatchUrl(watcherID)</code>: stop watching for URL changes.
  - <code>RescriptReactRouter.dangerouslyGetInitialUrl()</code>: get <code>url</code> record outside of <code>watchUrl</code>. Described later.
  - <code>RescriptReactRouter.useUrl(~serverUrl)</code>: returns the <code>url</code> record inside a component.</p>
<blockquote>
<p>If you want to know more about the low level details on how the router interface is implemented, refer to the <a href="https://github.com/rescript-lang/rescript-react/blob/master/src/RescriptReactRouter.res">RescriptReactRouter implementation</a>.</p>
</blockquote>
<h2>Match a Route</h2>
<p><em>There's no API</em>! <code>watchUrl</code> gives you back a <code>url</code> record of the following shape:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res prelude
type url = {
  /* path takes window.location.pathname, like "/book/title/edit" and turns it into</code>list{"book", "title", "edit"}` <em>/
  path: list<string>,
  /</em> the url's hash, if any. The # symbol is stripped out for you <em>/
  hash: string,
  /</em> the url's query params, if any. The ? symbol is stripped out for you */
  search: string
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>So the url <code>www.hello.com/book/10/edit?name=Jane#author</code> is given back as:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
{
  path: list{"book", "10", "edit"},
  hash: "author",
  search: "name=Jane"
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Basic Example</h2>
<p>Let's start with a first example to see how a ReScript React Router looks like:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// App.res
@react.component
let make = () =&gt; {
  let url = RescriptReactRouter.useUrl()

  switch url.path {
    | list{&quot;user&quot;, id} =&gt; &lt;User id /&gt;
    | list{} =&gt; &lt;Home/&gt;
    | _ =&gt; &lt;PageNotFound/&gt;
  }
}
</code></pre>

<pre class="codehilite"><code class="language-js">import * as React from &quot;react&quot;;
import * as User from &quot;./User.bs.js&quot;;
import * as RescriptReactRouter from &quot;@rescript/react/src/RescriptReactRouter.bs.js&quot;;
import * as Home from &quot;./Home.bs.js&quot;;
import * as NotFound from &quot;./NotFound.bs.js&quot;;

function App(Props) {
  var url = RescriptReactRouter.useUrl(undefined, undefined);
  var match = url.path;
  if (!match) {
    return React.createElement(Home.make, {});
  }
  if (match.hd === &quot;user&quot;) {
    var match$1 = match.tl;
    if (match$1 &amp;&amp; !match$1.tl) {
      return React.createElement(User.make, {
                  id: match$1.hd
                });
    }

  }
  return React.createElement(NotFound.make, {});
}

var make = App;

export {
  make ,

}
</code></pre>

<p></CodeTab></p>
<h2>Directly Get a Route</h2>
<p>In one specific occasion, you might want to take hold of a <code>url</code> record outside of <code>watchUrl</code>. For example, if you've put <code>watchUrl</code> inside a component's <code>didMount</code> so that a URL change triggers a component state change, you might also want the initial state to be dictated by the URL.</p>
<p>In other words, you'd like to read from the <code>url</code> record once at the beginning of your app logic. We expose <code>dangerouslyGetInitialUrl()</code> for this purpose.</p>
<p>Note: the reason why we label it as "dangerous" is to remind you not to read this <code>url</code> in any arbitrary component's e.g. <code>render</code>, since that information might be out of date if said component doesn't also contain a <code>watchUrl</code> subscription that re-renders the component when the URL changes. Aka, please only use <code>dangerouslyGetInitialUrl</code> alongside <code>watchUrl</code>.</p>
<h2>Push a New Route</h2>
<p>From anywhere in your app, just call e.g. <code>RescriptReactRouter.push("/books/10/edit#validated")</code>. This will trigger a URL change (without a page refresh) and <code>watchUrl</code>'s callback will be called again.</p>
<p>We might provide better facilities for typed routing + payload carrying in the future!</p>
<p>Note: because of browser limitations, changing the URL through JavaScript (aka pushState) cannot be detected. The solution is to change the URL then fire a "popState" event. This is what Router.push does, and what the event watchUrl listens to.
So if, for whatever reason (e.g. incremental migration), you want to update the URL outside of <code>RescriptReactRouter.push</code>, just do <code>window.dispatchEvent(new Event('popState'))</code>.</p>
<h2>Design Decisions</h2>
<p>We always strive to lower the performance and learning overhead in RescriptReact, and our router design's no different. The entire implementation, barring browser features detection, is around 20 lines. The design might seem obvious in retrospect, but to arrive here, we had to dig back into ReactJS internals &amp; future proposals to make sure we understood the state update mechanisms, the future context proposal, lifecycle ordering, etc. and reject some bad API designs along the way. It's nice to arrive at such an obvious solution!</p>
<p>The API also doesn't dictate whether matching on a route should return a component, a state update, or a side-effect. Flexible enough to slip into existing apps.</p>
<p>Performance-wise, a JavaScript-like API tends to use a JS object of route string -&gt; callback. We eschewed that in favor of pattern-matching, since the latter in Rescript does not allocate memory, and is compiled to a fast jump table in C++ (through the JS JIT). In fact, the only allocation in the router matching is the creation of the url record!</p><h1>forwarding-refs</h1><hr />
<p>title: Forwarding Refs
description: "Forwarding Ref values in ReScript and React"
canonical: "/docs/react/latest/forwarding-refs"</p>
<hr />
<h1>Forwarding Refs</h1>
<p><Intro></p>
<p>Ref forwarding is a technique for automatically passing a <a href="./refs-and-the-dom">React.ref</a> through a component to one of its children. This is typically not necessary for most components in the application. However, it can be useful for some kinds of components, especially in reusable component libraries. The most common scenarios are described below.</p>
<p></Intro></p>
<h2>Why Ref Forwarding?</h2>
<p>Consider a FancyButton component that renders the native button DOM element:</p>
<pre class="codehilite"><code class="language-res">// FancyButton.res

@react.component
let make = (~children) =&gt; {
  &lt;button className=&quot;FancyButton&quot;&gt;
    children
  &lt;/button&gt;
}
</code></pre>

<p>React components hide their implementation details, including their rendered output. Other components using FancyButton <strong>usually will not need</strong> to obtain a ref to the inner button DOM element. This is good because it prevents components from relying on each other’s DOM structure too much.</p>
<p>Although such encapsulation is desirable for application-level components like <code>FeedStory</code> or <code>Comment</code>, it can be inconvenient for highly reusable “leaf” components like <code>FancyButton</code> or <code>MyTextInput</code>. These components tend to be used throughout the application in a similar manner as a regular DOM button and input, and accessing their DOM nodes may be unavoidable for managing focus, selection, or animations.</p>
<p>There are currently two strategies on forwarding refs through a component. In ReScript and React we strongly recommend <strong>passing your ref as a prop</strong>, but there is also a dedicated API called <code>React.forwardRef</code>.</p>
<p>We will discuss both methods in this document.</p>
<h2>Forward Refs via Props</h2>
<p>A <code>React.ref</code> can be passed down like any other prop. The component will take care of forwarding the ref to the right DOM element.</p>
<p><strong>No new concepts to learn!</strong></p>
<p>In the example below, <code>FancyInput</code> defines a prop <code>inputRef</code> that will be forwarded to its <code>input</code> element:</p>
<pre class="codehilite"><code class="language-res">// App.res

module FancyInput = {
  @react.component
  let make = (~children, ~inputRef: ReactDOM.domRef) =&gt;
    &lt;div&gt; &lt;input type_=&quot;text&quot; ref=inputRef /&gt; children &lt;/div&gt;
}

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

@react.component
let make = () =&gt; {
  let input = React.useRef(Js.Nullable.null)

  let focusInput = () =&gt;
    input.current
    -&gt;Js.Nullable.toOption
    -&gt;Belt.Option.forEach(input =&gt; input-&gt;focus)

  let onClick = _ =&gt; focusInput()

  &lt;div&gt;
    &lt;FancyInput inputRef={ReactDOM.Ref.domRef(input)}&gt;
      &lt;button onClick&gt; {React.string(&quot;Click to focus&quot;)} &lt;/button&gt;
    &lt;/FancyInput&gt;
  &lt;/div&gt;
}
</code></pre>

<p>We use the <code>ReactDOM.domRef</code> type to represent our <code>inputRef</code>. We pass our ref in the exact same manner as we'd do a DOM <code>ref</code> attribute (<code>&lt;input ref={ReactDOM.Ref.domRef(myRef)} /&gt;</code>).</p>
<h2>[Discouraged] React.forwardRef</h2>
<p><strong>Note:</strong> We discourage this method since it <a href="https://twitter.com/dan_abramov/status/1173372190395445251">will likely go away</a> at some point, and doesn't yield any obvious advantages over the previously mentioned ref prop passing.</p>
<p><code>React.forwardRef</code> offers a way to "emulate a <code>ref</code> prop" within custom components. Internally the component will forward the passed <code>ref</code> value to the target DOM element instead.</p>
<p>This is how the previous example would look like with the <code>React.forwardRef</code> approach:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// App.res

module FancyInput = {
  @react.component
  let make = React.forwardRef((~className=?, ~children, ref) =&gt;
    &lt;div&gt;
      &lt;input
        type_=&quot;text&quot;
        ?className
        ref=?{Js.Nullable.toOption(ref)-&gt;Belt.Option.map(ReactDOM.Ref.domRef)}
      /&gt;
      children
    &lt;/div&gt;
  )
}

@send external focus: Dom.element =&gt; unit = &quot;focus&quot;

@react.component
let make = () =&gt; {
  let input = React.useRef(Js.Nullable.null)

  let focusInput = () =&gt;
    input.current-&gt;Js.Nullable.toOption-&gt;Belt.Option.forEach(input =&gt; input-&gt;focus)

  let onClick = _ =&gt; focusInput()

  &lt;div&gt;
    &lt;FancyInput className=&quot;fancy&quot; ref=input&gt;
      &lt;button onClick&gt; {React.string(&quot;Click to focus&quot;)} &lt;/button&gt;
    &lt;/FancyInput&gt;
  &lt;/div&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">import * as React from &quot;react&quot;;
import * as Belt_Option from &quot;rescript/lib/es6/belt_Option.js&quot;;
import * as Caml_option from &quot;rescript/lib/es6/caml_option.js&quot;;

var make = React.forwardRef(function (props, ref) {
  return React.createElement(
    &quot;div&quot;,
    undefined,
    React.createElement(&quot;input&quot;, {
      ref: Belt_Option.map(
        ref == null ? undefined : Caml_option.some(ref),
        function (prim) {
          return prim;
        }
      ),
      className: props.className,
      type: &quot;text&quot;,
    }),
    props.children
  );
});

var FancyInput = {
  make: make,
};

function App(props) {
  var input = React.useRef(null);
  var onClick = function (param) {
    Belt_Option.forEach(
      Caml_option.nullable_to_opt(input.current),
      function (input) {
        input.focus();
      }
    );
  };
  return React.createElement(
    &quot;div&quot;,
    undefined,
    React.createElement(make, {
      className: &quot;fancy&quot;,
      children: React.createElement(
        &quot;button&quot;,
        {
          onClick: onClick,
        },
        &quot;Click to focus&quot;
      ),
      ref: input,
    })
  );
}
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> Our <code>@react.component</code> decorator transforms our labeled argument props within our <code>React.forwardRef</code> function in the same manner as our classic <code>make</code> function.</p>
<p>This way, components using <code>FancyInput</code> can get a ref to the underlying <code>input</code> DOM node and access it if necessary—just like if they used a DOM <code>input</code> directly.</p>
<h2>Note for Component Library Maintainers</h2>
<p><strong>When you start using ref forwarding in a component library, you should treat it as a breaking change and release a new major version of your library</strong>. This is because your library likely has an observably different behavior (such as what refs get assigned to, and what types are exported), and this can break apps and other libraries that depend on the old behavior.</p><h1>context</h1><hr />
<p>title: Context
description: "Details about Context in ReScript and React"
canonical: "/docs/react/latest/context"</p>
<hr />
<h1>Context</h1>
<p><Intro></p>
<p>Context provides a way to pass data through the component tree without having to pass props down manually at every level.</p>
<p></Intro></p>
<h2>Why Context?</h2>
<p>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</p>
<p><strong>Note:</strong> In ReScript, passing down props is way simpler than in TS / JS due to its <a href="/docs/manual/latest/jsx#punning">JSX prop punning</a> feature and strong type inference, so it's often preferrable to keep it simple and just do props passing. Less magic means more transparency!</p>
<h2>When to Use Context</h2>
<p>Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a “theme” prop in order to style the Button component:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// src/App.res
type theme = Light | Dark;

module Button = {
  @react.component
  let make = (~theme) =&gt; {
    let className = switch theme {
      | Light =&gt; &quot;theme-light&quot;
      | Dark =&gt; &quot;theme-black&quot;
    };
    &lt;button className&gt; {React.string(&quot;Click me&quot;)} &lt;/button&gt;
  }
}

module ThemedButton = {
  @react.component
  let make = (~theme) =&gt; {
    &lt;Button theme /&gt;
  }
}

module Toolbar = {
  @react.component
  let make = (~theme) =&gt; {
    &lt;div&gt;
      &lt;ThemedButton theme/&gt;
    &lt;/div&gt;
  }
}

@react.component
let make = () =&gt; {
  // We define the theme in the
  // toplevel App component and
  // pass it down
  &lt;Toolbar theme=Dark/&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">function Button(props) {
  var className = props.theme ? &quot;theme-black&quot; : &quot;theme-light&quot;;
  return React.createElement(&quot;button&quot;, {
              className: className
            }, &quot;Click me&quot;);
}

function ThemedButton(props) {
  return React.createElement(App$Button, {
              theme: props.theme
            });
}

function Toolbar(props) {
  return React.createElement(&quot;div&quot;, undefined, React.createElement(App$ThemedButton, {
                  theme: props.theme
                }));
}

function App(props) {
  return React.createElement(App$Toolbar, {
              theme: /* Dark */1
            });
}
</code></pre>

<p></CodeTab></p>
<p>Using context, we can avoid passing props through intermediate elements:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// src/App.res

module ThemeContext = {
  type theme = Light | Dark
  let context = React.createContext(Light)

  module Provider = {
    let make = React.Context.provider(context)
  }
}

module Button = {
  @react.component
  let make = (~theme) =&gt; {
    let className = switch theme {
    | ThemeContext.Light =&gt; &quot;theme-light&quot;
    | Dark =&gt; &quot;theme-black&quot;
    }
    &lt;button className&gt; {React.string(&quot;Click me&quot;)} &lt;/button&gt;
  }
}

module ThemedButton = {
  @react.component
  let make = () =&gt; {
    let theme = React.useContext(ThemeContext.context)

    &lt;Button theme /&gt;
  }
}

module Toolbar = {
  @react.component
  let make = () =&gt; {
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  }
}

@react.component
let make = () =&gt; {
  &lt;ThemeContext.Provider value=ThemeContext.Dark&gt;
    &lt;div&gt;
      &lt;Toolbar /&gt;
    &lt;/div&gt;
  &lt;/ThemeContext.Provider&gt;
}
</code></pre>

<pre class="codehilite"><code class="language-js">var context = React.createContext(/* Light */0);

var make = context.Provider;

var Provider = {
  make: make
};

var ThemeContext = {
  context: context,
  Provider: Provider
};

function App$Button(props) {
  var className = props.theme ? &quot;theme-black&quot; : &quot;theme-light&quot;;
  return React.createElement(&quot;button&quot;, {
              className: className
            }, &quot;Click me&quot;);
}

var Button = {
  make: App$Button
};

function App$ThemedButton(props) {
  var theme = React.useContext(context);
  return React.createElement(App$Button, {
              theme: theme
            });
}

var ThemedButton = {
  make: App$ThemedButton
};

function App$Toolbar(props) {
  return React.createElement(&quot;div&quot;, undefined, React.createElement(App$ThemedButton, {}));
}

var Toolbar = {
  make: App$Toolbar
};

function App(props) {
  return React.createElement(make, {
              value: /* Dark */1,
              children: React.createElement(&quot;div&quot;, undefined, React.createElement(App$Toolbar, {}))
            });
}
</code></pre>

<p></CodeTab></p><h1>installation</h1><hr />
<p>title: Installation
description: "Installation and Setup"
canonical: "/docs/react/latest/installation"</p>
<hr />
<h1>Installation</h1>
<p><strong>Requirements:</strong></p>
<ul>
<li><code>rescript@10.1</code> or later</li>
<li><code>react@18.0.0</code> or later</li>
</ul>
<p>Add following dependency to your ReScript project (in case you don't have any project yet, check out the <a href="/docs/manual/latest/installation">installation instructions</a> in the manual):</p>
<pre class="codehilite"><code>npm install @rescript/react
</code></pre>

<p>Then add the following setting to your existing <code>bsconfig.json</code>:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;jsx&quot;: { &quot;version&quot;: 4, &quot;mode&quot;: &quot;classic&quot; },
  &quot;bs-dependencies&quot;: [&quot;@rescript/react&quot;]
}
</code></pre>

<blockquote>
<p>The <a href="https://ko.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html">new jsx transform</a> of ReactJS is available with <code>mode: "automatic"</code>.</p>
</blockquote>
<p><strong>Note</strong> JSX v4 is newly introduced with the idiomatic record-based representation of a component. If your dependencies are not compatible with v4 yet, then you can use v3 in the same project. Check out the details in <a href="/docs/react/latest/migrate-react">Migrate from v3</a></p>
<p>To test your setup, create a new <code>.res</code> file in your source directory and add the following code:</p>
<pre class="codehilite"><code class="language-res">// src/Test.res
@react.component
let make = () =&gt; {
  &lt;div&gt; {React.string(&quot;Hello World&quot;)} &lt;/div&gt;
}
</code></pre>

<p>Now run <code>npx rescript</code> and you should see a successful build.</p>
<h2>Exposed Modules</h2>
<p>After a successful installation, <code>@rescript/react</code> will make the following modules available in your project's global scope:</p>
<ul>
<li><code>React</code>: Bindings to React</li>
<li><code>ReactDOM</code>: Bindings to the ReactDOM</li>
<li><code>ReactDOMServer</code>: Bindings to the ReactDOMServer</li>
<li><code>ReactEvent</code>: Bindings to React's synthetic events</li>
<li><code>ReactDOMStyle</code>: Bindings to the inline style API</li>
<li><code>RescriptReactRouter</code>: A simple, yet fully featured router with minimal memory allocations</li>
<li><code>RescriptReactErrorBoundary</code>: A component which handles errors thrown in its child components gracefully</li>
</ul><h1>libraries</h1><hr />
<p>title: "Libraries &amp; Publishing"
description: "Install &amp; publish ReScript packages"
canonical: "/docs/manual/latest/libraries"</p>
<hr />
<h1>Libraries &amp; Publishing</h1>
<p>ReScript libraries are just like JavaScript libraries: published &amp; hosted on <a href="http://npmjs.com">NPM</a>. You can reuse your <code>npm</code>, <code>yarn</code> and <code>package.json</code>-related tools to manage them!</p>
<h2>Tips &amp; Tricks</h2>
<h3>Publish</h3>
<p>We recommend you to check in your compiled JavaScript output, for its <a href="interop-with-js-build-systems.md#popular-js-build-systems">various benefits</a>. If not, then at least consider publishing the JavaScript output by un-ignoring them in your <a href="https://docs.npmjs.com/cli/v7/using-npm/developers#keeping-files-out-of-your-package">npmignore</a>. This way, your published ReScript package comes with plain JavaScript files that JS users can consume. If your project's good, JS users might not even realize that they've installed a library written in ReScript!</p>
<p>In case your library is only consumed by JS users, you may want to check out our <a href="./build-external-stdlib">external stdlib</a> configuration as well.</p>
<h3>Find Libraries</h3>
<p>Search <code>rescript</code>-related packages on NPM, or use our <a href="/packages">Package Index</a>.</p>
<p>If you can't find what you're looking for, remember that <strong>you don't need a wrapper</strong> to use a JS library:</p>
<ul>
<li>Most JS data types, such as array and objects, <a href="shared-data-types.md">map over cleanly to ReScript and vice-versa</a>.</li>
<li>You also have access to the familiar <a href="api/js">JS API</a>.</li>
<li>You can use a JavaScript library without needing to install dedicated binding libraries. Check the <a href="external"><code>external</code></a> page.</li>
</ul><h1>tuple</h1><hr />
<p>title: "Tuple"
description: "Tuple types and values in ReScript"
canonical: "/docs/manual/latest/tuple"</p>
<hr />
<h1>Tuple</h1>
<p>Tuples are a ReScript-specific data structure that don't exist in JavaScript. They are:</p>
<ul>
<li>immutable</li>
<li>ordered</li>
<li>fix-sized at creation time</li>
<li>heterogeneous (can contain different types of values)</li>
</ul>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let ageAndName = (24, "Lil' ReScript")
let my3dCoordinates = (20.0, 30.5, 100.0)</p>
<pre class="codehilite"><code>```js
var ageAndName = [24, &quot;Lil' ReScript&quot;];
var my3dCoordinates = [20.0, 30.5, 100.0];
</code></pre>

<p></CodeTab></p>
<p>Tuples' types can be used in type annotations as well. Tuple types visually resemble tuples values.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let ageAndName: (int, string) = (24, "Lil' ReScript")
// a tuple type alias
type coord3d = (float, float, float)
let my3dCoordinates: coord3d = (20.0, 30.5, 100.0)</p>
<pre class="codehilite"><code>```js
var ageAndName = [24, &quot;Lil' ReScript&quot;];
var my3dCoordinates = [20.0, 30.5, 100.0];
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: there's no tuple of size 1. You'd just use the value itself.</p>
<h2>Usage</h2>
<p>To get a specific member of a tuple, destructure it:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let (<em>, y, </em>) = my3dCoordinates // now you've retrieved y</p>
<pre class="codehilite"><code>```js
var y = 30.5;
</code></pre>

<p></CodeTab></p>
<p>The <code>_</code> means you're ignoring the indicated members of the tuple.</p>
<p>Tuples aren't meant to be updated mutatively. You'd create new ones by destructuring the old ones:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let coordinates1 = (10, 20, 30)
let (c1x, <em>, </em>) = coordinates1
let coordinates2 = (c1x + 50, 20, 30)</p>
<pre class="codehilite"><code>```js
var coordinates1 = [10, 20, 30];
var c1x = 10;
var coordinates2 = [60, 20, 30];
</code></pre>

<p></CodeTab></p>
<h2>Tips &amp; Tricks</h2>
<p>You'd use tuples in handy situations that pass around multiple values without too much ceremony. For example, to return many values:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let getCenterCoordinates = () =&gt; {
  let x = doSomeOperationsHere()
  let y = doSomeMoreOperationsHere()
  (x, y)
}
</code></pre>

<pre class="codehilite"><code class="language-js">function getCenterCoordinates(param) {
  var x = doSomeOperationsHere(undefined);
  var y = doSomeMoreOperationsHere(undefined);
  return [x, y];
}
</code></pre>

<p></CodeTab></p>
<p>Try to keep the usage of tuple <strong>local</strong>. For data structures that are long-living and passed around often, prefer a <strong>record</strong>, which has named fields.</p><h1>variant</h1><hr />
<p>title: "Variant"
description: "Variant data structures in ReScript"
canonical: "/docs/manual/latest/variant"</p>
<hr />
<h1>Variant</h1>
<p>So far, most of ReScript's data structures might look familiar to you. This section introduces an extremely important, and perhaps unfamiliar, data structure: variant.</p>
<p>Most data structures in most languages are about "this <strong>and</strong> that". A variant allows us to express "this <strong>or</strong> that".</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type myResponse =
  | Yes
  | No
  | PrettyMuch</p>
<p>let areYouCrushingIt = Yes</p>
<pre class="codehilite"><code>```js
var areYouCrushingIt = /* Yes */0;
</code></pre>

<p></CodeTab></p>
<p><code>myResponse</code> is a variant type with the cases <code>Yes</code>, <code>No</code> and <code>PrettyMuch</code>, which are called "variant constructors" (or "variant tag"). The <code>|</code> bar separates each constructor.</p>
<p><strong>Note</strong>: a variant's constructors need to be capitalized.</p>
<h2>Variant Needs an Explicit Definition</h2>
<p>If the variant you're using is in a different file, bring it into scope like you'd do <a href="record.md#record-needs-an-explicit-definition">for a record</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// Zoo.res
type animal = Dog | Cat | Bird</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Example.res
let pet: Zoo.animal = Dog // preferred
// or
let pet2 = Zoo.Dog
</code></pre>

<pre class="codehilite"><code class="language-js">var pet = /* Dog */0;
var pet2 = /* Dog */0;
</code></pre>

<p></CodeTab></p>
<h2>Constructor Arguments</h2>
<p>A variant's constructors can hold extra data separated by comma.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
type account =
  | None
  | Instagram(string)
  | Facebook(string, int)</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>Here, <code>Instagram</code> holds a <code>string</code>, and <code>Facebook</code> holds a <code>string</code> and an <code>int</code>. Usage:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myAccount = Facebook("Josh", 26)
let friendAccount = Instagram("Jenny")</p>
<pre class="codehilite"><code>```js
var myAccount = {
  TAG: /* Facebook */1,
  _0: &quot;Josh&quot;,
  _1: 26
};
var friendAccount = {
  TAG: /* Instagram */0,
  _0: &quot;Jenny&quot;
};
</code></pre>

<p></CodeTab></p>
<h3>Labeled Variant Payloads (Inline Record)</h3>
<p>If a variant payload has multiple fields, you can use a record-like syntax to label them for better readability:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type user =
  | Number(int)
  | Id({name: string, password: string})</p>
<p>let me = Id({name: "Joe", password: "123"})</p>
<pre class="codehilite"><code>```js
var me = {
  TAG: /* Id */1,
  name: &quot;Joe&quot;,
  password: &quot;123&quot;
};
</code></pre>

<p></CodeTab></p>
<p>This is technically called an "inline record", and only allowed within a variant constructor. You cannot inline a record type declaration anywhere else in ReScript.</p>
<p>Of course, you can just put a regular record type in a variant too:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type u = {name: string, password: string}
type user =
  | Number(int)
  | Id(u)</p>
<p>let me = Id({name: "Joe", password: "123"})</p>
<pre class="codehilite"><code>```js
var me = {
  TAG: /* Id */1,
  _0: {
    name: &quot;Joe&quot;,
    password: &quot;123&quot;
  }
};
</code></pre>

<p></CodeTab></p>
<p>The output is slightly uglier and less performant than the former.</p>
<h2>Variant Type Spreads</h2>
<p>Just like <a href="record#record-type-spread">with records</a>, it's possible to use type spreads to create new variants from other variants:</p>
<pre class="codehilite"><code class="language-rescript">type a = One | Two | Three
type b = | ...a | Four | Five
</code></pre>

<p>Type <code>b</code> is now:</p>
<pre class="codehilite"><code class="language-rescript">type b = One | Two | Three | Four | Five
</code></pre>

<p>Type spreads act as a 'copy-paste', meaning all constructors are copied as-is from <code>a</code> to <code>b</code>. Here are the rules for spreads to work:
- You can't overwrite constructors, so the same constructor name can exist in only one place as you spread. This is true even if the constructors are identical.
- All variants and constructors must share the same runtime configuration - <code>@unboxed</code>, <code>@tag</code>, <code>@as</code> and so on.
- You can't spread types in recursive definitions.</p>
<p>Note that you need a leading <code>|</code> if you want to use a spread in the first position of a variant definition.</p>
<h3>Pattern Matching On Variant</h3>
<p>See the <a href="pattern-matching-destructuring">Pattern Matching/Destructuring</a> section later.</p>
<h2>JavaScript Output</h2>
<p>A variant value compiles to 3 possible JavaScript outputs depending on its type declaration:</p>
<ul>
<li>If the variant value is a constructor with no payload, it compiles to a string of the constructor name. Example: <code>Yes</code> compiles to <code>"Yes"</code>.</li>
<li>If it's a constructor with a payload, it compiles to an object with the field <code>TAG</code> and the field <code>_0</code> for the first payload, <code>_1</code> for the second payload, etc. The value of <code>TAG</code> is the constructor name as string by default, but note that the name of the <code>TAG</code> field as well as the string value used for each constructor name <a href="#tagged-variants">can be customized</a>.</li>
<li>Labeled variant payloads (the inline record trick earlier) compile to an object with the label names instead of <code>_0</code>, <code>_1</code>, etc. The object will have the <code>TAG</code> field as per the previous rule.</li>
</ul>
<p>Check the output in these examples:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type greeting = Hello | Goodbye
let g1 = Hello
let g2 = Goodbye</p>
<p>type outcome = Good | Error(string)
let o1 = Good
let o2 = Error("oops!")</p>
<p>type family = Child | Mom(int, string) | Dad (int)
let f1 = Child
let f2 = Mom(30, "Jane")
let f3 = Dad(32)</p>
<p>type person = Teacher | Student({gpa: float})
let p1 = Teacher
let p2 = Student({gpa: 99.5})</p>
<p>type s = {score: float}
type adventurer = Warrior(s) | Wizard(string)
let a1 = Warrior({score: 10.5})
let a2 = Wizard("Joe")</p>
<pre class="codehilite"><code>```js
var g1 = &quot;Hello&quot;;

var g2 = &quot;Goodbye&quot;;

var o1 = &quot;Good&quot;;

var o2 = {
  TAG: &quot;Error&quot;,
  _0: &quot;oops!&quot;
};

var f1 = &quot;Child&quot;;

var f2 = {
  TAG: &quot;Mom&quot;,
  _0: 30,
  _1: &quot;Jane&quot;
};

var f3 = {
  TAG: &quot;Dad&quot;,
  _0: 32
};

var p1 = &quot;Teacher&quot;;

var p2 = {
  TAG: &quot;Student&quot;,
  gpa: 99.5
};

var a1 = {
  TAG: &quot;Warrior&quot;,
  _0: {
    score: 10.5
  }
};

var a2 = {
  TAG: &quot;Wizard&quot;,
  _0: &quot;Joe&quot;
};
</code></pre>

<p></CodeTab></p>
<h2>Tagged variants</h2>
<ul>
<li>The <code>@tag</code> attribute lets you customize the discriminator (default: <code>TAG</code>).</li>
<li><code>@as</code> attributes control what each variant case is discriminated on (default: the variant case name as string).</li>
</ul>
<h3>Example: Binding to TypeScript enums</h3>
<pre class="codehilite"><code class="language-typescript">// direction.ts
/** Direction of the action. */
enum Direction {
  /** The direction is up. */
  Up = &quot;UP&quot;,

  /** The direction is down. */
  Down = &quot;DOWN&quot;,

  /** The direction is left. */
  Left = &quot;LEFT&quot;,

  /** The direction is right. */
  Right = &quot;RIGHT&quot;,
}

export const myDirection = Direction.Up;
</code></pre>

<p>You can bind to the above enums like so:</p>
<pre class="codehilite"><code class="language-rescript">/** Direction of the action. */
type direction =
  | /** The direction is up. */
  @as(&quot;UP&quot;)
  Up

  | /** The direction is down. */
  @as(&quot;DOWN&quot;)
  Down

  | /** The direction is left. */
  @as(&quot;LEFT&quot;)
  Left

  | /** The direction is right. */
  @as(&quot;RIGHT&quot;)
  Right

@module(&quot;./direction.js&quot;) external myDirection: direction = &quot;myDirection&quot;
</code></pre>

<p>Now, this maps 100% to the TypeScript code, including letting us bring over the documentation strings so we get a nice editor experience.</p>
<h3>String literals</h3>
<p>The same logic is easily applied to string literals from TypeScript, only here the benefit is even larger, because string literals have the same limitations in TypeScript that polymorphic variants have in ReScript:</p>
<pre class="codehilite"><code class="language-typescript">// direction.ts
type direction = &quot;UP&quot; | &quot;DOWN&quot; | &quot;LEFT&quot; | &quot;RIGHT&quot;;
</code></pre>

<p>There's no way to attach documentation strings to string literals in TypeScript, and you only get the actual value to interact with.</p>
<h3>Valid <code>@as</code> payloads</h3>
<p>Here's a list of everything you can put in the <code>@as</code> tag of a variant constructor:
- A string literal: <code>@as("success")</code>
- An int: <code>@as(5)</code>
- A float: <code>@as(1.5)</code>
- True/false: <code>@as(true)</code> and <code>@as(false)</code>
- Null: <code>@as(null)</code>
- Undefined: <code>@as(undefined)</code></p>
<h2>Untagged variants</h2>
<p>With <em>untagged variants</em> it is possible to mix types together that normally can't be mixed in the ReScript type system, as long as there's a way to discriminate them at runtime. For example, with untagged variants you can represent a heterogenous array:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed type listItemValue = String(string) | Boolean(bool) | Number(float)

let myArray = [String(&quot;Hello&quot;), Boolean(true), Boolean(false), Number(13.37)]
</code></pre>

<p>Here, each value will be <em>unboxed</em> at runtime. That means that the variant payload will be all that's left, the variant case name wrapping the payload itself will be stripped out and the payload will be all that remains.</p>
<p>It, therefore, compiles to this JS:</p>
<pre class="codehilite"><code class="language-javascript">var myArray = [&quot;hello&quot;, true, false, 13.37];
</code></pre>

<p>In the above example, reaching back into the values is as simple as pattern matching on them.</p>
<h3>Advanced: Unboxing rules</h3>
<h4>No overlap in constructors</h4>
<p>A variant can be unboxed if no constructors have overlap in their runtime representation. </p>
<p>For example, you can't have <code>String1(string) | String2(string)</code> in the same unboxed variant, because there's no way for ReScript to know at runtime which of <code>String1</code> or <code>String2</code> that <code>string</code> belongs to, as it could belong to both.
The same goes for two records - even if they have fully different shapes, they're still JavaScript <code>object</code> at runtime.</p>
<p>Don't worry - the compiler will guide you and ensure there's no overlap.</p>
<h4>What you can unbox</h4>
<p>Here's a list of all possible things you can unbox:
- <code>string</code>: <code>String(string)</code>
- <code>float</code>: <code>Number(float)</code>. Notice <code>int</code> cannot be unboxed, because JavaScript only has <code>number</code> (not actually <code>int</code> and <code>float</code> like in ReScript) so we can't disambiguate between <code>float</code> and <code>int</code> at runtime.
- <code>bool</code>: <code>Boolean(bool)</code>
- <code>array&lt;'value&gt;</code>: <code>List(array&lt;string&gt;)</code>
- <code>promise&lt;'value&gt;</code>: <code>Promise(promise&lt;string&gt;)</code>
- <code>Dict.t</code>: <code>Object(Dict.t&lt;string&gt;)</code>
- <code>Date.t</code>: <code>Date(Date.t)</code>. A JavaScript date.
- <code>Blob.t</code>: <code>Blob(Blob.t)</code>. A JavaScript blob.
- <code>File.t</code>: <code>File(File.t)</code>. A JavaScript file.
- <code>RegExp.t</code>: <code>RegExp(RegExp.t)</code>. A JavaScript regexp instance.</p>
<p>Again notice that the constructor names can be anything, what matters is what's in the payload.</p>
<blockquote>
<p><strong>Under the hood</strong>: Untagged variants uses a combination of JavaScript <code>typeof</code> and <code>instanceof</code> checks to discern between unboxed constructors at runtime. This means that we could add more things to the list above detailing what can be unboxed, if there are useful enough use cases.</p>
</blockquote>
<h3>Pattern matching on unboxed variants</h3>
<p>Pattern matching works the same on unboxed variants as it does on regular variants. In fact, in the perspective of ReScript's type system there's no difference between untagged and tagged variants. You can do virtually the same things with both. That's the beauty of untagged variants - they're just variants to you as a developer.</p>
<p>Here's an example of pattern matching on an unboxed nullable value that illustrates the above:</p>
<pre class="codehilite"><code class="language-rescript">module Null = {
  @unboxed type t&lt;'a&gt; = Present('a) | @as(null) Null
}

type userAge = {ageNum: Null.t&lt;int&gt;}

type rec user = {
  name: string,
  age: Null.t&lt;userAge&gt;,
  bestFriend: Null.t&lt;user&gt;,
}

let getBestFriendsAge = user =&gt;
  switch user.bestFriend {
  | Present({age: Present({ageNum: Present(ageNum)})}) =&gt; Some(ageNum)
  | _ =&gt; None
  }
</code></pre>

<p>No difference to how you'd do with a regular variant. But, the runtime representation is different to a regular variant.</p>
<blockquote>
<p>Notice how <code>@as</code> allows us to say that an untagged variant case should map to a specific underlying <em>primitive</em>. <code>Present</code> has a type variable, so it can hold any type. And since it's an unboxed type, only the payloads <code>'a</code> or <code>null</code> will be kept at runtime. That's where the magic comes from.</p>
</blockquote>
<h3>Decoding and encoding JSON idiomatically</h3>
<p>With untagged variants, we have everything we need to define a native JSON type:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type rec json =
  | @as(null) Null
  | Boolean(bool)
  | String(string)
  | Number(float)
  | Object(Js.Dict.t&lt;json&gt;)
  | Array(array&lt;json&gt;)

let myValidJsonValue = Array([String(&quot;Hi&quot;), Number(123.)])
</code></pre>

<p>Here's an example of how you could write your own JSON decoders easily using the above, leveraging pattern matching:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type rec json =
  | @as(null) Null
  | Boolean(bool)
  | String(string)
  | Number(float)
  | Object(Js.Dict.t&lt;json&gt;)
  | Array(array&lt;json&gt;)

type rec user = {
  name: string,
  age: int,
  bestFriend: option&lt;user&gt;,
}

let rec decodeUser = json =&gt;
  switch json {
  | Object(userDict) =&gt;
    switch (
      userDict-&gt;Dict.get(&quot;name&quot;),
      userDict-&gt;Dict.get(&quot;age&quot;),
      userDict-&gt;Dict.get(&quot;bestFriend&quot;),
    ) {
    | (Some(String(name)), Some(Number(age)), Some(maybeBestFriend)) =&gt;
      Some({
        name,
        age: age-&gt;Float.toInt,
        bestFriend: maybeBestFriend-&gt;decodeUser,
      })
    | _ =&gt; None
    }
  | _ =&gt; None
  }

let decodeUsers = json =&gt;
  switch json {
  | Array(array) =&gt; array-&gt;Array.map(decodeUser)-&gt;Array.keepSome
  | _ =&gt; []
  }
</code></pre>

<p>Encoding that same structure back into JSON is also easy:</p>
<pre class="codehilite"><code class="language-rescript">let rec userToJson = user =&gt; Object(
  Dict.fromArray([
    (&quot;name&quot;, String(user.name)),
    (&quot;age&quot;, Number(user.age-&gt;Int.toFloat)),
    (
      &quot;bestFriend&quot;,
      switch user.bestFriend {
      | None =&gt; Null
      | Some(friend) =&gt; userToJson(friend)
      },
    ),
  ]),
)

let usersToJson = users =&gt; Array(users-&gt;Array.map(userToJson))
</code></pre>

<p>This can be extrapolated to many more cases.</p>
<h3>Advanced: Catch-all Constructors</h3>
<p>With untagged variants comes a rather interesting capability - catch-all cases are now possible to encode directly into a variant. </p>
<p>Let's look at how it works. Imagine you're using a third party API that returns a list of available animals. You could of course model it as a regular <code>string</code>, but given that variants can be used as "typed strings", using a variant would give you much more benefit:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-rescript">type animal = Dog | Cat | Bird

type apiResponse = {
  animal: animal
}

let greetAnimal = (animal: animal) =&gt;
  switch animal {
  | Dog =&gt; &quot;Wof&quot;
  | Cat =&gt; &quot;Meow&quot;
  | Bird =&gt; &quot;Kashiiin&quot;
  }
</code></pre>

<pre class="codehilite"><code class="language-javascript">
</code></pre>

<p></CodeTab></p>
<p>This is all fine and good as long as the API returns <code>"Dog"</code>, <code>"Cat"</code> or <code>"Bird"</code> for <code>animal</code>. 
However, what if the API changes before you have a chance to deploy new code, and can now return <code>"Turtle"</code> as well? Your code would break down because the variant <code>animal</code> doesn't cover <code>"Turtle"</code>.</p>
<p>So, we'll need to go back to <code>string</code>, loosing all of the goodies of using a variant, and then do manual conversion into the <code>animal</code> variant from <code>string</code>, right?
Well, this used to be the case before, but not anymore! We can leverage untagged variants to bake in handling of unknown values into the variant itself.</p>
<p>Let's update our type definition first:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type animal = Dog | Cat | Bird | UnknownAnimal(string)
</code></pre>

<p>Notice we've added <code>@unboxed</code> and the constructor <code>UnknownAnimal(string)</code>. Remember how untagged variants work? You remove the constructors and just leave the payloads. This means that the variant above at runtime translates to this (made up) JavaScript type:</p>
<pre class="codehilite"><code>type animal = &quot;Dog&quot; | &quot;Cat&quot; | &quot;Bird&quot; | string
</code></pre>

<p>So, any string not mapping directly to one of the payloadless constructors will now map to the general <code>string</code> case.</p>
<p>As soon as we've added this, the compiler complains that we now need to handle this additional case in our pattern match as well. Let's fix that:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type animal = Dog | Cat | Bird | UnknownAnimal(string)

type apiResponse = {
  animal: animal
}

let greetAnimal = (animal: animal) =&gt;
  switch animal {
  | Dog =&gt; &quot;Wof&quot;
  | Cat =&gt; &quot;Meow&quot;
  | Bird =&gt; &quot;Kashiiin&quot;
  | UnknownAnimal(otherAnimal) =&gt;
    `I don't know how to greet animal ${otherAnimal}`
  }
</code></pre>

<pre class="codehilite"><code class="language-javascript">function greetAnimal(animal) {
  if (!(animal === &quot;Cat&quot; || animal === &quot;Dog&quot; || animal === &quot;Bird&quot;)) {
    return &quot;I don't know how to greet animal &quot; + animal;
  }
  switch (animal) {
    case &quot;Dog&quot; :
        return &quot;Wof&quot;;
    case &quot;Cat&quot; :
        return &quot;Meow&quot;;
    case &quot;Bird&quot; :
        return &quot;Kashiiin&quot;;

  }
}
</code></pre>

<p></CodeTab></p>
<p>There! Now the external API can change as much as it wants, we'll be forced to write all code that interfaces with <code>animal</code> in a safe way that handles all possible cases. All of this baked into the variant definition itself, so no need for labor intensive manual conversion.</p>
<p>This is useful in any scenario when you use something enum-style that's external and might change. Additionally, it's also useful when something external has a large number of possible values that are known, but where you only care about a subset of them. With a catch-all case you don't need to bind to all of them just because they can happen, you can safely just bind to the ones you care about and let the catch-all case handle the rest.</p>
<h2>Coercion</h2>
<p>In certain situations, variants can be coerced to other variants, or to and from primitives. Coercion is always zero cost.</p>
<h3>Coercing Variants to Other Variants</h3>
<p>You can coerce a variant to another variant if they're identical in runtime representation, and additionally if the variant you're coercing can be represented as the variant you're coercing to.</p>
<p>Here's an example using <a href="#variant-type-spreads">variant type spreads</a>:</p>
<pre class="codehilite"><code class="language-rescript">type a = One | Two | Three
type b = | ...a | Four | Five

let one: a = One
let four: b = Four

// This works because type `b` can always represent type `a` since all of type `a`'s constructors are spread into type `b` 
let oneAsTypeB = (one :&gt; b)
</code></pre>

<h3>Coercing Variants to Primitives</h3>
<p>Variants that are guaranteed to always be represented by a single primitive at runtime can be coerced to that primitive.</p>
<p>It works with strings, the default runtime representation of payloadless constructors:</p>
<pre class="codehilite"><code class="language-rescript">// Constructors without payloads are represented as `string` by default
type a = One | Two | Three

let one: a = One

// All constructors are strings at runtime, so you can safely coerce it to a string
let oneAsString = (one :&gt; string)
</code></pre>

<p>If you were to configure all of your construtors to be represented as <code>int</code> or <code>float</code>, you could coerce to those too:</p>
<pre class="codehilite"><code class="language-rescript">type asInt = | @as(1) One | @as(2) Two | @as(3) Three

let oneInt: asInt = One
let toInt = (oneInt :&gt; int)
</code></pre>

<h3>Advanced: Coercing <code>string</code> to Variant</h3>
<p>In certain situtations it's possible to coerce a <code>string</code> to a variant. This is an advanced technique that you're unlikely to need much, but when you do it's really useful.</p>
<p>You can coerce a <code>string</code> to a variant when:
- Your variant is <code>@unboxed</code>
- Your variant has a "catch-all" <code>string</code> case</p>
<p>Let's look at an example:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type myEnum = One | Two | Other(string)

// Other(&quot;Other thing&quot;)
let asMyEnum = (&quot;Other thing&quot; :&gt; myEnum)

// One
let asMyEnum = (&quot;One&quot; :&gt; myEnum)
</code></pre>

<p>This works because the variant is unboxed <strong>and</strong> has a catch-all case. So, if you throw a string at this variant that's not representable by the payloadless constructors, like <code>"One"</code> or <code>"Two"</code>, it'll <em>always</em> end up in <code>Other(string)</code>, since that case can represent any <code>string</code>.</p>
<h2>Tips &amp; Tricks</h2>
<p><strong>Be careful</strong> not to confuse a constructor carrying 2 arguments with a constructor carrying a single tuple argument:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type account =
  | Facebook(string, int) // 2 arguments
type account2 =
  | Instagram((string, int)) // 1 argument - happens to be a 2-tuple</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h3>Variants Must Have Constructors</h3>
<p>If you come from an untyped language, you might be tempted to try <code>type myType = int | string</code>. This isn't possible in ReScript; you'd have to give each branch a constructor: <code>type myType = Int(int) | String(string)</code>. The former looks nice, but causes lots of trouble down the line.</p>
<h3>Interop with JavaScript</h3>
<p><em>This section assumes knowledge about our JavaScript interop. Skip this if you haven't felt the itch to use variants for wrapping JS functions yet</em>.</p>
<p>Quite a few JS libraries use functions that can accept many types of arguments. In these cases, it's very tempting to model them as variants. For example, suppose there's a <code>myLibrary.draw</code> JS function that takes in either a <code>number</code> or a <code>string</code>. You might be tempted to bind it like so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// reserved for internal usage
@module("myLibrary") external draw : 'a =&gt; unit = "draw"</p>
<p>type animal =
  | MyFloat(float)
  | MyString(string)</p>
<p>let betterDraw = (animal) =&gt;
  switch animal {
  | MyFloat(f) =&gt; draw(f)
  | MyString(s) =&gt; draw(s)
  }</p>
<p>betterDraw(MyFloat(1.5))</p>
<pre class="codehilite"><code>```js
var MyLibrary = require(&quot;myLibrary&quot;);

function betterDraw(animal) {
  MyLibrary.draw(animal._0);
}

betterDraw({
      TAG: &quot;MyFloat&quot;,
      _0: 1.5
    });
</code></pre>

<p></CodeTab></p>
<p><strong>Try not to do that</strong>, as this generates extra noisy output. Instead, use the <code>@unboxed</code> attribute to guide ReScript to generate more efficient code:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// reserved for internal usage
@module("myLibrary") external draw : 'a =&gt; unit = "draw"</p>
<p>@unboxed
type animal =
  | MyFloat(float)
  | MyString(string)</p>
<p>let betterDraw = (animal) =&gt;
  switch animal {
  | MyFloat(f) =&gt; draw(f)
  | MyString(s) =&gt; draw(s)
  }</p>
<p>betterDraw(MyFloat(1.5))</p>
<pre class="codehilite"><code>```js
var MyLibrary = require(&quot;myLibrary&quot;);

function betterDraw(animal) {
  MyLibrary.draw(animal);
}

MyLibrary.draw(1.5);
</code></pre>

<p></CodeTab></p>
<p>Alternatively, define two <code>external</code>s that both compile to the same JS call:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("myLibrary") external drawFloat: float =&gt; unit = "draw"
@module("myLibrary") external drawString: string =&gt; unit = "draw"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>ReScript also provides <a href="bind-to-js-function.md#modeling-polymorphic-function">a few other ways</a> to do this.</p>
<h3>Variant Types Are Found By Field Name</h3>
<p>Please refer to this <a href="record#tips--tricks">record section</a>. Variants are the same: a function can't accept an arbitrary constructor shared by two different variants. Again, such feature exists; it's called a polymorphic variant. We'll talk about this in the future =).</p>
<h2>Design Decisions</h2>
<p>Variants, in their many forms (polymorphic variant, open variant, GADT, etc.), are likely <em>the</em> feature of a type system such as ReScript's. The aforementioned <code>option</code> variant, for example, obliterates the need for nullable types, a major source of bugs in other languages. Philosophically speaking, a problem is composed of many possible branches/conditions. Mishandling these conditions is the majority of what we call bugs. <strong>A type system doesn't magically eliminate bugs; it points out the unhandled conditions and asks you to cover them</strong>*. The ability to model "this or that" correctly is crucial.</p>
<p>For example, some folks wonder how the type system can safely eliminate badly formatted JSON data from propagating into their program. They don't, not by themselves! But if the parser returns the <code>option</code> type <code>None | Some(actualData)</code>, then you'd have to handle the <code>None</code> case explicitly in later call sites. That's all there is.</p>
<p>Performance-wise, a variant can potentially tremendously speed up your program's logic. Here's a piece of JavaScript:</p>
<pre class="codehilite"><code class="language-js">let data = 'dog'
if (data === 'dog') {
  ...
} else if (data === 'cat') {
  ...
} else if (data === 'bird') {
  ...
}
</code></pre>

<p>There's a linear amount of branch checking here (<code>O(n)</code>). Compare this to using a ReScript variant:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type animal = Dog | Cat | Bird
let data = Dog
switch data {
| Dog =&gt; Js.log("Wof")
| Cat =&gt; Js.log("Meow")
| Bird =&gt; Js.log("Kashiiin")
}</p>
<pre class="codehilite"><code>```js
console.log(&quot;Wof&quot;);

var data = &quot;Dog&quot;;
</code></pre>

<p></CodeTab></p>
<p>The compiler sees the variant, then</p>
<ol>
<li>conceptually turns them into <code>type animal = "Dog" | "Cat" | "Bird"</code></li>
<li>compiles <code>switch</code> to a constant-time jump table (<code>O(1)</code>).</li>
</ol><h1>build-pinned-dependencies</h1><hr />
<p>title: "Pinned Dependencies"
metaTitle: "Pinned Dependencies"
description: "Handling multiple packages within one ReScript project with pinned dependencies"
canonical: "/docs/manual/latest/build-pinned-dependencies"</p>
<hr />
<h1>Pinned Dependencies</h1>
<p>Usually we'd recommend to use ReScript in a single-codebase style by using one <code>rescript.json</code> file for your whole codebase.</p>
<p>There are scenarios where you still want to connect and build multiple independent ReScript packages for one main project though (<code>npm</code> workspaces-like "monorepos"). This is where <code>pinned-dependencies</code> come into play.</p>
<h2>Package Types</h2>
<p>Before we go into detail, let's first explain all the different package types recognized by the build system:</p>
<ul>
<li>Toplevel (this is usually the final app you are building, which has dependencies to other packages)</li>
<li>Pinned dependencies (these are your local packages that should always rebuild when you build your toplevel, those should be listed in <code>bs-dependencies</code> and <code>pinned-dependencies</code>)</li>
<li>Normal dependencies (these are packages that are consumed from npm and listed via <code>bs-dependencies</code>)</li>
</ul>
<p>Whenever a package is being built (<code>rescript build</code>), the build system will build the toplevel package with its pinned-dependencies. So any changes made in a pinned dependency will automatically be reflected in the final app.</p>
<h2>Build System Package Rules</h2>
<p>The build system respects the following rules for each package type:</p>
<p><strong>Toplevel</strong>
- Warnings reported
- Warn-error respected
- Builds dev dependencies
- Builds pinned dependencies
- Runs custom rules
- Package-specs like ES6/CommonJS overrides all its dependencies</p>
<p><strong>Pinned dependencies</strong>
- Warnings reported
- Warn-error respected
- Ignores pinned dependencies
- Builds dev dependencies
- Runs custom rules</p>
<p><strong>Normal dependencies</strong>
- Warnings, warn-error ignored
- Ignores dev directories
- Ignores pinned dependencies
- Ignores custom generator rules</p>
<p>So with that knowledge in mind, let's dive into some more concrete examples to see our pinned dependencies in action.</p>
<h2>Examples</h2>
<h3>Yarn workspaces</h3>
<p>Let's assume we have a codebase like this:</p>
<pre class="codehilite"><code>myproject/
  app/
   - src/App.res
   - rescript.json
  common/
   - src/Header.res
   - rescript.json
  myplugin/
   - src/MyPlugin.res
   - rescript.json
  package.json
</code></pre>

<p>Our <code>package.json</code> file within our codebase root would look like this:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;name&quot;: &quot;myproject&quot;,
  &quot;private&quot;: true,
  &quot;workspaces&quot;: {
    &quot;packages&quot;: [
      &quot;app&quot;,
      &quot;common&quot;,
      &quot;myplugin&quot;
    ]
  }
}
</code></pre>

<p>Our <code>app</code> folder would be our toplevel package, consuming our <code>common</code> and <code>myplugin</code> packages as <code>pinned-dependencies</code>. The configuration for <code>app/rescript.json</code> looks like this:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;name&quot;: &quot;app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;sources&quot;: {
    &quot;dir&quot; : &quot;src&quot;,
    &quot;subdirs&quot; : true
  },
  /* ... */
  &quot;bs-dependencies&quot;: [
    &quot;common&quot;,
    &quot;myplugin&quot;
  ],
  &quot;pinned-dependencies&quot;: [&quot;common&quot;, &quot;myplugin&quot;],
  /* ... */
}
</code></pre>

<p>Now, whenever we are running <code>rescript build</code> within our <code>app</code> package, the compiler would always rebuild any changes within its pinned dependencies as well.</p>
<p><strong>Important:</strong> ReScript will not rebuild any <code>pinned-dependencies</code> in watch mode! This is due to the complexity of file watching, so you'd need to set up your own file-watcher process that runs <code>rescript build</code> on specific file changes.</p><h1>attribute</h1><hr />
<p>title: "Attribute (Decorator)"
description: "Annotations in ReScript"
canonical: "/docs/manual/latest/attribute"</p>
<hr />
<h1>Attribute (Decorator)</h1>
<p>Like many other languages, ReScript allows annotating a piece of code to express extra functionality. Here's an example:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@inline
let mode = &quot;dev&quot;

let mode2 = mode
</code></pre>

<pre class="codehilite"><code class="language-js">var mode2 = &quot;dev&quot;;
</code></pre>

<p></CodeTab></p>
<p>The <code>@inline</code> annotation tells <code>mode</code>'s value to be inlined into its usage sites (see output). We call such annotation "attribute" (or "decorator" in JavaScript).</p>
<p>An attribute starts with <code>@</code> and goes before the item it annotates. In the above example, it's hooked onto the let binding.</p>
<h2>Usage</h2>
<blockquote>
<p><strong>Note:</strong> In previous versions (&lt; 8.3) all our interop related attributes started with a <code>bs.</code> prefix (<code>bs.module</code>, <code>bs.val</code>). Our formatter will automatically drop them in newer ReScript versions.</p>
</blockquote>
<p>You can put an attribute almost anywhere. You can even add extra data to them by using them visually like a function call. Here are a few famous attributes (explained in other sections):</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@@warning(&quot;-27&quot;)


@unboxed
type a = Name(string)

@val external message: string = &quot;message&quot;

type student = {
  age: int,
  @as(&quot;aria-label&quot;) ariaLabel: string,
}

@deprecated
let customDouble = foo =&gt; foo * 2

@deprecated(&quot;Use SomeOther.customTriple instead&quot;)
let customTriple = foo =&gt; foo * 3 
</code></pre>

<pre class="codehilite"><code class="language-js">
</code></pre>

<p></CodeTab></p>
<ol>
<li><code>@@warning("-27")</code> is a standalone attribute that annotates the entire file. Those attributes start with <code>@@</code>. Here, it carries the data <code>"-27"</code>. You can find a full list of all available warnings <a href="./warning-numbers">here</a>.</li>
<li><code>@unboxed</code> annotates the type definition.</li>
<li><code>@val</code> annotates the <code>external</code> statement.</li>
<li><code>@as("aria-label")</code> annotates the <code>ariaLabel</code> record field.</li>
<li><code>@deprecated</code> annotates the <code>customDouble</code> expression. This shows a warning while compiling telling consumers to not rely on this method long-term.</li>
<li><code>@deprecated("Use SomeOther.customTriple instead")</code> annotates the <code>customTriple</code> expression with a string to describe the reason for deprecation.</li>
</ol>
<p>For a list of all decorators and their usage, please refer to the <a href="/syntax-lookup">Syntax Lookup</a> page.</p>
<h2>Extension Point</h2>
<p>There's a second category of attributes, called "extension points" (a remnant term of our early systems):</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">%raw(&quot;var a = 1&quot;)
</code></pre>

<pre class="codehilite"><code class="language-js">var a = 1
</code></pre>

<p></CodeTab></p>
<p>Extension points are attributes that don't <em>annotate</em> an item; they <em>are</em> the item. Usually they serve as placeholders for the compiler to implicitly substitute them with another item.</p>
<p>Extension points start with <code>%</code>. A standalone extension point (akin to a standalone regular attribute) starts with <code>%%</code>.</p>
<p>For a list of all extension points and their usage, please refer to the <a href="/syntax-lookup">Syntax Lookup</a> page.</p><h1>generate-converters-accessors</h1><hr />
<p>title: "Generate Converters &amp; Helpers"
description: "All about the @deriving decorator, and how to generate code from types"
canonical: "/docs/manual/latest/generate-converters-accessors"</p>
<hr />
<h1>Generate Converters &amp; Helpers</h1>
<p><strong>Note</strong>: if you're looking for:
- <code>@deriving(jsConverter)</code> for records
- <code>@deriving({jsConverter: newType})</code> for records
- <code>@deriving(jsConverter)</code> for polymorphic variants</p>
<p>These particular ones are no longer needed. Select a doc version lower than <code>9.0</code> in the sidebar to see their old docs.</p>
<!-- TODO: genType -->

<p>When using ReScript, you will sometimes come into situations where you want to</p>
<ul>
<li>Automatically generate functions that convert between ReScript's internal and JS runtime values (e.g. variants).</li>
<li>Convert a record type into an abstract type with generated creation, accessor and method functions.</li>
<li>Generate some other helper functions, such as functions from record attribute names.</li>
</ul>
<p>You can use the <code>@deriving</code> decorator for different code generation scenarios. All different options and configurations will be discussed on this page.</p>
<p><strong>Note:</strong> Please be aware that extensive use of code generation might make it harder to understand your programs (since the code being generated is not visible in the source code, and you just need to know what kind of functions / values a decorator generates).</p>
<h2>Generate Functions &amp; Plain Values for Variants</h2>
<p>Use <code>@deriving(accessors)</code> on a variant type to create accessor functions for its constructors.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@deriving(accessors)
type action =
  | Click
  | Submit(string)
  | Cancel;
</code></pre>

<pre class="codehilite"><code class="language-js">function submit(param_0) {
  return /* Submit */[param_0];
}

var click = /* Click */0;

var cancel = /* Cancel */1;

exports.click  = click;
exports.submit = submit;
exports.cancel = cancel;
</code></pre>

<p></CodeTab></p>
<p>Variants constructors with payloads generate functions, payload-less constructors generate plain integers (the internal representation of variants).</p>
<p><strong>Note</strong>:
- The generated accessors are lower-cased.
- You can now use these helpers on the JavaScript side! But don't rely on their actual values please.</p>
<h3>Usage</h3>
<pre class="codehilite"><code class="language-res">let s = submit(&quot;hello&quot;); /* gives Submit(&quot;hello&quot;) */
</code></pre>

<p>This is useful:</p>
<ul>
<li>When you're passing the accessor function as a higher-order function (which plain variant constructors aren't).</li>
<li>When you'd like the JS side to use these values &amp; functions opaquely and pass you back a variant constructor (since JS has no such thing).</li>
</ul>
<p>Please note that in case you just want to <em>pipe a payload into a constructor</em>, you don't need to generate functions for that. Use the <code>-&gt;</code> syntax instead, e.g. <code>"test"-&gt;Submit</code>.</p>
<h2>Generate Field Accessors for Records</h2>
<p>Use <code>@deriving(accessors)</code> on a record type to create accessors for its record field names.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@deriving(accessors)
type pet = {name: string}

let pets = [{name: &quot;bob&quot;}, {name: &quot;bob2&quot;}]

pets
 -&gt;Array.map(name)
 -&gt;Array.joinWith(&quot;&amp;&quot;)
 -&gt;Js.log
</code></pre>

<pre class="codehilite"><code class="language-js">function name(param) {
  return param.name;
}

var pets = [
  {
    name: &quot;bob&quot;
  },
  {
    name: &quot;bob2&quot;
  }
];

console.log(Belt_Array.map(pets, name).join(&quot;&amp;&quot;));
</code></pre>

<p></CodeTab></p>
<h2>Generate Converters for JS Integer Enums and Variants</h2>
<p>Use <code>@deriving(jsConverter)</code> on a variant type to create converter functions that allow back and forth conversion between JS integer enum and ReScript variant values.</p>
<pre class="codehilite"><code class="language-res">@deriving(jsConverter)
type fruit =
  | Apple
  | Orange
  | Kiwi
  | Watermelon;
</code></pre>

<p>This option causes <code>jsConverter</code> to, again, generate functions of the following types:</p>
<pre class="codehilite"><code class="language-resi">let fruitToJs: fruit =&gt; int;

let fruitFromJs: int =&gt; option&lt;fruit&gt;;
</code></pre>

<p>For <code>fruitToJs</code>, each fruit variant constructor would map into an integer, starting at 0, in the order they're declared.</p>
<p>For <code>fruitFromJs</code>, the return value is an <code>option</code>, because not every int maps to a constructor.</p>
<p>You can also attach a <code>@as(1234)</code> to each constructor to customize their output.</p>
<h3>Usage</h3>
<pre class="codehilite"><code class="language-res">@deriving(jsConverter)
type fruit =
  | Apple
  | @as(10) Orange
  | @as(100) Kiwi
  | Watermelon

let zero = fruitToJs(Apple) /* 0 */

switch fruitFromJs(100) {
| Some(Kiwi) =&gt; Js.log(&quot;this is Kiwi&quot;)
| _ =&gt; Js.log(&quot;received something wrong from the JS side&quot;)
}
</code></pre>

<p><strong>Note</strong>: by using <code>@as</code> here, all subsequent number encoding changes. <code>Apple</code> is still <code>0</code>, <code>Orange</code> is <code>10</code>, <code>Kiwi</code> is <code>100</code> and <code>Watermelon</code> is <strong><code>101</code></strong>!</p>
<h3>More Safety</h3>
<p>Similar to the JS object \&lt;-&gt; record deriving, you can hide the fact that the JS enum are ints by using the same <code>newType</code> option with <code>@deriving(jsConverter)</code>:</p>
<pre class="codehilite"><code class="language-res">@deriving({jsConverter: newType})
type fruit =
  | Apple
  | @as(100) Kiwi
  | Watermelon;
</code></pre>

<p>This option causes <code>@deriving(jsConverter)</code> to generate functions of the following types:</p>
<pre class="codehilite"><code class="language-resi">let fruitToJs: fruit =&gt; abs_fruit;

let fruitFromJs: abs_fruit =&gt; fruit;
</code></pre>

<p>For <code>fruitFromJs</code>, the return value, unlike the previous non-abstract type case, doesn't contain an <code>option</code>, because there's no way a bad value can be passed into it; the only creator of <code>abs_fruit</code> values is <code>fruitToJs</code>!</p>
<h4>Usage</h4>
<pre class="codehilite"><code class="language-res">@deriving({jsConverter: newType})
type fruit =
  | Apple
  | @as(100) Kiwi
  | Watermelon

let opaqueValue = fruitToJs(Apple)

@module(&quot;myJSFruits&quot;) external jsKiwi: abs_fruit = &quot;iSwearThisIsAKiwi&quot;
let kiwi = fruitFromJs(jsKiwi)

let error = fruitFromJs(100) /* nope, can't take a random int */
</code></pre>

<h2>Convert Record Type to Abstract Record</h2>
<blockquote>
<p><strong>Note</strong>: For ReScript &gt;= v7, we recommend using <a href="bind-to-js-object#bind-to-record-like-js-objects">plain records to compile to JS objects</a>.
This feature might still be useful for certain scenarios, but the ergonomics might be worse</p>
</blockquote>
<p>Use <code>@deriving(abstract)</code> on a record type to expand the type into a creation, and a set of getter / setter functions for fields and methods.</p>
<p>Usually you'd just use ReScript records to compile to JS objects of the same shape. There is still one particular use-case left where the <code>@deriving(abstract)</code> convertion is still useful: Whenever you need compile a record with an optional field where the JS object attribute shouldn't show up in the resulting JS when undefined (e.g. <code>{name: "Carl", age: undefined}</code> vs <code>{name: "Carl"}</code>). Check the <a href="#optional-labels">Optional Labels</a> section for more infos on this particular scenario.</p>
<h3>Usage Example</h3>
<pre class="codehilite"><code class="language-res">@deriving(abstract)
type person = {
  name: string,
  age: int,
  job: string,
};

@val external john : person = &quot;john&quot;;
</code></pre>

<p><strong>Note</strong>: the <code>person</code> type is <strong>not</strong> a record! It's a record-looking type that uses the record's syntax and type-checking. The <code>@deriving(abstract)</code> decorator turns it into an "abstract type" (aka you don't know what the actual value's shape).</p>
<h3>Creation</h3>
<p>You don't have to bind to an existing <code>person</code> object from the JS side. You can also create such <code>person</code> JS object from ReScript's side.</p>
<p>Since <code>@deriving(abstract)</code> turns the above <code>person</code> record into an abstract type, you can't directly create a person record as you would usually. This doesn't work: <code>{name: "Joe", age: 20, job: "teacher"}</code>.</p>
<p>Instead, you'd use the <strong>creation function</strong> of the same name as the record type, implicitly generated by the <code>@deriving(abstract)</code> annotation:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let joe = person(~name=&quot;Joe&quot;, ~age=20, ~job=&quot;teacher&quot;)
</code></pre>

<pre class="codehilite"><code class="language-js">var joe = {
  name: &quot;Joe&quot;,
  age: 20,
  job: &quot;teacher&quot;
};
</code></pre>

<p></CodeTab></p>
<p>Note how in the example above there is no JS runtime overhead.</p>
<h4>Rename Fields</h4>
<p>Sometimes you might be binding to a JS object with field names that are invalid in ReScript. Two examples would be <code>{type: "foo"}</code> (reserved keyword in ReScript) and <code>{"aria-checked": true}</code>. Choose a valid field name then use <code>@as</code> to circumvent this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@deriving(abstract)
type data = {
  @as(&quot;type&quot;) type_: string,
  @as(&quot;aria-label&quot;) ariaLabel: string,
};

let d = data(~type_=&quot;message&quot;, ~ariaLabel=&quot;hello&quot;);
</code></pre>

<pre class="codehilite"><code class="language-js">var d = {
  type: &quot;message&quot;,
  &quot;aria-label&quot;: &quot;hello&quot;
};
</code></pre>

<p></CodeTab></p>
<h4>Optional Labels</h4>
<p>You can omit fields during the creation of the object:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@deriving(abstract)
type person = {
  @optional name: string,
  age: int,
  job: string,
};

let joe = person(~age=20, ~job=&quot;teacher&quot;, ());
</code></pre>

<pre class="codehilite"><code class="language-js">var joe = {
  age: 20,
  job: &quot;teacher&quot;
};
</code></pre>

<p></CodeTab></p>
<p>Optional values that are not defined, will not show up as an attribute in the resulting JS object. In the example above, you will see that <code>name</code> was omitted.</p>
<p><strong>Note</strong> that the <code>@optional</code> tag turned the <code>name</code> field optional. Merely typing <code>name</code> as <code>option&lt;string&gt;</code> wouldn't work.</p>
<p><strong>Note</strong>: now that your creation function contains optional fields, we mandate an unlabeled <code>()</code> at the end to indicate that <a href="function#optional-labeled-arguments">you've finished applying the function</a>.</p>
<h3>Accessors</h3>
<p>Again, since <code>@deriving(abstract)</code> hides the actual record shape, you can't access a field using e.g. <code>joe.age</code>. We remediate this by generating getter and setters.</p>
<h4>Read</h4>
<p>One getter function is generated per <code>@deriving(abstract)</code> record type field. In the above example, you'd get 3 functions: <code>nameGet</code>, <code>ageGet</code>, <code>jobGet</code>. They take in a <code>person</code> value and return <code>string</code>, <code>int</code>, <code>string</code> respectively:</p>
<pre class="codehilite"><code class="language-res">let twenty = ageGet(joe)
</code></pre>

<p>Alternatively, you can use the <a href="pipe">Pipe</a> operator (<code>-&gt;</code>) for a nicer-looking access syntax:</p>
<pre class="codehilite"><code class="language-res">let twenty = joe-&gt;ageGet
</code></pre>

<p>If you prefer shorter names for the getter functions, we also support a <code>light</code> setting:</p>
<pre class="codehilite"><code class="language-res">@deriving({abstract: light})
type person = {
  name: string,
  age: int,
}

let joe = person(~name=&quot;Joe&quot;, ~age=20)
let joeName = name(joe)
</code></pre>

<p>The getter functions will now have the same names as the object fields themselves.</p>
<h4>Write</h4>
<p>A <code>@deriving(abstract)</code> value is immutable by default. To mutate such value, you need to first mark one of the abstract record field as <code>mutable</code>, the same way you'd mark a normal record as mutable:</p>
<pre class="codehilite"><code class="language-res">@deriving(abstract)
type person = {
  name: string,
  mutable age: int,
  job: string,
}
</code></pre>

<p>Then, a setter of the name <code>ageSet</code> will be generated. Use it like so:</p>
<pre class="codehilite"><code class="language-res">let joe = person(~name=&quot;Joe&quot;, ~age=20, ~job=&quot;teacher&quot;);
ageSet(joe, 21);
</code></pre>

<p>Alternatively, with the Pipe First syntax:</p>
<pre class="codehilite"><code class="language-res">joe-&gt;ageSet(21)
</code></pre>

<h3>Methods</h3>
<p>You can attach arbitrary methods onto a type (<em>any</em> type, as a matter of fact. Not just <code>@deriving(abstract)</code> record types). See <a href="bind-to-js-function#object-method">Object Method</a> in the "Bind to JS Function" section for more infos.</p>
<h3>Tips &amp; Tricks</h3>
<p>You can leverage <code>@deriving(abstract)</code> for finer-grained access control.</p>
<h4>Mutability</h4>
<p>You can mark a field as mutable in the implementation (<code>.res</code>) file, while <em>hiding</em> such mutability in the interface file:</p>
<pre class="codehilite"><code class="language-res">/* test.res */
@deriving(abstract)
type cord = {
  @optional mutable x: int,
  y: int,
};
</code></pre>

<pre class="codehilite"><code class="language-resi">/* test.resi */
@deriving(abstract)
type cord = {
  @optional x: int,
  y: int,
};
</code></pre>

<p>Tada! Now you can mutate inside your own file as much as you want, and prevent others from doing so!</p>
<h4>Hide the Creation Function</h4>
<p>Mark the record as <code>private</code> to disable the creation function:</p>
<pre class="codehilite"><code class="language-res">@deriving(abstract)
type cord = private {
  @optional x: int,
  y: int,
}
</code></pre>

<p>The accessors are still there, but you can no longer create such data structure. Great for binding to a JS object while preventing others from creating more such object!</p>
<h4>Use submodules to prevent naming collisions and binding shadowing</h4>
<p>Oftentimes you will have multiple abstract types with similar attributes. Since
ReScript will expand all abstract getter, setter and creation functions in the
same scope where the type is defined, you will eventually run into value shadowing problems.</p>
<p><strong>For example:</strong></p>
<pre class="codehilite"><code class="language-res">@deriving(abstract)
type person = {name: string}

@deriving(abstract)
type cat = {
  name: string,
  isLazy: bool,
};

let person = person(~name=&quot;Alice&quot;)

/* Error: This expression has type person but an expression was expected
   of type cat */
person-&gt;nameGet()
</code></pre>

<p>To get around this issue, you can use modules to group a type with its related
functions and later use them via local open statements:</p>
<pre class="codehilite"><code class="language-res">module Person = {
  @deriving(abstract)
  type t = {name: string}
}

module Cat = {
  @deriving(abstract)
  type t = {
    name: string,
    isLazy: bool,
  }
}

let person = Person.t(~name=&quot;Alice&quot;)
let cat = Cat.t(~name=&quot;Snowball&quot;, ~isLazy=true)

/* We can use each nameGet function separately now */
let shoutPersonName = {
  open Person
  person-&gt;nameGet-&gt;Js.String.toUpperCase
}

/* Note how we use a local `open Cat` expression to
 get access to Cat's nameGet function */
let whisperCatName = {
  open Cat
  cat-&gt;nameGet-&gt;Js.String.toLowerCase
}
</code></pre>

<h2>Convert External into JS Object Creation Function</h2>
<p>Use <code>@obj</code> on an <code>external</code> binding to create a function that, when called, will evaluate to a JS object with fields corresponding to the function's parameter labels.</p>
<p>This is very handy because you can make some of those labelled parameters optional and if you don't pass them in, the output object won't include the corresponding fields. Thus you can use it to dynamically create objects with the subset of fields you need at runtime.</p>
<p>For example, suppose you need a JavaScript object like this:</p>
<pre class="codehilite"><code class="language-js">var homeRoute = {
  type: &quot;GET&quot;,
  path: &quot;/&quot;,
  action: () =&gt; console.log(&quot;Home&quot;),
  // options: ...
};
</code></pre>

<p>But only the first three fields are required; the options field is optional. You can declare the binding function like so:</p>
<pre class="codehilite"><code class="language-res">@obj
external route: (
  ~\&quot;type&quot;: string,
  ~path: string,
  ~action: list&lt;string&gt; =&gt; unit,
  ~options: {..}=?,
  unit,
) =&gt; _ = &quot;&quot;
</code></pre>

<p><strong>Note</strong>: the <code>= ""</code> part at the end is just a dummy placeholder, due to syntactic limitations. It serves no purpose currently.</p>
<p>This function has four labelled parameters (the fourth one optional), one unlabelled parameter at the end (which we mandate for functions with <a href="function#optional-labeled-arguments">optional parameters</a>, and one parameter (<code>\"type"</code>) that required quoting to <a href="use-illegal-identifier-names">avoid clashing</a> with the reserved <code>type</code> keyword.</p>
<p>Also of interest is the return type: <code>_</code>, which tells ReScript to automatically infer the full type of the JS object, sparing you the hassle of writing down the type manually!</p>
<p>The function is called like so:</p>
<pre class="codehilite"><code class="language-res">let homeRoute = route(
  ~\&quot;type&quot;=&quot;GET&quot;,
  ~path=&quot;/&quot;,
  ~action=_ =&gt; Js.log(&quot;Home&quot;),
  (),
)
</code></pre><h1>function</h1><hr />
<p>title: "Function"
description: "Function syntax in ReScript"
canonical: "/docs/manual/latest/function"</p>
<hr />
<h1>Function</h1>
<p><em>Cheat sheet for the full function syntax at the end</em>.</p>
<p>ReScript functions are declared with an arrow and return an expression, just like JS functions. They compile to clean JS functions too.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let greet = (name) =&gt; "Hello " ++ name</p>
<pre class="codehilite"><code>```js
function greet(name) {
  return &quot;Hello &quot; + name;
}
</code></pre>

<p></CodeTab></p>
<p>This declares a function and assigns to it the name <code>greet</code>, which you can call like so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
greet("world!") // "Hello world!"</p>
<pre class="codehilite"><code>```js
greet(&quot;world!&quot;);
</code></pre>

<p></CodeTab></p>
<p>Multi-arguments functions have arguments separated by comma:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let add = (x, y, z) =&gt; x + y + z
add(1, 2, 3) // 6</p>
<pre class="codehilite"><code>```js
function add(x, y, z) {
  return (x + y | 0) + z | 0;
}
</code></pre>

<p></CodeTab></p>
<p>For longer functions, you'd surround the body with a block:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let greetMore = (name) =&gt; {
  let part1 = "Hello"
  part1 ++ " " ++ name
}</p>
<pre class="codehilite"><code>```js
function greetMore(name) {
  return &quot;Hello &quot; + name;
}
</code></pre>

<p></CodeTab></p>
<p>If your function has no argument, just write <code>let greetMore = () =&gt; {...}</code>.</p>
<h2>Labeled Arguments</h2>
<p>Multi-arguments functions, especially those whose arguments are of the same type, can be confusing to call.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let addCoordinates = (x, y) =&gt; {
  // use x and y here
}
// ...
addCoordinates(5, 6) // which is x, which is y?
</code></pre>

<pre class="codehilite"><code class="language-js">function addCoordinates(x, y) {
  // use x and y here
}

addCoordinates(5, 6);
</code></pre>

<p></CodeTab></p>
<p>You can attach labels to an argument by prefixing the name with the <code>~</code> symbol:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let addCoordinates = (~x, ~y) =&gt; {
  // use x and y here
}
// ...
addCoordinates(~x=5, ~y=6)
</code></pre>

<pre class="codehilite"><code class="language-js">function addCoordinates(x, y) {
  // use x and y here
}

addCoordinates(5, 6);
</code></pre>

<p></CodeTab></p>
<p>You can provide the arguments in <strong>any order</strong>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">addCoordinates(~y=6, ~x=5)
</code></pre>

<pre class="codehilite"><code class="language-js">addCoordinates(5, 6);
</code></pre>

<p></CodeTab></p>
<p>The <code>~x</code> part in the declaration means the function accepts an argument labeled <code>x</code> and can refer to it in the function body by the same name. You can also refer to the arguments inside the function body by a different name for conciseness:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let drawCircle = (~radius as r, ~color as c) =&gt; {
  setColor(c)
  startAt(r, r)
  // ...
}

drawCircle(~radius=10, ~color=&quot;red&quot;)
</code></pre>

<pre class="codehilite"><code class="language-js">function drawCircle(r, c) {
  setColor(c);
  return startAt(r, r);
}

drawCircle(10, &quot;red&quot;);
</code></pre>

<p></CodeTab></p>
<p>As a matter of fact, <code>(~radius)</code> is just a shorthand for <code>(~radius as radius)</code>.</p>
<p>Here's the syntax for typing the arguments:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let drawCircle = (~radius as r: int, ~color as c: string) =&gt; {
  // code here
}
</code></pre>

<pre class="codehilite"><code class="language-js">function drawCircle(r, c) {
  // code here
}
</code></pre>

<p></CodeTab></p>
<h2>Optional Labeled Arguments</h2>
<p>Labeled function arguments can be made optional during declaration. You can then omit them when calling the function.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// radius can be omitted
let drawCircle = (~color, ~radius=?) =&gt; {
  setColor(color)
  switch radius {
  | None =&gt; startAt(1, 1)
  | Some(r_) =&gt; startAt(r_, r_)
  }
}
</code></pre>

<pre class="codehilite"><code class="language-js">var Caml_option = require(&quot;./stdlib/caml_option.js&quot;);

function drawCircle(color, radius) {
  setColor(color);
  if (radius === undefined) {
    return startAt(1, 1);
  }
  var r_ = Caml_option.valFromOption(radius);
  return startAt(r_, r_);
}
</code></pre>

<p></CodeTab></p>
<p>When given in this syntax, <code>radius</code> is <strong>wrapped</strong> in the standard library's <code>option</code> type, defaulting to <code>None</code>. If provided, it'll be wrapped with a <code>Some</code>. So <code>radius</code>'s type value is <code>None | Some(int)</code> here.</p>
<p>More on <code>option</code> type <a href="null-undefined-option.md">here</a>.</p>
<h3>Signatures and Type Annotations</h3>
<p>Functions with optional labeled arguments can be confusing when it comes to signature and type annotations. Indeed, the type of an optional labeled argument looks different depending on whether you're calling the function, or working inside the function body. Outside the function, a raw value is either passed in (<code>int</code>, for example), or left off entirely. Inside the function, the parameter is always there, but its value is an option (<code>option&lt;int&gt;</code>). This means that the type signature is different, depending on whether you're writing out the function type, or the parameter type annotation. The first being a raw value, and the second being an option.</p>
<p>If we get back to our previous example and both add a signature and type annotations to its argument, we get this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let drawCircle: (~color: color, ~radius: int=?) =&gt; unit =
  (~color: color, ~radius: option&lt;int&gt;=?) =&gt; {
    setColor(color)
    switch radius {
    | None =&gt; startAt(1, 1)
    | Some(r_) =&gt; startAt(r_, r_)
    }
  }
</code></pre>

<pre class="codehilite"><code class="language-js">function drawCircle(color, radius) {
  setColor(color);
  if (radius !== undefined) {
    return startAt(radius, radius);
  } else {
    return startAt(1, 1);
  }
}
</code></pre>

<p></CodeTab></p>
<p>The first line is the function's signature, we would define it like that in an interface file (see <a href="module.md#signatures">Signatures</a>). The function's signature describes the types that the <strong>outside world</strong> interacts with, hence the type <code>int</code> for <code>radius</code> because it indeed expects an <code>int</code> when called.</p>
<p>In the second line, we annotate the arguments to help us remember the types of the arguments when we use them <strong>inside</strong> the function's body, here indeed <code>radius</code> will be an <code>option&lt;int&gt;</code> inside the function.</p>
<p>So if you happen to struggle when writing the signature of a function with optional labeled arguments, try to remember this!</p>
<h3>Explicitly Passed Optional</h3>
<p>Sometimes, you might want to forward a value to a function without knowing whether the value is <code>None</code> or <code>Some(a)</code>. Naively, you'd do:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let result =
  switch payloadRadius {
  | None =&gt; drawCircle(~color)
  | Some(r) =&gt; drawCircle(~color, ~radius=r)
  }
</code></pre>

<pre class="codehilite"><code class="language-js">var r = payloadRadius;

var result = r !== undefined
  ? drawCircle(color, Caml_option.valFromOption(r))
  : drawCircle(color);
</code></pre>

<p></CodeTab></p>
<p>This quickly gets tedious. We provide a shortcut:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let result = drawCircle(~color, ~radius=?payloadRadius)
</code></pre>

<pre class="codehilite"><code class="language-js">var result = drawCircle(1, undefined);
</code></pre>

<p></CodeTab></p>
<p>This means "I understand <code>radius</code> is optional, and that when I pass it a value it needs to be an <code>int</code>, but I don't know whether the value I'm passing is <code>None</code> or <code>Some(val)</code>, so I'll pass you the whole <code>option</code> wrapper".</p>
<h3>Optional with Default Value</h3>
<p>Optional labeled arguments can also be provided a default value. In this case, they aren't wrapped in an <code>option</code> type.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let drawCircle = (~radius=1, ~color) =&gt; {
  setColor(color)
  startAt(radius, radius)
}
</code></pre>

<pre class="codehilite"><code class="language-js">function drawCircle(radiusOpt, color) {
  var radius = radiusOpt !== undefined ? radiusOpt : 1;
  setColor(color);
  return startAt(radius, radius);
}
</code></pre>

<p></CodeTab></p>
<h2>Recursive Functions</h2>
<p>ReScript chooses the sane default of preventing a function to be called recursively within itself. To make a function recursive, add the <code>rec</code> keyword after the <code>let</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let rec neverTerminate = () =&gt; neverTerminate()</p>
<pre class="codehilite"><code>```js
function neverTerminate(_param) {
  while(true) {
    _param = undefined;
    continue ;
  };
}
</code></pre>

<p></CodeTab></p>
<p>A simple recursive function may look like this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res example
// Recursively check every item on the list until one equals the</code>item<code>// argument. If a match is found, return</code>true<code>, otherwise return</code>false`
let rec listHas = (list, item) =&gt;
  switch list {
  | list{} =&gt; false
  | list{a, ...rest} =&gt; a === item || listHas(rest, item)
  }</p>
<pre class="codehilite"><code>```js
function listHas(_list, item) {
  while(true) {
    var list = _list;
    if (!list) {
      return false;
    }
    if (list.hd === item) {
      return true;
    }
    _list = list.tl;
    continue ;
  };
}
</code></pre>

<p></CodeTab></p>
<p>Recursively calling a function is bad for performance and the call stack. However, ReScript intelligently compiles <a href="https://stackoverflow.com/questions/33923/what-is-tail-recursion">tail recursion</a> into a fast JavaScript loop. Try checking the JS output of the above code!</p>
<h3>Mutually Recursive Functions</h3>
<p>Mutually recursive functions start like a single recursive function using the
<code>rec</code> keyword, and then are chained together with <code>and</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let rec callSecond = () =&gt; callFirst()
and callFirst = () =&gt; callSecond()</p>
<pre class="codehilite"><code>```js
function callSecond(_param) {
  while(true) {
    _param = undefined;
    continue ;
  };
}

function callFirst(_param) {
  while(true) {
    _param = undefined;
    continue ;
  };
}
</code></pre>

<p></CodeTab></p>
<h2>Partial Application</h2>
<p><strong>Since 11.0</strong></p>
<p>To partially apply a function, use the explicit <code>...</code> syntax. </p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let add = (a, b) =&gt; a + b
let addFive = add(5, ...)
</code></pre>

<pre class="codehilite"><code class="language-js">function add(a, b) {
  return a + b | 0;
}

function addFive(extra) {
  return 5 + extra | 0;
}
</code></pre>

<p></CodeTab></p>
<h2>Async/Await</h2>
<p>Just as in JS, an async function can be declared by adding <code>async</code> before the definition, and <code>await</code> can be used in the body of such functions.
The output looks like idiomatic JS:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let getUserName = async (userId) =&gt; userId</p>
<p>let greetUser = async (userId) =&gt; {
  let name = await getUserName(userId)<br />
  "Hello " ++ name ++ "!"
}</p>
<pre class="codehilite"><code>```js
async function greetUser(userId) {
  var name = await getUserName(userId);
  return &quot;Hello &quot; + name + &quot;!&quot;;
}
</code></pre>

<p></CodeTab></p>
<p>The return type of <code>getUser</code> is inferred to be <code>promise&lt;string&gt;</code>.
Similarly, <code>await getUserName(userId)</code> returns a <code>string</code> when the function returns <code>promise&lt;string&gt;</code>.
Using <code>await</code> outside of an <code>async</code> function (including in a non-async callback to an async function) is an error.</p>
<h3>Ergonomic error handling</h3>
<p>Error handling is done by simply using <code>try</code>/<code>catch</code>, or a switch with an <code>exception</code> case, just as in functions that are not async.
Both JS exceptions and exceptions defined in ReScript can be caught. The compiler takes care of packaging JS exceptions into the builtin <code>JsError</code> exception:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
exception SomeReScriptException</p>
<p>let somethingThatMightThrow = async () =&gt; raise(SomeReScriptException)</p>
<p>let someAsyncFn = async () =&gt; {
  switch await somethingThatMightThrow() {
  | data =&gt; Some(data)
  | exception JsError(_) =&gt; None
  | exception SomeReScriptException =&gt; None
  }
}</p>
<pre class="codehilite"><code>```js
var SomeReScriptException = /* @__PURE__ */Caml_exceptions.create(&quot;Example.SomeReScriptException&quot;);

async function someAsyncFn(param) {
  var data;
  try {
    data = await somethingThatMightThrow(undefined);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === &quot;JsError&quot;) {
      return ;
    }
    if (exn.RE_EXN_ID === SomeReScriptException) {
      return ;
    }
    throw exn;
  }
  return data;
}
</code></pre>

<p></CodeTab></p>
<h2>The ignore() Function</h2>
<p>Occasionally you may want to ignore the return value of a function. ReScript provides an <code>ignore()</code> function that discards the value of its argument and returns <code>()</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">mySideEffect()-&gt;Promise.catch(handleError)-&gt;ignore

Js.Global.setTimeout(myFunc, 1000)-&gt;ignore
</code></pre>

<pre class="codehilite"><code class="language-js">$$Promise.$$catch(mySideEffect(), function (prim) {
  return handleError(prim);
});

setTimeout(function (prim) {
  myFunc();
}, 1000);
</code></pre>

<p></CodeTab></p>
<h2>Tips &amp; Tricks</h2>
<p>Cheat sheet for the function syntaxes:</p>
<h3>Declaration</h3>
<pre class="codehilite"><code class="language-res">// anonymous function
(x, y) =&gt; 1
// bind to a name
let add = (x, y) =&gt; 1

// labeled
let add = (~first as x, ~second as y) =&gt; x + y
// with punning sugar
let add = (~first, ~second) =&gt; first + second

// labeled with default value
let add = (~first as x=1, ~second as y=2) =&gt; x + y
// with punning
let add = (~first=1, ~second=2) =&gt; first + second

// optional
let add = (~first as x=?, ~second as y=?) =&gt; switch x {...}
// with punning
let add = (~first=?, ~second=?) =&gt; switch first {...}
</code></pre>

<h4>With Type Annotation</h4>
<pre class="codehilite"><code class="language-res">// anonymous function
(x: int, y: int): int =&gt; 1
// bind to a name
let add = (x: int, y: int): int =&gt; 1

// labeled
let add = (~first as x: int, ~second as y: int) : int =&gt; x + y
// with punning sugar
let add = (~first: int, ~second: int) : int =&gt; first + second

// labeled with default value
let add = (~first as x: int=1, ~second as y: int=2) : int =&gt; x + y
// with punning sugar
let add = (~first: int=1, ~second: int=2) : int =&gt; first + second

// optional
let add = (~first as x: option&lt;int&gt;=?, ~second as y: option&lt;int&gt;=?) : int =&gt; switch x {...}
// with punning sugar
// note that the caller would pass an `int`, not `option&lt;int&gt;`
// Inside the function, `first` and `second` are `option&lt;int&gt;`.
let add = (~first: option&lt;int&gt;=?, ~second: option&lt;int&gt;=?) : int =&gt; switch first {...}
</code></pre>

<h3>Application</h3>
<pre class="codehilite"><code class="language-res">add(x, y)

// labeled
add(~first=1, ~second=2)
// with punning sugar
add(~first, ~second)

// application with default value. Same as normal application
add(~first=1, ~second=2)

// explicit optional application
add(~first=?Some(1), ~second=?Some(2))
// with punning
add(~first?, ~second?)
</code></pre>

<h4>With Type Annotation</h4>
<pre class="codehilite"><code class="language-res">// labeled
add(~first=1: int, ~second=2: int)
// with punning sugar
add(~first: int, ~second: int)

// application with default value. Same as normal application
add(~first=1: int, ~second=2: int)

// explicit optional application
add(~first=?Some(1): option&lt;int&gt;, ~second=?Some(2): option&lt;int&gt;)
// no punning sugar when you want to type annotate
</code></pre>

<h3>Standalone Type Signature</h3>
<pre class="codehilite"><code class="language-res">// first arg type, second arg type, return type
type add = (int, int) =&gt; int

// labeled
type add = (~first: int, ~second: int) =&gt; int

// labeled
type add = (~first: int=?, ~second: int=?, unit) =&gt; int
</code></pre>

<h4>In Interface Files</h4>
<p>To annotate a function from the implementation file (<code>.res</code>) in your interface file (<code>.resi</code>):</p>
<p><code>res sig
let add: (int, int) =&gt; int</code></p>
<p>The type annotation part is the same as the previous section on With Type Annotation.</p>
<p><strong>Don't</strong> confuse <code>let add: myType</code> with <code>type add = myType</code>. When used in <code>.resi</code> interface files, the former exports the binding <code>add</code> while annotating it as type <code>myType</code>. The latter exports the type <code>add</code>, whose value is the type <code>myType</code>.</p><h1>converting-from-js</h1><hr />
<p>title: "Converting from JS"
description: "How to convert to ReScript with an existing JS codebase"
canonical: "/docs/manual/latest/converting-from-js"</p>
<hr />
<h1>Converting from JS</h1>
<p>ReScript offers a unique project conversion methodology which:
- Ensures minimal disruption to your teammates (very important!).
- Remove the typical friction of verifying conversion's correctness and performance guarantees.
- Doesn't force you to search for pre-made binding libraries made by others. <strong>ReScript doesn't need the equivalent of TypeScript's <code>DefinitelyTyped</code></strong>.</p>
<h2>Step 1: Install ReScript</h2>
<p>Run <code>npm install rescript</code> on your project, then imitate our <a href="installation#new-project">New Project</a> workflow by adding a <code>rescript.json</code> at the root. Then start <code>npx rescript build -w</code>.</p>
<h2>Step 2: Copy Paste the Entire JS File</h2>
<p>Let's work on converting a file called <code>src/main.js</code>.</p>
<pre class="codehilite"><code class="language-js">const school = require('school');

const defaultId = 10;

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}
</code></pre>

<p>First, copy the entire file content over to a new file called <code>src/Main.res</code> by using our <a href="embed-raw-javascript"><code>%%raw</code> JS embedding trick</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res example
%%raw(</code>
const school = require('school');</p>
<p>const defaultId = 10;</p>
<p>function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}
`)</p>
<pre class="codehilite"><code>```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

const school = require('school');

const defaultId = 10;

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}

/*  Not a pure module */
</code></pre>

<p></CodeTab></p>
<p>Add this file to <code>rescript.json</code>:</p>
<pre class="codehilite"><code class="language-json">  &quot;sources&quot;: {
    &quot;dir&quot; : &quot;src&quot;,
    &quot;subdirs&quot; : true
  },
</code></pre>

<p>Open an editor tab for <code>src/Main.bs.js</code>. Do a command-line <code>diff -u src/main.js src/Main.bs.js</code>. Aside from whitespaces, you should see only minimal, trivial differences. You're already a third of the way done!</p>
<p><strong>Always make sure</strong> that at each step, you keep the ReScript output <code>.bs.js</code> file open to compare against the existing JavaScript file. Our compilation output is very close to your hand-written JavaScript; you can simply eye the difference to catch conversion bugs!</p>
<h2>Step 3: Extract Parts into Idiomatic ReScript</h2>
<p>Let's turn the <code>defaultId</code> variable into a ReScript let-binding:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let defaultId = 10</p>
<p>%%raw(`
const school = require('school');</p>
<p>function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}
`)</p>
<pre class="codehilite"><code>```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

const school = require('school');

function queryResult(usePayload, payload) {
  if usePayload {
    return payload.student
  } else {
    return school.getStudentById(defaultId)
  }
}

var defaultId = 10;

exports.defaultId = defaultId;
/*  Not a pure module */
</code></pre>

<p></CodeTab></p>
<p>Check the output. Diff it. Code still works. Moving on! Extract the function:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">%%raw(`
const school = require('school');
`)

let defaultId = 10

let queryResult = (usePayload, payload) =&gt; {
  if usePayload {
    payload.student
  } else {
    school.getStudentById(defaultId)
  }
}
</code></pre>

<pre class="codehilite"><code class="language-js">
</code></pre>

<p></CodeTab></p>
<p>Format the code: <code>./node_modules/.bin/rescript format src/Main.res</code>.</p>
<p>We have a type error: "The record field student can't be found". That's fine! <strong>Always ensure your code is syntactically valid first</strong>. Fixing type errors comes later.</p>
<h2>Step 4: Add <code>external</code>s, Fix Types</h2>
<p>The previous type error is caused by <code>payload</code>'s record declaration (which supposedly contains the field <code>student</code>) not being found. Since we're trying to convert as quickly as possible, let's use our <a href="object">object</a> feature to avoid needing type declaration ceremonies:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">%%raw(`
const school = require('school');
`)

let defaultId = 10

let queryResult = (usePayload, payload) =&gt; {
  if usePayload {
    payload[&quot;student&quot;]
  } else {
    school[&quot;getStudentById&quot;](. defaultId)
  }
}
</code></pre>

<pre class="codehilite"><code class="language-js">
</code></pre>

<p></CodeTab></p>
<p>Now this triggers the next type error, that <code>school</code> isn't found. Let's use <a href="external"><code>external</code></a> to bind to that module:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module external school: 'whatever = "school"</p>
<p>let defaultId = 10</p>
<p>let queryResult = (usePayload, payload) =&gt; {
  if usePayload {
    payload["student"]
  } else {
    school<a href=". defaultId">"getStudentById"</a>
  }
}</p>
<pre class="codehilite"><code>```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var School = require(&quot;school&quot;);

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return School.getStudentById(10);
  }
}

var defaultId = 10;

exports.defaultId = defaultId;
exports.queryResult = queryResult;
/* school Not a pure module */
</code></pre>

<p></CodeTab></p>
<p>We hurrily typed <code>school</code> as a polymorphic <code>'whatever</code> and let its type be inferred by its usage below. The inference is technically correct, but within the context of bringing it a value from JavaScript, slightly dangerous. This is just the interop trick we've shown in the <a href="external"><code>external</code></a> page.</p>
<p>Anyway, the file passes the type checker again. Check the <code>.bs.js</code> output, diff with the original <code>.js</code>; we've now converted a file over to ReScript!</p>
<p>Now, you can delete the original, hand-written <code>main.js</code> file, and grep the files importing <code>main.js</code> and change them to importing <code>Main.bs.js</code>.</p>
<h2>(Optional) Step 5: Cleanup</h2>
<p>If you prefer more advanced, rigidly typed <code>payload</code> and <code>school</code>, feel free to do so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type school
type student
type payload = {
  student: student
}</p>
<p>@module external school: school = "school"
@send external getStudentById: (school, int) =&gt; student = "getStudentById"</p>
<p>let defaultId = 10</p>
<p>let queryResult = (usePayload, payload) =&gt; {
  if usePayload {
    payload.student
  } else {
    school-&gt;getStudentById(defaultId)
  }
}</p>
<pre class="codehilite"><code>```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var School = require(&quot;school&quot;);

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return School.getStudentById(10);
  }
}

var defaultId = 10;

exports.defaultId = defaultId;
exports.queryResult = queryResult;
/* school Not a pure module */
</code></pre>

<p></CodeTab></p>
<p>We've:
- introduced an opaque types for <code>school</code> and <code>student</code> to prevent misusages their values
- typed the payload as a record with only the <code>student</code> field
- typed <code>getStudentById</code> as the sole method of <code>student</code></p>
<p>Check that the <code>.bs.js</code> output didn't change. How rigidly to type your JavaScript code is up to you; we recommend not typing them too elaborately; it's sometime an endless chase, and produces diminishing returns, especially considering that the elaborate-ness might turn off your potential teammates.</p>
<h2>Tips &amp; Tricks</h2>
<p>In the same vein of idea, <strong>resist the urge to write your own wrapper functions for the JS code you're converting</strong>. Use <a href="external"><code>external</code>s</a>, which are guaranteed to be erased in the output. And avoid trying to take the occasion to convert JS data structures into ReScript-specific data structures like variant or list. <strong>This isn't the time for that</strong>.</p>
<p>The moment you produce extra conversion code in the output, your skeptical teammate's mental model might switch from "I recognize this output" to "this conversion might be introducing more problems than it solves. Why are we testing ReScript again?". Then you've lost.</p>
<h2>Conclusion</h2>
<ul>
<li>Paste the JS code into a new ReScript file as embedded raw JS code.</li>
<li>Compile and keep the output file open. Check and diff against original JS file. Free regression tests.</li>
<li>Always make sure your file is syntactically valid. Don't worry about fixing types before that.</li>
<li>(Ab)use <a href="object.md">object</a> accesses to quickly convert things over.</li>
<li>Optionally clean up the types for robustness.</li>
<li>Don't go overboard and turn off your boss and fellow teammates.</li>
<li>Proudly display that you've conserved the semantics and performance characteristics during the conversion by showing your teammates the eerily familiar output.</li>
<li>Get promoted for introducing a new technology the safer, mature way.</li>
</ul><h1>pattern-matching-destructuring</h1><hr />
<p>title: "Pattern Matching / Destructuring"
description: "Pattern matching and destructuring complex data structures in ReScript"
canonical: "/docs/manual/latest/pattern-matching-destructuring"</p>
<hr />
<h1>Pattern Matching / Destructuring</h1>
<p>One of ReScript's <strong>best</strong> feature is our pattern matching. Pattern matching combines 3 brilliant features into one:</p>
<ul>
<li>Destructuring.</li>
<li><code>switch</code> based on shape of data.</li>
<li>Exhaustiveness check.</li>
</ul>
<p>We'll dive into each aspect below.</p>
<h2>Destructuring</h2>
<p>Even JavaScript has destructuring, which is "opening up" a data structure to extract the parts we want and assign variable names to them:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let coordinates = (10, 20, 30)
let (x, <em>, </em>) = coordinates
Js.log(x) // 10</p>
<pre class="codehilite"><code>```js
var coordinates = [10, 20, 30];
var x = 10;
console.log(10);
</code></pre>

<p></CodeTab></p>
<p>Destructuring works with most built-in data structures:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Record
type student = {name: string, age: int}
let student1 = {name: &quot;John&quot;, age: 10}
let {name} = student1 // &quot;John&quot; assigned to `name`

// Variant
type result =
  | Success(string)
let myResult = Success(&quot;You did it!&quot;)
let Success(message) = myResult // &quot;You did it!&quot; assigned to `message`
</code></pre>

<pre class="codehilite"><code class="language-js">var student1 = {
  name: &quot;John&quot;,
  age: 10
};
var name = &quot;John&quot;;

var myResult = /* Success */{
  _0: &quot;You did it!&quot;
};
var message = &quot;You did it!&quot;

var myArray = [1, 2, 3];
if (myArray.length !== 2) {
  throw {
    RE_EXN_ID: &quot;Match_failure&quot;,
    _1: [
      &quot;playground.res&quot;,
      14,
      4
    ],
    Error: new Error()
  };
}
var item1 = myArray[0];
var item2 = myArray[1];

var myList = {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: /* [] */0
    }
  }
};
// ...
</code></pre>

<p></CodeTab></p>
<p>You can also use destructuring anywhere you'd usually put a binding:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type result =
  | Success(string)
let displayMessage = (Success(m)) =&gt; {
  // we've directly extracted the success message
  // string by destructuring the parameter
  Js.log(m)
}
displayMessage(Success("You did it!"))</p>
<pre class="codehilite"><code>```js
function displayMessage(m) {
  console.log(m._0);
}

displayMessage(/* Success */{
  _0: &quot;You did it!&quot;
});
</code></pre>

<p></CodeTab></p>
<p>For a record, you can rename the field while destructuring:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let {name: n} = student1 // &quot;John&quot; assigned to `n`
</code></pre>

<pre class="codehilite"><code class="language-js">var n = &quot;John&quot;;
</code></pre>

<p></CodeTab></p>
<p>You <em>can</em> in theory destructure array and list at the top level too:</p>
<pre class="codehilite"><code class="language-res">let myArray = [1, 2, 3]
let [item1, item2, _] = myArray
// 1 assigned to `item1`, 2 assigned to `item2`, 3rd item ignored

let myList = list{1, 2, 3}
let list{head, ...tail} = myList
// 1 assigned to `head`, `list{2, 3}` assigned to tail
</code></pre>

<p>But the array example is <strong>highly disrecommended</strong> (use tuple instead) and the list example will error on you. They're only there for completeness' sake. As you'll see below, the proper way of using destructuring array and list is using <code>switch</code>.</p>
<h2><code>switch</code> Based on Shape of Data</h2>
<p>While the destructuring aspect of pattern matching is nice, it doesn't really change the way you think about structuring your code. One paradigm-changing way of thinking about your code is to execute some code based on the shape of the data.</p>
<p>Consider a variant:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
type payload =
  | BadResult(int)
  | GoodResult(string)
  | NoResult</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>We'd like to handle each of the 3 cases differently. For example, print a success message if the value is <code>GoodResult(...)</code>, do something else when the value is <code>NoResult</code>, etc.</p>
<p>In other languages, you'd end up with a series of if-elses that are hard to read and error-prone. In ReScript, you can instead use the supercharged <code>switch</code> pattern matching facility to destructure the value while calling the right code based on what you destructured:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let data = GoodResult("Product shipped!")
switch data {
| GoodResult(theMessage) =&gt;
  Js.log("Success! " ++ theMessage)
| BadResult(errorCode) =&gt;
  Js.log("Something's wrong. The error code is: " ++ Js.Int.toString(errorCode))
| NoResult =&gt;
  Js.log("Bah.")
}</p>
<pre class="codehilite"><code>```js
var data = {
  TAG: /* GoodResult */1,
  _0: &quot;Product shipped!&quot;
};

if (typeof data === &quot;number&quot;) {
  console.log(&quot;Bah.&quot;);
} else if (data.TAG === /* BadResult */ 0) {
  console.log(&quot;Something's wrong. The error code is: &quot; + &quot;Product shipped!&quot;.toString());
} else {
  console.log(&quot;Success! Product shipped!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>In this case, <code>message</code> will have the value <code>"Success! Product shipped!"</code>.</p>
<p>Suddenly, your if-elses that messily checks some structure of the value got turned into a clean, compiler-verified, linear list of code to execute based on exactly the shape of the value.</p>
<h3>Complex Examples</h3>
<p>Here's a real-world scenario that'd be a headache to code in other languages. Given this data structure:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
type status = Vacations(int) | Sabbatical(int) | Sick | Present
type reportCard = {passing: bool, gpa: float}
type student = {name: string, status: status, reportCard: reportCard}
type person =
  | Teacher({name: string, age: int})
  | Student(student)</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>Imagine this requirement:</p>
<ul>
<li>Informally greet a person who's a teacher and if his name is Mary or Joe.</li>
<li>Greet other teachers formally.</li>
<li>If the person's a student, congratulate him/her score if they passed the semester.</li>
<li>If the student has a gpa of 0 and is on vacations or sabbatical, display a different message.</li>
<li>A catch-all message for a student.</li>
</ul>
<p>ReScript can do this easily!</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let person1 = Teacher({name: "Jane", age: 35})</p>
<p>let message = switch person1 {
| Teacher({name: "Mary" | "Joe"}) =&gt;
  <code>Hey, still going to the party on Saturday?</code>
| Teacher({name}) =&gt;
  // this is matched only if <code>name</code> isn't "Mary" or "Joe"
  <code>Hello ${name}.</code>
| Student({name, reportCard: {passing: true, gpa}}) =&gt;
  <code>Congrats ${name}, nice GPA of ${Js.Float.toString(gpa)} you got there!</code>
| Student({
    reportCard: {gpa: 0.0},
    status: Vacations(daysLeft) | Sabbatical(daysLeft)
  }) =&gt;
  <code>Come back in ${Js.Int.toString(daysLeft)} days!</code>
| Student({status: Sick}) =&gt;
  <code>How are you feeling?</code>
| Student({name}) =&gt;
  <code>Good luck next semester ${name}!</code>
}</p>
<pre class="codehilite"><code>```js
var person1 = {
  TAG: /* Teacher */0,
  name: &quot;Jane&quot;,
  age: 35
};

var message;

if (person1.TAG) {
  var match$1 = person1.status;
  var name = person1.name;
  var match$2 = person1.reportCard;
  message = match$2.passing
    ? &quot;Congrats &quot; +
      name +
      &quot;, nice GPA of &quot; +
      match$2.gpa.toString() +
      &quot; you got there!&quot;
    : typeof match$1 === &quot;number&quot;
    ? match$1 !== 0
      ? &quot;Good luck next semester &quot; + name + &quot;!&quot;
      : &quot;How are you feeling?&quot;
    : person1.reportCard.gpa !== 0.0
    ? &quot;Good luck next semester &quot; + name + &quot;!&quot;
    : &quot;Come back in &quot; + match$1._0.toString() + &quot; days!&quot;;
} else {
  var name$1 = person1.name;
  switch (name$1) {
    case &quot;Joe&quot;:
    case &quot;Mary&quot;:
      message = &quot;Hey, still going to the party on Saturday?&quot;;
      break;
    default:
      message = &quot;Hello &quot; + name$1 + &quot;.&quot;;
  }
}
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong> how we've:
- drilled deep down into the value concisely
- using a <strong>nested pattern check</strong> <code>"Mary" | "Joe"</code> and <code>Vacations | Sabbatical</code>
- while extracting the <code>daysLeft</code> number from the latter case
- and assigned the greeting to the binding <code>message</code>.</p>
<p>Here's another example of pattern matching, this time on an inline tuple.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type animal = Dog | Cat | Bird
let categoryId = switch (isBig, myAnimal) {
| (true, Dog) =&gt; 1
| (true, Cat) =&gt; 2
| (true, Bird) =&gt; 3
| (false, Dog | Cat) =&gt; 4
| (false, Bird) =&gt; 5
}
</code></pre>

<pre class="codehilite"><code class="language-js">var categoryId = isBig ? (myAnimal + 1) | 0 : myAnimal &gt;= 2 ? 5 : 4;
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong> how pattern matching on a tuple is equivalent to a 2D table:</p>
<table>
<thead>
<tr>
<th>isBig \ myAnimal</th>
<th>Dog</th>
<th>Cat</th>
<th>Bird</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>false</td>
<td>4</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<h3>Fall-Through Patterns</h3>
<p>The nested pattern check, demonstrated in the earlier <code>person</code> example, also works at the top level of a <code>switch</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let myStatus = Vacations(10)</p>
<p>switch myStatus {
| Vacations(days)
| Sabbatical(days) =&gt; Js.log(<code>Come back in ${Js.Int.toString(days)} days!</code>)
| Sick
| Present =&gt; Js.log("Hey! How are you?")
}</p>
<pre class="codehilite"><code>```js
var myStatus = {
  TAG: /* Vacations */0,
  _0: 10
};

if (typeof myStatus === &quot;number&quot;) {
  console.log(&quot;Hey! How are you?&quot;);
} else {
  console.log(&quot;Come back in &quot; + (10).toString() + &quot; days!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>Having multiple cases fall into the same handling can clean up certain types of logic.</p>
<h3>Ignore Part of a Value</h3>
<p>If you have a value like <code>Teacher(payload)</code> where you just want to pattern match on the <code>Teacher</code> part and ignore the <code>payload</code> completely, you can use the <code>_</code> wildcard like this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch person1 {
| Teacher(<em>) =&gt; Js.log("Hi teacher")
| Student(</em>) =&gt; Js.log("Hey student")
}</p>
<pre class="codehilite"><code>```js
if (person1.TAG) {
  console.log(&quot;Hey student&quot;);
} else {
  console.log(&quot;Hi teacher&quot;);
}
</code></pre>

<p></CodeTab></p>
<p><code>_</code> also works at the top level of the <code>switch</code>, serving as a catch-all condition:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch myStatus {
| Vacations(_) =&gt; Js.log("Have fun!")
| _ =&gt; Js.log("Ok.")
}</p>
<pre class="codehilite"><code>```js
if (typeof myStatus === &quot;number&quot; || myStatus.TAG) {
  console.log(&quot;Ok.&quot;);
} else {
  console.log(&quot;Have fun!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p><strong>Do not</strong> abuse a top-level catch-all condition. Instead, prefer writing out all the cases:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch myStatus {
| Vacations(<em>) =&gt; Js.log("Have fun!")
| Sabbatical(</em>) | Sick | Present =&gt; Js.log("Ok.")
}</p>
<pre class="codehilite"><code>```js
if (typeof myStatus === &quot;number&quot; || myStatus.TAG) {
  console.log(&quot;Ok.&quot;);
} else {
  console.log(&quot;Have fun!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>Slightly more verbose, but a one-time writing effort. This helps when you add a new variant case e.g. <code>Quarantined</code> to the <code>status</code> type and need to update the places that pattern match on it. A top-level wildcard here would have accidentally and silently continued working, potentially causing bugs.</p>
<h3>If Clause</h3>
<p>Sometime, you want to check more than the shape of a value. You want to also run some arbitrary check on it. You might be tempted to write this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch person1 {
| Teacher(_) =&gt; () // do nothing
| Student({reportCard: {gpa}}) =&gt;
  if gpa &lt; 0.5 {
    Js.log("What's happening")
  } else {
    Js.log("Heyo")
  }
}</p>
<pre class="codehilite"><code>```js
if (person1.TAG) {
  if (person1.reportCard.gpa &lt; 0.5) {
    console.log(&quot;What's happening&quot;);
  } else {
    console.log(&quot;Heyo&quot;);
  }
}
</code></pre>

<p></CodeTab></p>
<p><code>switch</code> patterns support a shortcut for the arbitrary <code>if</code> check, to keep your pattern linear-looking:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch person1 {
| Teacher(<em>) =&gt; () // do nothing
| Student({reportCard: {gpa}}) if gpa &lt; 0.5 =&gt;
  Js.log("What's happening")
| Student(</em>) =&gt;
  // fall-through, catch-all case
  Js.log("Heyo")
}</p>
<pre class="codehilite"><code>```js
if (person1.TAG) {
  if (person1.reportCard.gpa &lt; 0.5) {
    console.log(&quot;What's happening&quot;);
  } else {
    console.log(&quot;Heyo&quot;);
  }
}
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> Rescript versions &lt; 9.0 had a <code>when</code> clause, not an <code>if</code> clause.  Rescript 9.0 changed <code>when</code> to <code>if</code>.  (<code>when</code> may still work, but is deprecated.)</p>
<h3>Match on Exceptions</h3>
<p>If the function throws an exception (covered later), you can also match on <em>that</em>, in addition to the function's normally returned values.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">switch List.find(i =&gt; i === theItem, myItems) {
| item =&gt; Js.log(item)
| exception Not_found =&gt; Js.log(&quot;No such item found!&quot;)
}
</code></pre>

<pre class="codehilite"><code class="language-js">var exit = 0;

var item;

try {
  item = List.find(function(i) {
    return i === theItem;
  }, myItems);
  exit = 1;
}
catch (raw_exn){
  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.RE_EXN_ID === &quot;Not_found&quot;) {
    console.log(&quot;No such item found!&quot;);
  } else {
    throw exn;
  }
}

if (exit === 1) {
  console.log(item);
}
</code></pre>

<p></CodeTab></p>
<h3>Match on Array</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let students = ["Jane", "Harvey", "Patrick"]
switch students {
| [] =&gt; Js.log("There are no students")
| [student1] =&gt;
  Js.log("There's a single student here: " ++ student1)
| manyStudents =&gt;
  // display the array of names
  Js.log2("The students are: ", manyStudents)
}</p>
<pre class="codehilite"><code>```js
var students = [&quot;Jane&quot;, &quot;Harvey&quot;, &quot;Patrick&quot;];

var len = students.length;

if (len !== 1) {
  if (len !== 0) {
    console.log(&quot;The students are: &quot;, students);
  } else {
    console.log(&quot;There are no students&quot;);
  }
} else {
  var student1 = students[0];
  console.log(&quot;There's a single student here: &quot; + student1);
}
</code></pre>

<p></CodeTab></p>
<h3>Match on List</h3>
<p>Pattern matching on list is similar to array, but with the extra feature of extracting the tail of a list (all elements except the first one):</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let rec printStudents = (students) =&gt; {
  switch students {
  | list{} =&gt; () // done
  | list{student} =&gt; Js.log("Last student: " ++ student)
  | list{student1, ...otherStudents} =&gt;
    Js.log(student1)
    printStudents(otherStudents)
  }
}
printStudents(list{"Jane", "Harvey", "Patrick"})</p>
<pre class="codehilite"><code>```js
function printStudents(_students) {
  while(true) {
    var students = _students;
    if (!students) {
      return;
    }
    var otherStudents = students.tl;
    var student = students.hd;
    if (otherStudents) {
      console.log(student);
      _students = otherStudents;
      continue;
    }
    console.log(&quot;Last student: &quot; + student);
    return;
  };
}

printStudents({
  hd: &quot;Jane&quot;,
  tl: {
    hd: &quot;Harvey&quot;,
    tl: {
      hd: &quot;Patrick&quot;,
      tl: /* [] */0
    }
  }
});
</code></pre>

<p></CodeTab></p>
<h3>Small Pitfall</h3>
<p><strong>Note</strong>: you can only pass literals (i.e. concrete values) as a pattern, not let-binding names or other things. The following doesn't work as expected:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let coordinates = (10, 20, 30)
let centerY = 20
switch coordinates {
| (x, <em>centerY, </em>) =&gt; Js.log(x)
}</p>
<pre class="codehilite"><code>```js
var coordinates = [10, 20, 30];
var centerY = 20;

console.log(10);
</code></pre>

<p></CodeTab></p>
<p>A first time ReScript user might accidentally write that code, assuming that it's matching on <code>coordinates</code> when the second value is of the same value as <code>centerY</code>. In reality, this is interpreted as matching on coordinates and assigning the second value of the tuple to the name <code>centerY</code>, which isn't what's intended.</p>
<h2>Exhaustiveness Check</h2>
<p>As if the above features aren't enough, ReScript also provides arguably the most important pattern matching feature: <strong>compile-time check of missing patterns</strong>.</p>
<p>Let's revisit one of the above examples:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let message = switch person1 {
| Teacher({name: &quot;Mary&quot; | &quot;Joe&quot;}) =&gt;
  `Hey, still going to the party on Saturday?`
| Student({name, reportCard: {passing: true, gpa}}) =&gt;
  `Congrats ${name}, nice GPA of ${Js.Float.toString(gpa)} you got there!`
| Student({
    reportCard: {gpa: 0.0},
    status: Vacations(daysLeft) | Sabbatical(daysLeft)
  }) =&gt;
  `Come back in ${Js.Int.toString(daysLeft)} days!`
| Student({status: Sick}) =&gt;
  `How are you feeling?`
| Student({name}) =&gt;
  `Good luck next semester ${name}!`
}
</code></pre>

<pre class="codehilite"><code class="language-js">if (person1.TAG) {
  var match$1 = person1.status;
  var name = person1.name;
  var match$2 = person1.reportCard;
  if (match$2.passing) {
    &quot;Congrats &quot; + name + &quot;, nice GPA of &quot; + match$2.gpa.toString() + &quot; you got there!&quot;;
  } else if (typeof match$1 === &quot;number&quot;) {
    if (match$1 !== 0) {
      &quot;Good luck next semester &quot; + name + &quot;!&quot;;
    } else {
      &quot;How are you feeling?&quot;;
    }
  } else if (person1.reportCard.gpa !== 0.0) {
    &quot;Good luck next semester &quot; + name + &quot;!&quot;;
  } else {
    &quot;Come back in &quot; + match$1._0.toString() + &quot; days!&quot;;
  }
} else {
  switch (person1.name) {
    case &quot;Joe&quot;:
    case &quot;Mary&quot;:
      break;
    default:
      throw {
        RE_EXN_ID: &quot;Match_failure&quot;,
        _1: [
          &quot;playground.res&quot;,
          13,
          0
        ],
        Error: new Error()
      };
  }
}
</code></pre>

<p></CodeTab></p>
<p>Did you see what we removed? This time, we've omitted the handling of the case where <code>person1</code> is <code>Teacher({name})</code> when <code>name</code> isn't Mary or Joe.</p>
<p>Failing to handle every scenario of a value likely constitutes the majority of program bugs out there. This happens very often when you refactor a piece of code someone else wrote. Fortunately for ReScript, the compiler will tell you so:</p>
<pre class="codehilite"><code>Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Some({name: &quot;&quot;})
</code></pre>

<p><strong>BAM</strong>! You've just erased an entire category of important bugs before you even ran the code. In fact, this is how most of nullable values is handled:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myNullableValue = Some(5)</p>
<p>switch myNullableValue {
| Some(_v) =&gt; Js.log("value is present")
| None =&gt; Js.log("value is absent")
}</p>
<pre class="codehilite"><code>```js
var myNullableValue = 5;

if (myNullableValue !== undefined) {
  console.log(&quot;value is present&quot;);
} else {
  console.log(&quot;value is absent&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>If you don't handle the <code>None</code> case, the compiler warns. No more <code>undefined</code> bugs in your code!</p>
<h2>Conclusion &amp; Tips &amp; Tricks</h2>
<p>Hopefully you can see how pattern matching is a game changer for writing correct code, through the concise destructuring syntax, the proper conditions handling of <code>switch</code>, and the static exhaustiveness check.</p>
<p>Below is some advice:</p>
<p>Avoid using the wildcard <code>_</code> unnecessarily.  Using the wildcard <code>_</code> will bypass the compiler's exhaustiveness check.  Consequently, the compiler will not be able to notify you of probable errors when you add a new case to a variant. Try only using <code>_</code> against infinite possibilities, e.g. string, int, etc.</p>
<p>Use the <code>if</code> clause sparingly.</p>
<p><strong>Flatten your pattern-match whenever you can</strong>. This is a real bug remover. Here's a series of examples, from worst to best:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let optionBoolToBool = opt =&gt; {
  if opt == None {
    false
  } else if opt === Some(true) {
    true
  } else {
    false
  }
}</p>
<pre class="codehilite"><code>```js
function optionBoolToBool(opt) {
  if (opt === undefined) {
    return false;
  } else {
    return opt === true;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Now that's just silly =). Let's turn it into pattern-matching:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let optionBoolToBool = opt =&gt; {
  switch opt {
  | None =&gt; false
  | Some(a) =&gt; a ? true : false
  }
}</p>
<pre class="codehilite"><code>```js
function optionBoolToBool(opt) {
  if (opt !== undefined &amp;&amp; opt) {
    return true;
  } else {
    return false;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Slightly better, but still nested. Pattern-matching allows you to do this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let optionBoolToBool = opt =&gt; {
  switch opt {
  | None =&gt; false
  | Some(true) =&gt; true
  | Some(false) =&gt; false
  }
}</p>
<pre class="codehilite"><code>```js
function optionBoolToBool(opt) {
  if (opt !== undefined &amp;&amp; opt) {
    return true;
  } else {
    return false;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Much more linear-looking! Now, you might be tempted to do this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let optionBoolToBool = opt =&gt; {
  switch opt {
  | Some(true) =&gt; true
  | _ =&gt; false
  }
}</p>
<pre class="codehilite"><code>```js
function optionBoolToBool(opt) {
  if (opt !== undefined &amp;&amp; opt) {
    return true;
  } else {
    return false;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Which is much more concise, but kills the exhaustiveness check mentioned above; refrain from using that. This is the best:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let optionBoolToBool = opt =&gt; {
  switch opt {
  | Some(trueOrFalse) =&gt; trueOrFalse
  | None =&gt; false
  }
}</p>
<pre class="codehilite"><code>```js
function optionBoolToBool(opt) {
  if (opt !== undefined) {
    return opt;
  } else {
    return false;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Pretty darn hard to make a mistake in this code at this point! Whenever you'd like to use an if-else with many branches, prefer pattern matching instead. It's more concise and <a href="variant#design-decisions">performant</a> too.</p><h1>overview</h1><hr />
<p>title: "Overview"
metaTitle: "Language Features Overview"
description: "A quick overview on ReScript's syntax"
canonical: "/docs/manual/latest/overview"</p>
<hr />
<h1>Overview</h1>
<h2>Comparison to JS</h2>
<h3>Semicolon</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rules enforced by linter/formatter</td>
<td>No semicolon needed!</td>
</tr>
</tbody>
</table>
<h3>Comments</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>// Line comment</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>/* Comment */</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>/** Doc Comment */</code></td>
<td><code>/** Before Types/Values */</code></td>
</tr>
<tr>
<td></td>
<td><code>/*** Standalone Doc Comment */</code></td>
</tr>
</tbody>
</table>
<h3>Variable</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const x = 5;</code></td>
<td><code>let x = 5</code></td>
</tr>
<tr>
<td><code>var x = y;</code></td>
<td>No equivalent (thankfully)</td>
</tr>
<tr>
<td><code>let x = 5; x = x + 1;</code></td>
<td><code>let x = ref(5); x := x.contents + 1</code></td>
</tr>
</tbody>
</table>
<h3>String &amp; Character</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"Hello world!"</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>'Hello world!'</code></td>
<td>Strings must use <code>"</code></td>
</tr>
<tr>
<td><code>"hello " + "world"</code></td>
<td><code>"hello " ++ "world"</code></td>
</tr>
<tr>
<td><code>`hello ${message}`</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h3>Boolean</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true</code>, <code>false</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>!true</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>&#124;&#124;</code>, <code>&amp;&amp;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>a === b</code>, <code>a !== b</code></td>
<td>Same</td>
</tr>
<tr>
<td>No deep equality (recursive compare)</td>
<td><code>a == b</code>, <code>a != b</code></td>
</tr>
<tr>
<td><code>a == b</code></td>
<td>No equality with implicit casting (thankfully)</td>
</tr>
</tbody>
</table>
<h3>Number</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3</code></td>
<td>Same *</td>
</tr>
<tr>
<td><code>3.1415</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>3 + 4</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>3.0 + 4.5</code></td>
<td><code>3.0 +. 4.5</code></td>
</tr>
<tr>
<td><code>5 % 3</code></td>
<td><code>mod(5, 3)</code></td>
</tr>
</tbody>
</table>
<p>* JS has no distinction between integer and float.</p>
<h3>Object/Record</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>no types</td>
<td><code>type point = {x: int, mutable y: int}</code></td>
</tr>
<tr>
<td><code>{x: 30, y: 20}</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>point.x</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>point.y = 30;</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>{...point, x: 30}</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h3>Array</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[1, 2, 3]</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>myArray[1] = 10</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>[1, "Bob", true]</code></td>
<td><code>(1, "Bob", true)</code> *</td>
</tr>
</tbody>
</table>
<p>* Heterogenous arrays in JS are disallowed for us. Use tuple instead.</p>
<h3>Null</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code>, <code>undefined</code></td>
<td><code>None</code> *</td>
</tr>
</tbody>
</table>
<p>* Again, only a spiritual equivalent; we don't have nulls, nor null bugs! But we do have an <code>option</code> type for when you actually need nullability.</p>
<h3>Function</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arg =&gt; retVal</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>function named(arg) {...}</code></td>
<td><code>let named = (arg) =&gt; {...}</code></td>
</tr>
<tr>
<td><code>const f = function(arg) {...}</code></td>
<td><code>let f = (arg) =&gt; {...}</code></td>
</tr>
<tr>
<td><code>add(4, add(5, 6))</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h3>Async Function / Await</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>async (arg) =&gt; {...}</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>async function named(arg) {...}</code></td>
<td><code>let named = async (arg) =&gt; {...}</code></td>
</tr>
<tr>
<td><code>await somePromise</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>async (arg): Promise&lt;string&gt; =&gt; {...}</code></td>
<td><code>async (): string =&gt; {...}</code> (note the return type)</td>
</tr>
</tbody>
</table>
<h3>Blocks</h3>
<table>
  <thead>
    <tr>
      <th>JavaScript</th>
      <th>ReScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
      ```
      const myFun = (x, y) => {
        const doubleX = x + x;
        const doubleY = y + y;
        return doubleX + doubleY
      };
      ```
      </td>
      <td>
      ```
      let myFun = (x, y) => {
        let doubleX = x + x
        let doubleY = y + y
        doubleX + doubleY
      }
      ```
      </td>
    </tr>
  </tbody>
</table>

<h3>If-else</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>if (a) {b} else {c}</code></td>
<td><code>if a {b} else {c}</code> *</td>
</tr>
<tr>
<td><code>a ? b : c</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>switch</code></td>
<td><code>switch</code> but <a href="pattern-matching-destructuring.md">super-powered pattern matching!</a></td>
</tr>
</tbody>
</table>
<p>* Our conditionals are always expressions! You can write <code>let result = if a {"hello"} else {"bye"}</code></p>
<h3>Destructuring</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const {a, b} = data</code></td>
<td><code>let {a, b} = data</code></td>
</tr>
<tr>
<td><code>const [a, b] = data</code></td>
<td><code>let [a, b] = data</code> *</td>
</tr>
<tr>
<td><code>const {a: aa, b: bb} = data</code></td>
<td><code>let {a: aa, b: bb} = data</code></td>
</tr>
</tbody>
</table>
<p>* Gives good compiler warning that <code>data</code> might not be of length 2.</p>
<h3>Loop</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for (let i = 0; i &lt;= 10; i++) {...}</code></td>
<td><code>for i in 0 to 10 {...}</code></td>
</tr>
<tr>
<td><code>for (let i = 10; i &gt;= 0; i--) {...}</code></td>
<td><code>for i in 10 downto 0 {...}</code></td>
</tr>
<tr>
<td><code>while (true) {...}</code></td>
<td><code>while true {...}</code></td>
</tr>
</tbody>
</table>
<h3>JSX</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;Comp message="hi" onClick={handler} /&gt;</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>&lt;Comp message={message} /&gt;</code></td>
<td><code>&lt;Comp message /&gt;</code> *</td>
</tr>
<tr>
<td><code>&lt;input checked /&gt;</code></td>
<td><code>&lt;input checked=true /&gt;</code></td>
</tr>
<tr>
<td>No children spread</td>
<td><code>&lt;Comp&gt;...children&lt;/Comp&gt;</code></td>
</tr>
</tbody>
</table>
<p>* Argument punning!</p>
<h3>Exception</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>ReScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>throw new SomeError(...)</code></td>
<td><code>raise(SomeError(...))</code></td>
</tr>
<tr>
<td><code>try {a} catch (Err) {...} finally {...}</code></td>
<td><code>try a catch { \| Err =&gt; ...}</code> *</td>
</tr>
</tbody>
</table>
<p>* No finally.</p>
<h3>Blocks</h3>
<p>The last expression of a block delimited by <code>{}</code> implicitly returns (including function body). In JavaScript, this can only be simulated via an immediately-invoked function expression (since function bodies have their own local scope).</p>
<table>
  <thead>
    <tr>
      <th>JavaScript</th>
      <th>ReScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
      ```
      let result = (function() {
        const x = 23;
        const y = 34;
        return x + y;
      })();
      ```
      </td>
      <td>
      ```
      let result = {
        let x = 23
        let y = 34
        x + y
      }
      ```
      </td>
    </tr>
  </tbody>
</table>

<h2>Common Features' JS Output</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Example</th>
<th>JavaScript Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td><code>"Hello"</code></td>
<td><code>"Hello"</code></td>
</tr>
<tr>
<td>String Interpolation</td>
<td><code>`Hello ${message}`</code></td>
<td><code>"Hello " + message</code></td>
</tr>
<tr>
<td>Character (disrecommended)</td>
<td><code>'x'</code></td>
<td><code>120</code> (char code)</td>
</tr>
<tr>
<td>Integer</td>
<td><code>23</code>, <code>-23</code></td>
<td><code>23</code>, <code>-23</code></td>
</tr>
<tr>
<td>Float</td>
<td><code>23.0</code>, <code>-23.0</code></td>
<td><code>23.0</code>, <code>-23.0</code></td>
</tr>
<tr>
<td>Integer Addition</td>
<td><code>23 + 1</code></td>
<td><code>23 + 1</code></td>
</tr>
<tr>
<td>Float Addition</td>
<td><code>23.0 +. 1.0</code></td>
<td><code>23.0 + 1.0</code></td>
</tr>
<tr>
<td>Integer Division/Multiplication</td>
<td><code>2 / 23 * 1</code></td>
<td><code>2 / 23 * 1</code></td>
</tr>
<tr>
<td>Float Division/Multiplication</td>
<td><code>2.0 /. 23.0 *. 1.0</code></td>
<td><code>2.0 / 23.0 * 1.0</code></td>
</tr>
<tr>
<td>Float Exponentiation</td>
<td><code>2.0 ** 3.0</code></td>
<td><code>Math.pow(2.0, 3.0)</code></td>
</tr>
<tr>
<td>String Concatenation</td>
<td><code>"Hello " ++ "World"</code></td>
<td><code>"Hello " + "World"</code></td>
</tr>
<tr>
<td>Comparison</td>
<td><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></td>
<td><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></td>
</tr>
<tr>
<td>Boolean operation</td>
<td><code>!</code>, <code>&amp;&amp;</code>, <code>&#124;&#124;</code></td>
<td><code>!</code>, <code>&amp;&amp;</code>, <code>&#124;&#124;</code></td>
</tr>
<tr>
<td>Shallow and deep Equality</td>
<td><code>===</code>, <code>==</code></td>
<td><code>===</code>, <code>==</code></td>
</tr>
<tr>
<td>List (disrecommended)</td>
<td><code>list{1, 2, 3}</code></td>
<td><code>{hd: 1, tl: {hd: 2, tl: {hd: 3, tl: 0}}}</code></td>
</tr>
<tr>
<td>List Prepend</td>
<td><code>list{a1, a2, ...oldList}</code></td>
<td><code>{hd: a1, tl: {hd: a2, tl: theRest}}</code></td>
</tr>
<tr>
<td>Array</td>
<td><code>[1, 2, 3]</code></td>
<td><code>[1, 2, 3]</code></td>
</tr>
<tr>
<td>Record</td>
<td><code>type t = {b: int}; let a = {b: 10}</code></td>
<td><code>var a = {b: 10}</code></td>
</tr>
<tr>
<td>Multiline Comment</td>
<td><code>/* Comment here */</code></td>
<td>Not in output</td>
</tr>
<tr>
<td>Single line Comment</td>
<td><code>// Comment here</code></td>
<td>Not in output</td>
</tr>
</tbody>
</table>
<p><em>Note that this is a cleaned-up comparison table; a few examples' JavaScript output are slightly different in reality.</em></p><h1>embed-raw-javascript</h1><hr />
<p>title: "Embed Raw JavaScript"
description: "Utility syntax to for raw JS usage in ReScript"
canonical: "/docs/manual/latest/embed-raw-javascript"</p>
<hr />
<h1>Embed Raw JavaScript</h1>
<h2>Paste Raw JS Code</h2>
<p>First thing first. If you're ever stuck learning ReScript, remember that you can always just paste raw JavaScript code into our source file:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res example
%%raw(</code>
// look ma, regular JavaScript!
var message = "hello";
function greet(m) {
  console.log(m)
}
`)</p>
<pre class="codehilite"><code>```js
// look ma, regular JavaScript!
var message = &quot;hello&quot;;
function greet(m) {
  console.log(m)
}
</code></pre>

<p></CodeTab></p>
<p>The <code>%%raw</code> special ReScript call takes your code string and pastes it as-is into the output. <strong>You've now technically written your first ReScript file!</strong></p>
<p>(The back tick syntax is a multiline string, similar to JavaScript's. Except for us, no escaping is needed inside the string. More on string in a later section.)</p>
<p>While <code>%%raw</code> lets you embed top-level raw JS code, <code>%raw</code> lets you embed expression-level JS code:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res example
let add = %raw(</code>
  function(a, b) {
    console.log("hello from raw JavaScript!");
    return a + b
  }
`)</p>
<p>Js.log(add(1, 2))</p>
<pre class="codehilite"><code>```js
var add = function(a, b) {
  console.log(&quot;hello from raw JavaScript!&quot;);
  return a + b
};

console.log(add(1, 2));
</code></pre>

<p></CodeTab></p>
<p>The above code:
- declared a ReScript variable <code>add</code>,
- with the raw JavaScript value of a function declaration,
- then called that function in ReScript.</p>
<p>If your boss is ever worried that your teammates can't adopt ReScript, just let them keep writing JavaScript inside ReScript files =).</p>
<h2>Debugger</h2>
<p>You can also drop a <code>%debugger</code> expression in a body:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let f = (x, y) =&gt; {
  %debugger
  x + y
}</p>
<pre class="codehilite"><code>```js
function f(x, y) {
  debugger;
  return x + y | 0;
}
</code></pre>

<p></CodeTab></p>
<p>Output:</p>
<pre class="codehilite"><code class="language-js">function f(x, y) {
  debugger; // JavaScript developer tools will set an breakpoint and stop here
  x + y;
}
</code></pre>

<h2>Tips &amp; Tricks</h2>
<p>Embedding raw JS snippets isn't the best way to experience ReScript, though it's also highly useful if you're just starting out. As a matter of fact, the first few ReScript projects were converted through:</p>
<ul>
<li>pasting raw JS snippets inside a file</li>
<li>examining the JS output (identical to the old hand-written JS)</li>
<li>gradually extract a few values and functions and making sure the output still looks OK</li>
</ul>
<p>At the end, we get a fully safe, converted ReScript file whose JS output is clean enough that we can confidently assert that no new bug has been introduced during the conversion process.</p>
<p>We have a small guide on this iteration <a href="converting-from-js.md">here</a>. Feel free to peruse it later.</p><h1>promise</h1><hr />
<p>title: "Promises"
description: "JS Promise handling in ReScript"
canonical: "/docs/manual/latest/promise"</p>
<hr />
<h1>Promise</h1>
<blockquote>
<p><strong>Note:</strong> Starting from ReScript 10.1 and above, we recommend using <a href="./async-await">async / await</a> when interacting with Promises.</p>
</blockquote>
<h2><code>promise</code> type</h2>
<p><strong>Since 10.1</strong></p>
<p>In ReScript, every JS promise is represented with the globally available <code>promise&lt;'a&gt;</code> type. For ReScript versions &lt; 10.1, use its original alias <code>Js.Promise.t&lt;'a&gt;</code> instead.</p>
<p>Here's a usage example in a function signature:</p>
<pre class="codehilite"><code class="language-resi">// User.resi file

type user = {name: string}

let fetchUser: string =&gt; promise&lt;user&gt;
</code></pre>

<p>To work with promise values (instead of using <code>async</code> / <code>await</code>) you may want to use the built in <code>Js.Promise2</code> module. </p>
<h2>Js.Promise2</h2>
<p>A builtin module to create, chain and manipulate promises.</p>
<blockquote>
<p><strong>Note:</strong> This is an intermediate replacement for the <code>Js.Promise</code> module. It is designed to work with the <code>-&gt;</code> operator and should be used in favour of it's legacy counterpart. We are aware that the <code>Belt</code>, <code>Js</code> and <code>Js.xxx2</code> situation is confusing; a proper solution will hopefully be part of our upcoming <code>v11</code> release.</p>
</blockquote>
<h3>Creating a promise</h3>
<pre class="codehilite"><code class="language-res">let p1 = Js.Promise2.make((~resolve, ~reject) =&gt; {
  // We use uncurried functions for resolve / reject
  // for cleaner JS output without unintended curry calls
  resolve(. &quot;hello world&quot;)
})

let p2 = Js.Promise2.resolve(&quot;some value&quot;)

// You can only reject `exn` values for streamlined catch handling
exception MyOwnError(string)
let p3 = Js.Promise2.reject(MyOwnError(&quot;some rejection&quot;))
</code></pre>

<h3>Access the contents and transform a promise</h3>
<pre class="codehilite"><code class="language-res">let logAsyncMessage = () =&gt; {
  open Js.Promise2
  Js.Promise2.resolve(&quot;hello world&quot;)
  -&gt;then(msg =&gt; {
    // then callbacks require the result to be resolved explicitly
    resolve(&quot;Message: &quot; ++ msg)
  })
  -&gt;then(msg =&gt; {
    Js.log(msg)

    // Even if there is no result, we need to use resolve() to return a promise
    resolve()
  })
  -&gt;ignore // Requires ignoring due to unhandled return value
}
</code></pre>

<p>For comparison, the <code>async</code> / <code>await</code> version of the same code would look like this:</p>
<pre class="codehilite"><code class="language-res">let logAsyncMessage = async () =&gt; {
  let msg = await Js.Promise2.resolve(&quot;hello world&quot;)
  Js.log(`Message: ${msg}`)
}
</code></pre>

<p>Needless to say, the async / await version offers better ergonomics and less opportunities to run into type issues.</p>
<h3>Run multiple promises in parallel</h3>
<p>In case you want to launch multiple promises in parallel, use <code>Js.Promise2.all</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@val
external fetchMessage: string =&gt; promise&lt;string&gt; = &quot;global.fetchMessage&quot;

let logAsyncMessage = async () =&gt; {
  let messages = await Js.Promise2.all([fetchMessage(&quot;message1&quot;), fetchMessage(&quot;message2&quot;)])

  Js.log(Js.Array2.joinWith(messages, &quot;, &quot;))
}
</code></pre>

<pre class="codehilite"><code class="language-js">async function logAsyncMessage(param) {
  var messages = await Promise.all([
        global.fetchMessage(&quot;message1&quot;),
        global.fetchMessage(&quot;message2&quot;)
      ]);
  console.log(messages.join(&quot;, &quot;));
}

export {
  logAsyncMessage ,
}
</code></pre>

<p></CodeTab></p>
<h2>Js.Promise module (legacy - do not use)</h2>
<blockquote>
<p><strong>Note:</strong> The <code>Js.Promise</code> bindings are following the outdated data-last convention from a few years ago. We kept those APIs for backwards compatibility. Either use <code>Js.Promise2</code> or a third-party promise binding instead.</p>
</blockquote>
<p>ReScript has built-in support for <a href="api/js/promise">JavaScript promises</a>. The 3 functions you generally need are:</p>
<ul>
<li><code>Js.Promise.resolve: 'a =&gt; Js.Promise.t&lt;'a&gt;</code></li>
<li><code>Js.Promise.then_: ('a =&gt; Js.Promise.t&lt;'b&gt;, Js.Promise.t&lt;'a&gt;) =&gt; Js.Promise.t&lt;'b&gt;</code></li>
<li><code>Js.Promise.catch: (Js.Promise.error =&gt; Js.Promise.t&lt;'a&gt;, Js.Promise.t&lt;'a&gt;) =&gt; Js.Promise.t&lt;'a&gt;</code></li>
</ul>
<p>Additionally, here's the type signature for creating a promise on the ReScript side:</p>
<pre class="codehilite"><code class="language-res">Js.Promise.make: (
  (
    ~resolve: (. 'a) =&gt; unit,
    ~reject: (. exn) =&gt; unit
  ) =&gt; unit
) =&gt; Js.Promise.t&lt;'a&gt;
</code></pre>

<p>This type signature means that <code>make</code> takes a callback that takes 2 named arguments, <code>resolve</code> and <code>reject</code>. Both arguments are themselves <a href="function.md#uncurried-function">uncurried callbacks</a> (with a dot). <code>make</code> returns the created promise.</p>
<h3>Usage</h3>
<p>Using the <a href="pipe.md">pipe operator</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myPromise = Js.Promise.make((~resolve, ~reject) =&gt; resolve(. 2))</p>
<p>myPromise-&gt;Js.Promise.then_(value =&gt; {
  Js.log(value)
  Js.Promise.resolve(value + 2)
}, <em>)-&gt;Js.Promise.then</em>(value =&gt; {
  Js.log(value)
  Js.Promise.resolve(value + 3)
}, <em>)-&gt;Js.Promise.catch(err =&gt; {
  Js.log2("Failure!!", err)
  Js.Promise.resolve(-2)
}, </em>)</p>
<pre class="codehilite"><code>```js
var myPromise = new Promise(function (resolve, reject) {
  return resolve(2);
});

myPromise
  .then(function (value) {
    console.log(value);
    return Promise.resolve((value + 2) | 0);
  })
  .then(function (value) {
    console.log(value);
    return Promise.resolve((value + 3) | 0);
  })
  .catch(function (err) {
    console.log(&quot;Failure!!&quot;, err);
    return Promise.resolve(-2);
  });
</code></pre>

<p></CodeTab></p><h1>bind-to-js-function</h1><hr />
<p>title: "Bind to JS Function"
description: "JS interop with functions in ReScript"
canonical: "/docs/manual/latest/bind-to-js-function"</p>
<hr />
<h1>Function</h1>
<p>Binding a JS function is like binding any other value:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// Import nodejs' path.dirname
@module("path") external dirname: string =&gt; string = "dirname"
let root = dirname("/User/github") // returns "User"</p>
<pre class="codehilite"><code>```js
var Path = require(&quot;path&quot;);
var root = Path.dirname(&quot;/User/github&quot;);
</code></pre>

<p></CodeTab></p>
<p>We also expose a few special features, described below.</p>
<h2>Labeled Arguments</h2>
<p>ReScript has <a href="function.md#labeled-arguments">labeled arguments</a> (that can also be optional). These work on an <code>external</code> too! You'd use them to <em>fix</em> a JS function's unclear usage. Assuming we're modeling this:</p>
<pre class="codehilite"><code class="language-js">// MyGame.js

function draw(x, y, border) {
   // suppose `border` is optional and defaults to false
}
draw(10, 20)
draw(20, 20, true)
</code></pre>

<p>It'd be nice if on ReScript's side, we can bind &amp; call <code>draw</code> while labeling things a bit:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("MyGame")
external draw: (~x: int, ~y: int, ~border: bool=?) =&gt; unit = "draw"</p>
<p>draw(~x=10, ~y=20, ~border=true)
draw(~x=10, ~y=20)</p>
<pre class="codehilite"><code>```js
var MyGame = require(&quot;MyGame&quot;);

MyGame.draw(10, 20, true);
MyGame.draw(10, 20, undefined);
</code></pre>

<p></CodeTab></p>
<p>We've compiled to the same function, but now the usage is much clearer on the ReScript side thanks to labels!</p>
<p>Note that you can freely reorder the labels on the ReScript side; they'll always correctly appear in their declaration order in the JavaScript output:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("MyGame")
external draw: (~x: int, ~y: int, ~border: bool=?) =&gt; unit = "draw"</p>
<p>draw(~x=10, ~y=20)
draw(~y=20, ~x=10)</p>
<pre class="codehilite"><code>```js
var MyGame = require(&quot;MyGame&quot;);

MyGame.draw(10, 20, undefined);
MyGame.draw(10, 20, undefined);
</code></pre>

<p></CodeTab></p>
<h2>Object Method</h2>
<p>Functions attached to a JS objects (other than JS modules) require a special way of binding to them, using <code>send</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type document // abstract type for a document object
@send external getElementById: (document, string) =&gt; Dom.element = "getElementById"
@val external doc: document = "document"</p>
<p>let el = getElementById(doc, "myId")</p>
<pre class="codehilite"><code>```js
var el = document.getElementById(&quot;myId&quot;);
</code></pre>

<p></CodeTab></p>
<p>In a <code>send</code>, the object is always the first argument. Actual arguments of the method follow (this is a bit what modern OOP objects are really).</p>
<h3>Chaining</h3>
<p>Ever used <code>foo().bar().baz()</code> chaining ("fluent api") in JS OOP? We can model that in ReScript too, through the <a href="pipe.md">pipe operator</a>.</p>
<h2>Variadic Function Arguments</h2>
<p>You might have JS functions that take an arbitrary amount of arguments. ReScript supports modeling those, under the condition that the arbitrary arguments part is homogenous (aka of the same type). If so, add <code>variadic</code> to your <code>external</code>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("path") @variadic
external join: array<string> =&gt; string = "join"</p>
<p>let v = join(["a", "b"])</p>
<pre class="codehilite"><code>```js
var Path = require(&quot;path&quot;);
var v = Path.join(&quot;a&quot;, &quot;b&quot;);
</code></pre>

<p></CodeTab></p>
<p><code>module</code> will be explained in <a href="import-from-export-to-js.md">Import from/Export to JS</a>.</p>
<h2>Modeling Polymorphic Function</h2>
<p>Apart from the above special-case, JS function in general are often arbitrary overloaded in terms of argument types and number. How would you bind to those?</p>
<h3>Trick 1: Multiple <code>external</code>s</h3>
<p>If you can exhaustively enumerate the many forms an overloaded JS function can take, simply bind to each differently:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("MyGame") external drawCat: unit =&gt; unit = "draw"
@module("MyGame") external drawDog: (~giveName: string) =&gt; unit = "draw"
@module("MyGame") external draw: (string, ~useRandomAnimal: bool) =&gt; unit = "draw"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>Note how all three externals bind to the same JS function, <code>draw</code>.</p>
<h3>Trick 2: Polymorphic Variant + <code>unwrap</code></h3>
<p>If you have the irresistible urge of saying "if only this JS function argument was a variant instead of informally being either <code>string</code> or <code>int</code>", then good news: we do provide such <code>external</code> features through annotating a parameter as a polymorphic variant! Assuming you have the following JS function you'd like to bind to:</p>
<pre class="codehilite"><code class="language-js">function padLeft(value, padding) {
  if (typeof padding === &quot;number&quot;) {
    return Array(padding + 1).join(&quot; &quot;) + value;
  }
  if (typeof padding === &quot;string&quot;) {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>

<p>Here, <code>padding</code> is really conceptually a variant. Let's model it as such.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val
external padLeft: (
  string,
  @unwrap [
    | #Str(string)
    | #Int(int)
  ])
  =&gt; string = "padLeft"
padLeft("Hello World", #Int(4))
padLeft("Hello World", #Str("Message from ReScript: "))</p>
<pre class="codehilite"><code>```js
padLeft(&quot;Hello World&quot;, 4);
padLeft(&quot;Hello World&quot;, &quot;Message from ReScript: &quot;);
</code></pre>

<p></CodeTab></p>
<p>Obviously, the JS side couldn't have an argument that's a polymorphic variant! But here, we're just piggy backing on poly variants' type checking and syntax. The secret is the <code>@unwrap</code> annotation on the type. It strips the variant constructors and compile to just the payload's value. See the output.</p>
<h2>Constrain Arguments Better</h2>
<p>Consider the Node <code>fs.readFileSync</code>'s second argument. It can take a string, but really only a defined set: <code>"ascii"</code>, <code>"utf8"</code>, etc. You can still bind it as a string, but we can use poly variants + <code>string</code> to ensure that our usage's more correct:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("fs")
external readFileSync: (
  ~name: string,
  @string [
    | #utf8
    | @as("ascii") #useAscii
  ],
) =&gt; string = "readFileSync"</p>
<p>readFileSync(~name="xx.txt", #useAscii)</p>
<pre class="codehilite"><code>```js
var Fs = require(&quot;fs&quot;);
Fs.readFileSync(&quot;xx.txt&quot;, &quot;ascii&quot;);
</code></pre>

<p></CodeTab></p>
<ul>
<li>Attaching <code>@string</code> to the whole poly variant type makes its constructor compile to a string of the same name.</li>
<li>Attaching a <code>@as("bla")</code> to a constructor lets you customize the final string.</li>
</ul>
<p>And now, passing something like <code>"myOwnUnicode"</code> or other variant constructor names to <code>readFileSync</code> would correctly error.</p>
<p>Aside from string, you can also compile an argument to an int, using <code>int</code> instead of <code>string</code> in a similar way:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val
external testIntType: (
  @int [
    | #onClosed
    | @as(20) #onOpen
    | #inBinary
  ])
  =&gt; int = "testIntType"
testIntType(#inBinary)</p>
<pre class="codehilite"><code>```js
testIntType(21);
</code></pre>

<p></CodeTab></p>
<p><code>onClosed</code> compiles to <code>0</code>, <code>onOpen</code> to <code>20</code> and <code>inBinary</code> to <strong><code>21</code></strong>.</p>
<h2>Unknown for type safety</h2>
<p>It is best practice to inspect data received from untrusted external functions to ensure it contains what you expect. This helps avoid run-time crashes and unexpected behavior. If you're certain about what an external function returns, simply assert the return value as <code>string</code> or <code>array&lt;int&gt;</code> or whatever you want it to be. Otherwise use <code>unknown</code>. The ReScript type system will prevent you from using an <code>unknown</code> until you first inspect it and "convert" it using JSON parsing utilities or similar tools.</p>
<p>Consider the example below of two external functions that access the value of a property on a JavaScript object. <code>getPropertyUnsafe</code> returns an <code>'a</code>, which means "anything you want it to be." ReScript allows you to use this value as a <code>string</code> or <code>array</code> or any other type. Quite convenient! But if the property is missing or contains something unexpected, your code might break. You can make the binding more safe by changing <code>'a</code> to <code>string</code> or <code>option&lt;'a&gt;</code>, but this doesn't completely eliminate the problem.</p>
<p>The <code>getPropertySafe</code> function returns an <code>unknown</code>, which could be <code>null</code> or a <code>string</code> or anything else. But ReScript prevents you from using this value inappropriately until it has been safely parsed.</p>
<p>```res example
@get_index external getPropertyUnsafe: ({..}, string) =&gt; 'a = ""
@get_index external getPropertySafe: ({..}, string) =&gt; unknown = ""</p>
<p>let person = {"name": "Bob", "age": 12}</p>
<p>let greeting1 = "Hello, " ++ getPropertyUnsafe(person, "name") // works (this time!)
// let greeting2 = "Hello, " ++ getPropertySafe(person, "name") // syntax error</p>
<pre class="codehilite"><code>## Special-case: Event Listeners

One last trick with polymorphic variants:

&lt;CodeTab labels={[&quot;ReScript&quot;, &quot;JS Output&quot;]}&gt;

```res example
type readline

@send
external on: (
    readline,
    @string [
      | #close(unit =&gt; unit)
      | #line(string =&gt; unit)
    ]
  )
  =&gt; readline = &quot;on&quot;

let register = rl =&gt;
  rl
  -&gt;on(#close(event =&gt; ()))
  -&gt;on(#line(line =&gt; Js.log(line)));
</code></pre>

<pre class="codehilite"><code class="language-js">function register(rl) {
  return rl
    .on(&quot;close&quot;, function($$event) {})
    .on(&quot;line&quot;, function(line) {
      console.log(line);
    });
}
</code></pre>

<p></CodeTab></p>
<!-- TODO: GADT phantom type -->

<h2>Fixed Arguments</h2>
<p>Sometimes it's convenient to bind to a function using an <code>external</code>, while passing predetermined argument values to the JS function:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val
external processOnExit: (
  @as("exit") _,
  int =&gt; unit
) =&gt; unit = "process.on"</p>
<p>processOnExit(exitCode =&gt;
  Js.log("error code: " ++ Js.Int.toString(exitCode))
);</p>
<pre class="codehilite"><code>```js
process.on(&quot;exit&quot;, function (exitCode) {
  console.log(&quot;error code: &quot; + exitCode.toString());
});
</code></pre>

<p></CodeTab></p>
<p>The <code>@as("exit")</code> and the placeholder <code>_</code> argument together indicates that you want the first argument to compile to the string <code>"exit"</code>. You can also use any JSON literal with <code>as</code>: <code>@as(json`true`)</code>, <code>@as(json`{"name": "John"}`)</code>, etc.</p>
<h2>Ignore arguments</h2>
<p>You can also explicitly "hide" <code>external</code> function parameters in the JS output, which may be useful if you want to add type constraints to other parameters without impacting the JS side:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@val external doSomething: (@ignore 'a, 'a) =&gt; unit = &quot;doSomething&quot;

doSomething(&quot;this only shows up in ReScript code&quot;, &quot;test&quot;)
</code></pre>

<pre class="codehilite"><code class="language-js">doSomething(&quot;test&quot;);
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> It's a pretty niche feature, mostly used to map to polymorphic JS APIs.</p>
<h2>Modeling <code>this</code>-based Callbacks</h2>
<p>Many JS libraries have callbacks which rely on this (the source), for example:</p>
<pre class="codehilite"><code class="language-js">x.onload = function(v) {
  console.log(this.response + v)
}
</code></pre>

<p>Here, <code>this</code> would point to <code>x</code> (actually, it depends on how <code>onload</code> is called, but we digress). It's not correct to declare <code>x.onload</code> of type <code>(. unit) -&gt; unit</code>. Instead, we introduced a special attribute, <code>this</code>, which allows us to type <code>x</code> as so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type x
@val external x: x = "x"
@set external setOnload: (x, @this ((x, int) =&gt; unit)) =&gt; unit = "onload"
@get external resp: x =&gt; int = "response"
setOnload(x, @this (o, v) =&gt; Js.log(resp(o) + v))</p>
<pre class="codehilite"><code>```js
x.onload = function (v) {
  var o = this;
  console.log((o.response + v) | 0);
};
</code></pre>

<p></CodeTab></p>
<p><code>this</code> has its first parameter is reserved for <code>this</code> and for arity of 0, there is no need for a redundant <code>unit</code> type.</p>
<h2>Function Nullable Return Value Wrapping</h2>
<p>For JS functions that return a value that can also be <code>undefined</code> or <code>null</code>, we provide <code>@return(...)</code>. To automatically convert that value to an <code>option</code> type (recall that ReScript <code>option</code> type's <code>None</code> value only compiles to <code>undefined</code> and not <code>null</code>).</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type element
type dom</p>
<p>@send @return(nullable)
external getElementById: (dom, string) =&gt; option<element> = "getElementById"</p>
<p>let test = dom =&gt; {
  let elem = dom-&gt;(getElementById("haha"))
  switch (elem) {
  | None =&gt; 1
  | Some(_ui) =&gt; 2
  }
}</p>
<pre class="codehilite"><code>```js
function test(dom) {
  var elem = dom.getElementById(&quot;haha&quot;);
  if (elem == null) {
    return 1;
  } else {
    console.log(elem);
    return 2;
  }
}
</code></pre>

<p></CodeTab></p>
<p><code>return(nullable)</code> attribute will automatically convert <code>null</code> and <code>undefined</code> to <code>option</code> type.</p>
<p>Currently 4 directives are supported: <code>null_to_opt</code>, <code>undefined_to_opt</code>, <code>nullable</code> and <code>identity</code>.</p>
<!-- When the return type is unit: the compiler will append its return value with an OCaml unit literal to make sure it does return unit. Its main purpose is to make the user consume FFI in idiomatic OCaml code, the cost is very very small and the compiler will do smart optimizations to remove it when the returned value is not used (mostly likely). -->

<p><code>identity</code> will make sure that compiler will do nothing about the returned value. It is rarely used, but introduced here for debugging purpose.</p><h1>json</h1><hr />
<p>title: "JSON"
description: "Interacting with JSON in ReScript"
canonical: "/docs/manual/latest/json"</p>
<hr />
<h1>JSON</h1>
<h2>Parse</h2>
<p>Bind to JavaScript's <code>JSON.parse</code> and type the return value as the type you're expecting:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// declare the shape of the json you're binding to
type data = {names: array<string>}</p>
<p>// bind to JS' JSON.parse
@scope("JSON") @val
external parseIntoMyData: string =&gt; data = "parse"</p>
<p>let result = parseIntoMyData(<code>{"names": ["Luke", "Christine"]}</code>)
let name1 = result.names[0]</p>
<pre class="codehilite"><code>```js
var result = JSON.parse(&quot;{\&quot;names\&quot;: [\&quot;Luke\&quot;, \&quot;Christine\&quot;]}&quot;);
var name1 = result.names[0];
</code></pre>

<p></CodeTab></p>
<p>Where <code>data</code> can be any type you assume the JSON is. As you can see, this compiles to a straightforward <code>JSON.parse</code> call. As with regular JS, this is convenient, but has no guarantee that e.g. the data is correctly shaped, or even syntactically valid. Slightly dangerous.</p>
<h2>Stringify</h2>
<p>Use <code>Js.Json.stringify</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
Js.log(Js.Json.stringifyAny(["Amy", "Joe"]))</p>
<pre class="codehilite"><code>```js
console.log(JSON.stringify([
  &quot;Amy&quot;,
  &quot;Joe&quot;
]));
</code></pre>

<p></CodeTab></p>
<h2>Advanced</h2>
<p>The <a href="api/js/json">Js.Json</a> module provides slightly safer, low-level building blocks for power users who want to parse JSON on a per-field basis. See the examples in the API docs.</p><h1>type</h1><hr />
<p>title: "Type"
description: "Types and type definitions in ReScript"
canonical: "/docs/manual/latest/type"</p>
<hr />
<h1>Type</h1>
<p>Types are the highlight of ReScript! They are:
- <strong>Strong</strong>. A type can't change into another type. In JavaScript, your variable's type might change when the code runs (aka at runtime). E.g. a <code>number</code> variable might change into a <code>string</code> sometimes. This is an anti-feature; it makes the code much harder to understand when reading or debugging.
- <strong>Static</strong>. ReScript types are erased after compilation and don't exist at runtime. Never worry about your types dragging down performance. You don't need type info during runtime; we report all the information (especially all the type errors) during compile time. Catch the bugs earlier!
- <strong>Sound</strong>. This is our biggest differentiator versus many other typed languages that compile to JavaScript. Our type system is guaranteed to <strong>never</strong> be wrong. Most type systems make a guess at the type of a value and show you a type in your editor that's sometime incorrect. We don't do that. We believe that a type system that is sometime incorrect can end up being dangerous due to expectation mismatches.
- <strong>Fast</strong>. Many developers underestimate how much of their project's build time goes into type checking. Our type checker is one of the fastest around.
- <strong>Inferred</strong>. You don't have to write down the types! ReScript can deduce them from their values. Yes, it might seem magical that we can deduce all of your program's types, without incorrectness, without your manual annotation, and do so quickly. Welcome to ReScript =).</p>
<p>The following sections explore more of our type system.</p>
<h2>Inference</h2>
<p>This let-binding doesn't contain any written type:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let score = 10
let add = (a, b) =&gt; a + b</p>
<pre class="codehilite"><code>```js
var score = 10;
function add(a, b) {
  return a + b | 0;
}
</code></pre>

<p></CodeTab></p>
<p>ReScript knows that <code>score</code> is an <code>int</code>, judging by the value <code>10</code>. This is called <strong>inference</strong>. Likewise, it also knows that the <code>add</code> function takes 2 <code>int</code>s and returns an <code>int</code>, judging from the <code>+</code> operator, which works on ints.</p>
<h2>Type Annotation</h2>
<p>But you can also optionally write down the type, aka annotate your value:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let score: int = 10</p>
<pre class="codehilite"><code>```js
var score = 10;
</code></pre>

<p></CodeTab></p>
<p>If the type annotation for <code>score</code> doesn't correspond to our inferred type for it, we'll show you an error during compilation time. We <strong>won't</strong> silently assume your type annotation is correct, unlike many other languages.</p>
<p>You can also wrap any expression in parentheses and annotate it:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let myInt = 5
let myInt: int = 5
let myInt = (5: int) + (4: int)
let add = (x: int, y: int) : int =&gt; x + y
let drawCircle = (~radius as r: int): circleType =&gt; /* code here */
</code></pre>

<pre class="codehilite"><code class="language-js">var myInt = 9;
function add(x, y) {
  return x + y | 0;
}
function drawCircle(r) {
  /* code here */
}
</code></pre>

<p></CodeTab></p>
<p>Note: in the last line, <code>(~radius as r: int)</code> is a labeled argument. More on this in the <a href="function.md">function</a> page.</p>
<h2>Type Alias</h2>
<p>You can refer to a type by a different name. They'll be equivalent:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type scoreType = int
let x: scoreType = 10</p>
<pre class="codehilite"><code>```js
var x = 10;
</code></pre>

<p></CodeTab></p>
<h2>Type Parameter (Aka Generic)</h2>
<p>Types can accept parameters, akin to generics in other languages. The parameters' names <strong>need</strong> to start with <code>'</code>.</p>
<p>The use-case of a parameterized type is to kill duplications. Before:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// this is a tuple of 3 items, explained next
type intCoordinates = (int, int, int)
type floatCoordinates = (float, float, float)</p>
<p>let a: intCoordinates = (10, 20, 20)
let b: floatCoordinates = (10.5, 20.5, 20.5)</p>
<pre class="codehilite"><code>```js
var a = [10, 20, 20];
var b = [10.5, 20.5, 20.5];
</code></pre>

<p></CodeTab></p>
<p>After:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type coordinates&lt;'a&gt; = ('a, 'a, 'a)</p>
<p>let a: coordinates<int> = (10, 20, 20)
let b: coordinates<float> = (10.5, 20.5, 20.5)</p>
<pre class="codehilite"><code>```js
var a = [10, 20, 20];
var b = [10.5, 20.5, 20.5];
</code></pre>

<p></CodeTab></p>
<p>Note that the above codes are just contrived examples for illustration purposes. Since the types are inferred, you could have just written:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let buddy = (10, 20, 20)</p>
<pre class="codehilite"><code>```js
var buddy = [10, 20, 20];
</code></pre>

<p></CodeTab></p>
<p>The type system infers that it's a <code>(int, int, int)</code>. Nothing else needed to be written down.</p>
<p>Type arguments appear in many places. Our <code>array&lt;'a&gt;</code> type is such a type that requires a type parameter.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res example
// inferred as</code>array<string>`
let greetings = ["hello", "world", "how are you"]</p>
<pre class="codehilite"><code>```js
// inferred as `array&lt;string&gt;`
var greetings = [&quot;hello&quot;, &quot;world&quot;, &quot;how are you&quot;];
</code></pre>

<p></CodeTab></p>
<p>If types didn't accept parameters, the standard library would need to define the types <code>arrayOfString</code>, <code>arrayOfInt</code>, <code>arrayOfTuplesOfInt</code>, etc. That'd be tedious.</p>
<p>Types can receive many arguments, and be composable.</p>
<!-- TODO: too early for this example -->

<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type result&lt;'a, 'b&gt; =
  | Ok('a)
  | Error('b)</p>
<p>type myPayload = {data: string}</p>
<p>type myPayloadResults&lt;'errorType&gt; = array<result\<myPayload, 'errorType>></p>
<p>let payloadResults: myPayloadResults<string> = [
  Ok({data: "hi"}),
  Ok({data: "bye"}),
  Error("Something wrong happened!")
]</p>
<pre class="codehilite"><code>```js
var payloadResults = [
  {
    TAG: /* Ok */0,
    _0: {data: &quot;hi&quot;}
  },
  {
    TAG: /* Ok */0,
    _0: {data: &quot;bye&quot;}
  },
  {
    TAG: /* Error */1,
    _0: &quot;Something wrong happened!&quot;
  }
];
</code></pre>

<p></CodeTab></p>
<h2>Recursive Types</h2>
<p>Just like a function, a type can reference itself within itself using <code>rec</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type rec person = {
  name: string,
  friends: array<person>
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Mutually Recursive Types</h2>
<p>Types can also be <em>mutually</em> recursive through <code>and</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type rec student = {taughtBy: teacher}
and teacher = {students: array<student>}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Type Escape Hatch</h2>
<p>ReScript's type system is robust and does not allow dangerous, unsafe stuff like implicit type casting, randomly guessing a value's type, etc. However, out of pragmatism, we expose a single escape hatch for you to "lie" to the type system:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">external myShadyConversion: myType1 =&gt; myType2 = &quot;%identity&quot;
</code></pre>

<pre class="codehilite"><code class="language-js">// Empty output
</code></pre>

<p></CodeTab></p>
<p>This declaration converts a <code>myType1</code> of your choice to <code>myType2</code> of your choice. You can use it like so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
external convertToFloat : int =&gt; float = "%identity"
let age = 10
let gpa = 2.1 +. convertToFloat(age)</p>
<pre class="codehilite"><code>```js
var age = 10;
var gpa = 2.1 + 10;
</code></pre>

<p></CodeTab></p>
<p>Obviously, do <strong>not</strong> abuse this feature. Use it tastefully when you're working with existing, overly dynamic JS code, for example.</p>
<p>More on externals <a href="external.md">here</a>.</p>
<p><strong>Note</strong>: this particular <code>external</code> is the only one that isn't preceded by a <code>@</code> <a href="attribute.md">attribute</a>.</p><h1>newcomer-examples</h1><hr />
<p>title: "Newcomer Examples"
description: "Quick examples for users new to ReScript"
canonical: "/docs/manual/latest/newcomer-examples"</p>
<hr />
<h1>Newcomer Examples</h1>
<!-- TODO: this whole page needs a revamp -->

<p>An example is worth a thousand words.</p>
<p>This section is dedicated to newcomers trying to figure out general idioms &amp; conventions. If you're a beginner who's got a good idea for an example, please suggest an edit!</p>
<h2>Use the <a href="null-undefined-option.md"><code>option</code> type</a></h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let possiblyNullValue1 = None
let possiblyNullValue2 = Some("Hello")</p>
<p>switch possiblyNullValue2 {
| None =&gt; Js.log("Nothing to see here.")
| Some(message) =&gt; Js.log(message)
}</p>
<pre class="codehilite"><code>```js
var possiblyNullValue1;
var possiblyNullValue2 = &quot;Hello&quot;;

if (possiblyNullValue2 !== undefined) {
  console.log(possiblyNullValue2);
} else {
  console.log(&quot;Nothing to see here.&quot;);
}
</code></pre>

<p></CodeTab></p>
<h2>Create a Parametrized Type</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type universityStudent = {gpa: float}</p>
<p>type response&lt;'studentType&gt; = {
  status: int,
  student: 'studentType,
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Creating a JS Object</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let student1 = {
  "name": "John",
  "age": 30,
}</p>
<pre class="codehilite"><code>```js
var student1 = {
  name: &quot;John&quot;,
  age: 30,
};
</code></pre>

<p></CodeTab></p>
<p>Or using <a href="record.md">record</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type payload = {
  name: string,
  age: int,
}</p>
<p>let student1 = {
  name: "John",
  age: 30,
}</p>
<pre class="codehilite"><code>```js
var student1 = {
  name: &quot;John&quot;,
  age: 30,
};
</code></pre>

<p></CodeTab></p>
<h2>Modeling a JS Module with Default Export</h2>
<p>See <a href="import-from-export-to-js.md#import-a-javascript-module-itself-es6-module-format">here</a>.</p>
<h2>Checking for JS nullable types using the <code>option</code> type</h2>
<p>For a function whose argument is passed a JavaScript value that's potentially <code>null</code> or <code>undefined</code>, it's idiomatic to convert it to an <code>option</code>. The conversion is done through the helper functions in ReScript's <a href="api/js/nullable#t"><code>Js.Nullable</code></a> module. In this case, <code>toOption</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let greetByName = (possiblyNullName) =&gt; {
  let optionName = Js.Nullable.toOption(possiblyNullName)
  switch optionName {
  | None =&gt; "Hi"
  | Some(name) =&gt; "Hello " ++ name
  }
}</p>
<pre class="codehilite"><code>```js
function greetByName(possiblyNullName) {
  if (possiblyNullName == null) {
    return &quot;Hi&quot;;
  } else {
    return &quot;Hello &quot; + possiblyNullName;
  }
}
</code></pre>

<p></CodeTab></p>
<p>This check compiles to <code>possiblyNullName == null</code> in JS, so checks for the presence of <code>null</code> or <code>undefined</code>.</p><h1>browser-support-polyfills</h1><hr />
<p>title: "Browser Support &amp; Polyfills"
description: "Note on browser support in ReScript"
canonical: "/docs/manual/latest/browser-support-polyfills"</p>
<hr />
<h1>Browser Support &amp; Polyfills</h1>
<p>ReScript compiles to JavaScript <strong>ES5</strong>, with the exception of optionally allowing to compile to ES6's module import &amp; export.</p>
<p>For <a href="https://caniuse.com/#search=typed%20array">old browsers</a>, you also need to polyfill TypedArray. The following standard library functions require it:</p>
<ul>
<li><code>Int64.float_of_bits</code></li>
<li><code>Int64.bits_of_float</code></li>
<li><code>Int32.float_of_bits</code></li>
<li><code>Int32.bits_of_float</code></li>
</ul>
<p>If you don't use these functions, you're fine. Otherwise, it'll be a runtime failure.</p><h1>primitive-types</h1><hr />
<p>title: "Primitive Types"
description: "Primitive Data Types in ReScript"
canonical: "/docs/manual/latest/primitive-types"</p>
<hr />
<h1>Primitive Types</h1>
<p>ReScript comes with the familiar primitive types like <code>string</code>, <code>int</code>, <code>float</code>, etc.</p>
<!-- TODO: doc unit -->

<h2>String</h2>
<p>ReScript <code>string</code>s are delimited using <strong>double</strong> quotes (single quotes are reserved for the character type below).</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let greeting = "Hello world!"
let multilineGreeting = "Hello
 world!"</p>
<pre class="codehilite"><code>```js
var greeting = &quot;Hello world!&quot;;
var multilineGreeting = &quot;Hello\n world!&quot;;
</code></pre>

<p></CodeTab></p>
<p>To concatenate strings, use <code>++</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let greetings = "Hello " ++ "world!"</p>
<pre class="codehilite"><code>```js
var greetings = &quot;Hello world!&quot;;
</code></pre>

<p></CodeTab></p>
<h3>String Interpolation</h3>
<p>There's a special syntax for string that allows</p>
<ul>
<li>multiline string just like before</li>
<li>no special character escaping</li>
<li>Interpolation</li>
</ul>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let name = "Joe"</p>
<p>let greeting = <code>Hello
World
👋
${name}</code></p>
<pre class="codehilite"><code>```js
var name = &quot;Joe&quot;;

var greeting = &quot;Hello\nWorld\n👋\n&quot; + name + &quot;\n&quot;;
</code></pre>

<p></CodeTab></p>
<p>This is just like JavaScript's backtick string interpolation, except without needing to escape special characters.</p>
<h3>Usage</h3>
<p>See the familiar <code>String</code> API in the <a href="api/js/string">API docs</a>. Since a ReScript string maps to a JavaScript string, you can mix &amp; match the string operations in all standard libraries.</p>
<h3>Tips &amp; Tricks</h3>
<p><strong>You have a good type system now!</strong> In an untyped language, you'd often overload the meaning of string by using it as:</p>
<ul>
<li>a unique id: <code>var BLUE_COLOR = "blue"</code></li>
<li>an identifier into a data structure: <code>var BLUE = "blue" var RED = "red" var colors = [BLUE, RED]</code></li>
<li>the name of an object field: <code>person["age"] = 24</code></li>
<li>an enum: <code>if (audio.canPlayType() === 'probably') {...}</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value">(ಠ_ಠ)</a></li>
<li>other crazy patterns you'll soon find horrible, after getting used to ReScript's alternatives.</li>
</ul>
<p>The more you overload the poor string type, the less the type system (or a teammate) can help you! ReScript provides concise, fast and maintainable types &amp; data structures alternatives to the use-cases above (e.g. variants, in a later section).</p>
<h2>Char</h2>
<p>ReScript has a type for a string with a single letter:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let firstLetterOfAlphabet = 'a'</p>
<pre class="codehilite"><code>```js
var firstLetterOfAlphabet = /* &quot;a&quot; */97;
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: Char doesn't support Unicode or UTF-8 and is therefore not recommended.</p>
<p>To convert a String to a Char, use <code>String.get("a", 0)</code>. To convert a Char to a String, use <code>String.make(1, 'a')</code>.</p>
<h2>Regular Expression</h2>
<p>ReScript regular expressions compile cleanly to their JavaScript counterpart:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let r = %re("/b/g")</p>
<pre class="codehilite"><code>```js
var r = /b/g;
</code></pre>

<p></CodeTab></p>
<p>A regular expression like the above has the type <code>Js.Re.t</code>. The <a href="api/js/re">Js.Re</a> module contains the regular expression helpers you have seen in JS.</p>
<h2>Boolean</h2>
<p>A ReScript boolean has the type <code>bool</code> and can be either <code>true</code> or <code>false</code>. Common operations:</p>
<ul>
<li><code>&amp;&amp;</code>: logical and.</li>
<li><code>||</code>: logical or.</li>
<li><code>!</code>: logical not.</li>
<li><code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></li>
<li><code>==</code>: structural equal, compares data structures deeply. <code>(1, 2) == (1, 2)</code> is <code>true</code>. Convenient, but use with caution.</li>
<li><code>===</code>: referential equal, compares shallowly. <code>(1, 2) === (1, 2)</code> is <code>false</code>. <code>let myTuple = (1, 2); myTuple === myTuple</code> is <code>true</code>.</li>
<li><code>!=</code>: structural unequal.</li>
<li><code>!==</code>: referential unequal.</li>
</ul>
<p>ReScript's <code>true/false</code> compiles into a JavaScript <code>true/false</code>.</p>
<h2>Integers</h2>
<p>32-bits, truncated when necessary. We provide the usual operations on them: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc. See <a href="api/js/int">Js.Int</a> for helper functions.</p>
<p><strong>Be careful when you bind to JavaScript numbers!</strong> Since ReScript integers have a much smaller range than JavaScript numbers, data might get lost when dealing with large numbers. In those cases it’s much safer to bind the numbers as <strong>float</strong>. Be extra mindful of this when binding to JavaScript Dates and their epoch time.</p>
<p>To improve readability, you may place underscores in the middle of numeric literals such as <code>1_000_000</code>. Note that underscores can be placed anywhere within a number, not just every three digits.</p>
<h2>Floats</h2>
<p>Float requires other operators: <code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code>, etc. Like <code>0.5 +. 0.6</code>. See <a href="api/js/float">Js.Float</a> for helper functions.</p>
<p>As with integers, you may use underscores within literals to improve readability.</p>
<h2>Unit</h2>
<p>The <code>unit</code> type indicates the absence of a specific value. It has only a single value, <code>()</code>, which acts as a placeholder when no other value exists or is needed. It compiles to JavaScript's <code>undefined</code> and resembles the <code>void</code> type in languages such as C++. What's the point of such a type?</p>
<p>Consider the <code>Math.random</code> function. Its type signature is <code>unit =&gt; float</code>, which means it receives a <code>unit</code> as input and calculates a random <code>float</code> as output. You use the function like this - <code>let x = Math.random()</code>. Notice <code>()</code> as the first and only function argument.</p>
<p>Imagine a simplified <code>Console.log</code> function that prints a message. Its type signature is <code>string =&gt; unit</code> and you'd use it like this <code>Console.log("Hello!")</code>. It takes a string as input, prints it, and then returns nothing useful. When <code>unit</code> is the output of a function it means the function performs some kind of side-effect. </p>
<h2>Unknown</h2>
<p>The <code>unknown</code> type represents values with contents that are a mystery or are not 100% guaranteed to be what you think they are. It provides type-safety when interacting with data received from an untrusted source. For example, suppose an external function is supposed to return a <code>string</code>. It might. But if the documentation is not accurate or the code has bugs, the function could return <code>null</code>, an <code>array</code>, or something else you weren't expecting.</p>
<p>The ReScript type system helps you avoid run-time crashes and unpredicatable behavior by preventing you from using <code>unknown</code> in places that expect a <code>string</code> or <code>int</code> or some other type. The ReScript core libraries also provide utility functions to help you inspect <code>unknown</code> values and access their contents. In some cases you may need a JSON parsing library to convert <code>unknown</code> values to types you can safely use.   </p>
<p>Consider using <code>unknown</code> when receiving data from <a href="/docs/manual/latest/bind-to-js-function">external JavaScript functions</a></p><h1>import-from-export-to-js</h1><hr />
<p>title: "Import from / Export to JS"
description: "Importing / exporting JS module content in ReScript"
canonical: "/docs/manual/latest/import-from-export-to-js"</p>
<hr />
<h1>Import from/Export to JS</h1>
<p>You've seen how ReScript's idiomatic <a href="import-export.md">Import &amp; Export</a> works. This section describes how we work with importing stuff from JavaScript and exporting stuff for JavaScript consumption.</p>
<p><strong>Note</strong>: due to JS ecosystem's module compatibility issues, our advice of keeping your ReScript file's compiled JS output open in a tab applies here <strong>more than ever</strong>, as you don't want to subtly output the wrong JS module import/export code, on top of having to deal with Babel/Webpack/Jest/Node's CommonJS \&lt;-&gt; ES6 compatibility shims.</p>
<p>In short: <strong>make sure your bindings below output what you'd have manually written in JS</strong>.</p>
<h2>Output Format</h2>
<p>We support 2 JavaScript import/export formats:</p>
<ul>
<li>CommonJS: <code>require('myFile')</code> and <code>module.exports = ...</code>.</li>
<li>ES6 modules: <code>import * from 'MyReScriptFile'</code> and <code>export let ...</code>.</li>
</ul>
<p>The format is <a href="build-configuration.md#package-specs">configurable in via <code>rescript.json</code></a>.</p>
<h2>Import From JavaScript</h2>
<h3>Import a JavaScript Module's Named Export</h3>
<p>Use the <code>module</code> <a href="external.md">external</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output (CommonJS)", "JS Output (ES6)"]}></p>
<p>```res example
// Import nodejs' path.dirname
@module("path") external dirname: string =&gt; string = "dirname"
let root = dirname("/User/github") // returns "User"</p>
<pre class="codehilite"><code>```js
var Path = require(&quot;path&quot;);
var root = Path.dirname(&quot;/User/github&quot;);
</code></pre>

<pre class="codehilite"><code class="language-js">import * as Path from &quot;path&quot;;
var root = Path.dirname(&quot;/User/github&quot;);
</code></pre>

<p></CodeTab></p>
<p>Here's what the <code>external</code> does:</p>
<ul>
<li><code>@module("path")</code>: pass the name of the JS module; in this case, <code>"path"</code>. The string can be anything: <code>"./src/myJsFile"</code>, <code>"@myNpmNamespace/myLib"</code>, etc.</li>
<li><code>external</code>: the general keyword for declaring a value that exists on the JS side.</li>
<li><code>dirname</code>: the binding name you'll use on the ReScript side.</li>
<li><code>string =&gt; string</code>: the type signature of <code>dirname</code>. Mandatory for <code>external</code>s.</li>
<li><code>= "dirname"</code>: the name of the variable inside the <code>path</code> JS module. There's repetition in writing the first and second <code>dirname</code>, because sometime the binding name you want to use on the ReScript side is different than the variable name the JS module exported.</li>
</ul>
<h3>Import a JavaScript Module As a Single Value</h3>
<p>By omitting the string argument to <code>module</code>, you bind to the whole JS module:</p>
<p><CodeTab labels={["ReScript", "JS Output (CommonJS)", "JS Output (ES6)"]}></p>
<p>```res example
@module external leftPad: (string, int) =&gt; string = "./leftPad"
let paddedResult = leftPad("hi", 5)</p>
<pre class="codehilite"><code>```js
var LeftPad = require(&quot;./leftPad&quot;);
var paddedResult = LeftPad(&quot;hi&quot;, 5);
</code></pre>

<pre class="codehilite"><code class="language-js">import * as LeftPad from &quot;./leftPad&quot;;
var paddedResult = LeftPad(&quot;hi&quot;, 5);
</code></pre>

<p></CodeTab></p>
<p>Depending on whether you're compiling ReScript to CommonJS or ES6 module, <strong>this feature will generate subtly different code</strong>. Please check both output tabs to see the difference. The ES6 output here would be wrong!</p>
<h3>Import an ES6 Default Export</h3>
<p>Use the value <code>"default"</code> on the right hand side:</p>
<p><CodeTab labels={["ReScript", "JS Output (ES6)"]}></p>
<p>```res example
@module("./student") external studentName: string = "default"
Js.log(studentName)</p>
<pre class="codehilite"><code>```js
import Student from &quot;./student&quot;;
var studentName = Student;
</code></pre>

<p></CodeTab></p>
<h2>Dynamic Import</h2>
<p>Leveraging JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">dynamic <code>import</code></a> to reduce bundle size and lazy load code as needed is easy in ReScript. It's also a little bit more convenient than in regular JavaScript because you don't need to keep track of file paths manually with ReScript's module system.</p>
<h3>Dynamically Importing Parts of a Module</h3>
<p>Use the <code>Js.import</code> function to dynamically import a specific part of a module. Put whatever <code>let</code> binding you want to import in there, and you'll get a <code>promise</code> back resolving to that specific binding.</p>
<p>Let's look at an example. Imagine the following file <code>MathUtils.res</code>:</p>
<pre class="codehilite"><code class="language-rescript">let add = (a, b) =&gt; a + b
let sub = (a, b) =&gt; a - b
</code></pre>

<p>Now let's dynamically import the add function in another module, e.g. <code>App.res</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output (ES6)"]}></p>
<pre class="codehilite"><code class="language-rescript">// App.res
let main = async () =&gt; {
  let add = await Js.import(MathUtils.add)
  let onePlusOne = add(1, 1)

  Console.log(onePlusOne)
}
</code></pre>

<pre class="codehilite"><code class="language-javascript">async function main() {
  var add = await import(&quot;./MathUtils.mjs&quot;).then(function(m) {
    return m.add;
  });

  var onePlusOne = add(1, 1);
  console.log(onePlusOne);
}
</code></pre>

<p></CodeTab></p>
<h3>Dynamically Importing an Entire Module</h3>
<p>The syntax for importing a whole module looks a little different, since we are operating on the module syntax level; instead of using <code>Js.import</code>, you may simply <code>await</code> the module itself:
<CodeTab labels={["ReScript", "JS Output (ES6)"]}></p>
<pre class="codehilite"><code class="language-rescript">// App.res
let main = async () =&gt; {
  module Utils = await MathUtils

  let twoPlusTwo = Utils.add(2, 2)
  Console.log(twoPlusTwo)
}
</code></pre>

<pre class="codehilite"><code class="language-javascript">async function main() {
  var Utils = await import(&quot;./MathUtils.mjs&quot;);

  var twoPlusTwo = Utils.add(2, 2);
  console.log(twoPlusTwo);
}
</code></pre>

<p></CodeTab></p>
<h2>Export To JavaScript</h2>
<h3>Export a Named Value</h3>
<p>As mentioned in ReScript's idiomatic <a href="import-export.md">Import &amp; Export</a>, every let binding and module is exported by default to other ReScript modules (unless you use a <code>.resi</code> <a href="module#signatures">interface file</a>). If you open up the compiled JS file, you'll see that these values can also directly be used by a <em>JavaScript</em> file too.</p>
<h3>Export an ES6 Default Value</h3>
<p>If your JS project uses ES6 modules, you're likely exporting &amp; importing some default values:</p>
<pre class="codehilite"><code class="language-js">// student.js
export default name = &quot;Al&quot;;
</code></pre>

<pre class="codehilite"><code class="language-js">// teacher.js
import studentName from 'student.js';
</code></pre>

<p>A JavaScript default export is really just syntax sugar for a named export implicitly called <code>default</code> (now you know!). So to export a default value from ReScript, you can just do:</p>
<p><CodeTab labels={["ReScript", "JS Output (CommonJS)", "JS Output (ES6)"]}></p>
<p>```res example
// ReScriptStudent.res
let default = "Bob"</p>
<pre class="codehilite"><code>```js
var $$default = &quot;Bob&quot;;

exports.$$default = $$default;
exports.default = $$default;
// informal transpiler-compatible marker of a default export compiled from ES6
exports.__esModule = true;
</code></pre>

<pre class="codehilite"><code class="language-js">var $$default = &quot;Bob&quot;;

export {
  $$default,
  $$default as default,
}
</code></pre>

<p></CodeTab></p>
<p>You can then import this default export as usual on the JS side:</p>
<pre class="codehilite"><code class="language-js">// teacher2.js
import studentName from 'ReScriptStudent.js';
</code></pre>

<p>If your JavaScript's ES6 default import is transpiled by Babel/Webpack/Jest into CommonJS <code>require</code>s, we've taken care of that too! See the CommonJS output tab for <code>__esModule</code>.</p><h1>mutation</h1><hr />
<p>title: "Mutation"
description: "Imperative and mutative programming capabilities in ReScript"
canonical: "/docs/manual/latest/mutation"</p>
<hr />
<h1>Mutation</h1>
<p>ReScript has great traditional imperative &amp; mutative programming capabilities. You should use these features sparingly, but sometimes they allow your code to be more performant and written in a more familiar pattern.</p>
<h2>Mutate Let-binding</h2>
<p>Let-bindings are immutable, but you can wrap it with a <code>ref</code>, exposed as a record with a single mutable field in the standard library:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let myValue = ref(5)</p>
<pre class="codehilite"><code>```js
var myValue = {
  contents: 5
};
</code></pre>

<p></CodeTab></p>
<h2>Usage</h2>
<p>You can get the actual value of a <code>ref</code> box through accessing its <code>contents</code> field:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let five = myValue.contents // 5</p>
<pre class="codehilite"><code>```js
var five = myValue.contents;
</code></pre>

<p></CodeTab></p>
<p>Assign a new value to <code>myValue</code> like so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
myValue.contents = 6</p>
<pre class="codehilite"><code>```js
myValue.contents = 6;
</code></pre>

<p></CodeTab></p>
<p>We provide a syntax sugar for this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
myValue := 6</p>
<pre class="codehilite"><code>```js
myValue.contents = 6;
</code></pre>

<p></CodeTab></p>
<p>Note that the previous binding <code>five</code> stays <code>5</code>, since it got the underlying item on the <code>ref</code> box, not the <code>ref</code> itself.</p>
<p><strong>Note</strong>: you might see in the JS output tabs above that <code>ref</code> allocates an object. Worry not; local, non-exported <code>ref</code>s allocations are optimized away.</p>
<h2>Tip &amp; Tricks</h2>
<p>Before reaching for <code>ref</code>, know that you can achieve lightweight, local "mutations" through <a href="let-binding.md#binding-shadowing">overriding let bindings</a>.</p><h1>external</h1><hr />
<p>title: "External (Bind to Any JS Library)"
description: "The external keyword"
canonical: "/docs/manual/latest/external"</p>
<hr />
<h1>External (Bind to Any JS Library)</h1>
<p><code>external</code> is the primary ReScript features for bringing in and using JavaScript values.</p>
<p><code>external</code> is like a let binding, but:
- The right side of <code>=</code> isn't a value; it's the name of the JS value you're referring to.
- The type for the binding is mandatory, since we need to know what the type of that JS value is.
- Can only exist at the top level of a file or module.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val external setTimeout: (unit =&gt; unit, int) =&gt; float = "setTimeout"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>There are several kinds of <code>external</code>s, differentiated and/or augmented through the <a href="attribute.md">attribute</a> they carry. This page deals with the general, shared mechanism behind most <code>external</code>s. The different are documented in their respective pages later. A few notable ones:</p>
<ul>
<li><code>@val</code>, <code>@scope</code>: <a href="bind-to-global-js-values">bind to global JS values</a>.</li>
<li><code>@module</code>: <a href="import-from-export-to-js">bind to JS imported/exported values</a>.</li>
<li><code>@send</code>: <a href="bind-to-js-function">bind to JS methods</a>.</li>
</ul>
<p>You can also use our <a href="/syntax-lookup">Syntax Lookup</a> tool to find them.</p>
<p>Related: see also our <a href="interop-cheatsheet#list-of-decorators">list of external decorators</a>.</p>
<h2>Usage</h2>
<p>Once declared, you can use an <code>external</code> as a normal value, just like a let binding.</p>
<h2>Tips &amp; Tricks</h2>
<p><code>external</code> + ReScript objects are a wonderful combination for quick prototyping. Check the JS output tab:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// The type of document is just some random type 'a
// that we won't bother to specify
@val external document: 'a = "document"</p>
<p>// call a method
document<a href="." title="mouseup&quot;, _event =&gt; {   Js.log(&quot;clicked!">"addEventListener"</a>
})</p>
<p>// get a property
let loc = document["location"]</p>
<p>// set a property
document["location"]["href"] = "rescript-lang.org"</p>
<pre class="codehilite"><code>```js
document.addEventListener(&quot;mouseup&quot;, function(_event) {
  console.log(&quot;clicked!&quot;);
});

var loc = document.location;

document.location.href = &quot;rescript-lang.org&quot;;
</code></pre>

<p></CodeTab></p>
<p>We've specified <code>document</code>'s type as <code>'a</code>, aka a placeholder type that's polymorphic. Any value can be passed there, so you're not getting much type safety (except the inferences at various call sites). However, this is excellent for quickly getting started using a JavaScript library in ReScript <strong>without needing the equivalent of a repository of typed bindings</strong> like TypeScript's <code>DefinitelyTyped</code> repo.</p>
<p>However, if you want to more rigidly bind to the JavaScript library you want, keep reading the next few interop pages.</p>
<h2>Performance &amp; Output Readability</h2>
<p><code>external</code>s declarations are inlined into their callers during compilation, <strong>and completely disappear from the JS output</strong>. This means any time you use one, you can be sure that you're not incurring extra JavaScript \&lt;-&gt; ReScript conversion cost.</p>
<p>Additionally, no extra ReScript-specific runtime is better for output readability.</p>
<blockquote>
<p><strong>Note:</strong> do also use <code>external</code>s and the <code>@blabla</code> attributes in the interface files. Otherwise the inlining won't happen.</p>
</blockquote>
<h2>Design Decisions</h2>
<p>ReScript takes interoperating with existing code very seriously. Our type system has very strong guarantees. However, such strong feature also means that, without a great interop system, it'd be very hard to gradually convert a codebase over to ReScript. Fortunately, our interop are comprehensive and cooperate very well with most existing JavaScript code.</p>
<p>The combination of a sound type system + great interop means that we get the benefits of a traditional gradual type system regarding incremental codebase coverage &amp; conversion, without the downside of such gradual type system: complex features to support existing patterns, slow analysis, diminishing return in terms of type coverage, etc.</p><h1>let-binding</h1><hr />
<p>title: "Let Binding"
description: "Let binding syntax for binding to values in ReScript"
canonical: "/docs/manual/latest/let-binding"</p>
<hr />
<h1>Let Binding</h1>
<p>A "let binding", in other languages, might be called a "variable declaration". <code>let</code> <em>binds</em> values to names. They can be seen and referenced by code that comes <em>after</em> them.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let greeting = "hello!"
let score = 10
let newScore = 10 + score</p>
<pre class="codehilite"><code>```js
var greeting = &quot;hello!&quot;;
var score = 10;
var newScore = 20;
</code></pre>

<p></CodeTab></p>
<h2>Block Scope</h2>
<p>Bindings can be scoped through <code>{}</code>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p><code>``res example
let message = {
  let part1 = "hello"
  let part2 = "world"
  part1 ++ " " ++ part2
}
//</code>part1<code>and</code>part2` not accessible here!</p>
<pre class="codehilite"><code>```js
var message = &quot;hello world&quot;;
</code></pre>

<p></CodeTab></p>
<p>The value of the last line of a scope is implicitly returned.</p>
<h3>Design Decisions</h3>
<p>ReScript's <code>if</code>, <code>while</code> and functions all use the same block scoping mechanism. The code below works <strong>not</strong> because of some special "if scope"; but simply because it's the same scope syntax and feature you just saw:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">if displayGreeting {
  let message = &quot;Enjoying the docs so far?&quot;
  Js.log(message)
}
// `message` not accessible here!
</code></pre>

<pre class="codehilite"><code class="language-js">if (displayGreeting) {
  console.log(&quot;Enjoying the docs so far?&quot;);
}
</code></pre>

<p></CodeTab></p>
<h2>Bindings Are Immutable</h2>
<p>Let bindings are "immutable", aka "cannot change". This helps our type system deduce and optimize much more than other languages (and in turn, help you more).</p>
<h2>Binding Shadowing</h2>
<p>The above restriction might sound unpractical at first. How would you change a value then? Usually, 2 ways:</p>
<p>The first is to realize that many times, what you want isn't to mutate a variable's value. For example, this JavaScript pattern:</p>
<pre class="codehilite"><code class="language-js">var result = 0;
result = calculate(result);
result = calculateSomeMore(result);
</code></pre>

<p>...is really just to comment on intermediate steps. You didn't need to mutate <code>result</code> at all! You could have just written this JS:</p>
<pre class="codehilite"><code class="language-js">var result1 = 0;
var result2 = calculate(result1);
var result3 = calculateSomeMore(result2);
</code></pre>

<p>In ReScript, this obviously works too:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let result1 = 0
let result2 = calculate(result1)
let result3 = calculateSomeMore(result2)
</code></pre>

<pre class="codehilite"><code class="language-js">var result1 = 0;
var result2 = calculate(0);
var result3 = calculateSomeMore(result2);
</code></pre>

<p></CodeTab></p>
<p>Additionally, reusing the same let binding name overshadows the previous bindings with the same name. So you can write this too:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let result = 0
let result = calculate(result)
let result = calculateSomeMore(result)
</code></pre>

<pre class="codehilite"><code class="language-js">var result = calculate(0);
var result$1 = calculateSomeMore(result);
</code></pre>

<p></CodeTab></p>
<p>(Though for the sake of clarity, we don't recommend this).</p>
<p>As a matter of fact, even this is valid code:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let result = "hello"
Console.log(result) // prints "hello"
let result = 1
Console.log(result) // prints 1</p>
<pre class="codehilite"><code>```js
var result = 1;
console.log(&quot;hello&quot;);
console.log(1);
</code></pre>

<p></CodeTab></p>
<p>The binding you refer to is whatever's the closest upward. No mutation here!
If you need <em>real</em> mutation, e.g. passing a value around, have it modified by many pieces of code, we provide a slightly heavier <a href="mutation.md">mutation feature</a>.</p>
<h2>Private let bindings</h2>
<p>Private let bindings are introduced in the release <a href="https://rescript-lang.org/blog/bucklescript-release-7-2">7.2</a>.</p>
<p>In the module system, everything is public by default,
the only way to hide some values is by providing a separate signature to
list public fields and their types:</p>
<pre class="codehilite"><code class="language-res">module A: {
  let b: int
} = {
  let a = 3
  let b = 4
}
</code></pre>

<p><code>%%private</code> gives you an option to mark private fields directly</p>
<pre class="codehilite"><code class="language-res">module A = {
  %%private(let a = 3)
  let b = 4
}
</code></pre>

<p><code>%%private</code> also applies to file level modules, so in some cases,
users do not need to provide a separate interface file just to hide some particular values.</p>
<p>Note interface files are still recommended as a general best practice since they give you better
separate compilation units and also they're better for documentation.</p>
<p>Still, <code>%%private</code> is useful in the following scenarios:</p>
<ul>
<li>
<p><strong>Code generators.</strong> Some code generators want to hide some values but it is sometimes very hard or time consuming for code generators to synthesize the types for public fields.</p>
</li>
<li>
<p><strong>Quick prototyping.</strong> During prototyping, we still want to hide some values, but the interface file is not stable yet, <code>%%private</code> provide you such convenience.</p>
</li>
</ul><h1>record</h1><hr />
<p>title: "Record"
description: "Record types in ReScript"
canonical: "/docs/manual/latest/record"</p>
<hr />
<h1>Record</h1>
<p>Records are like JavaScript objects but:</p>
<ul>
<li>are immutable by default</li>
<li>have fixed fields (not extensible)</li>
</ul>
<h2>Type Declaration</h2>
<p>A record needs a mandatory type declaration:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
type person = {
  age: int,
  name: string,
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Creation</h2>
<p>To create a <code>person</code> record (declared above):</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let me = {
  age: 5,
  name: "Big ReScript"
}</p>
<pre class="codehilite"><code>```js
var me = {
  age: 5,
  name: &quot;Big ReScript&quot;
};
</code></pre>

<p></CodeTab></p>
<p>When you create a new record value, ReScript tries to find a record type declaration that conforms to the shape of the value. So the <code>me</code> value here is inferred as of type <code>person</code>.</p>
<p>The type is found by looking above the <code>me</code> value. <strong>Note</strong>: if the type instead resides in another file or module, you need to explicitly indicate which file or module it is:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// School.res
type person = {age: int, name: string}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Example.res

let me: School.person = {age: 20, name: &quot;Big ReScript&quot;}
/* or */
let me2 = {School.age: 20, name: &quot;Big ReScript&quot;}
</code></pre>

<pre class="codehilite"><code class="language-js">var me = {
  age: 20,
  name: &quot;Big ReScript&quot;
};
var me2 = {
  age: 20,
  name: &quot;Big ReScript&quot;
};
</code></pre>

<p></CodeTab></p>
<p>In both <code>me</code> and <code>me2</code> the record definition from <code>School</code> is found. The first one, <code>me</code> with the regular type annotation, is preferred.</p>
<h2>Access</h2>
<p>Use the familiar dot notation:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let name = me.name</p>
<pre class="codehilite"><code>```js
var name = &quot;Big ReScript&quot;;
</code></pre>

<p></CodeTab></p>
<h2>Immutable Update</h2>
<p>New records can be created from old records with the <code>...</code> spread operator. The original record isn't mutated.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let meNextYear = {...me, age: me.age + 1}</p>
<pre class="codehilite"><code>```js
var meNextYear = {
  age: 21,
  name: &quot;Big ReScript&quot;
};
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: spread cannot add new fields to the record value, as a record's shape is fixed by its type.</p>
<h2>Mutable Update</h2>
<p>Record fields can optionally be mutable. This allows you to efficiently update those fields in-place with the <code>=</code> operator.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  name: string,
  mutable age: int
}</p>
<p>let baby = {name: "Baby ReScript", age: 5}
baby.age = baby.age + 1 // <code>baby.age</code> is now 6. Happy birthday!</p>
<pre class="codehilite"><code>```js
var baby = {
  name: &quot;Baby ReScript&quot;,
  age: 5
};

baby.age = baby.age + 1 | 0;
</code></pre>

<p></CodeTab></p>
<p>Fields not marked with <code>mutable</code> in the type declaration cannot be mutated.</p>
<h2>JavaScript Output</h2>
<p>ReScript records compile to straightforward JavaScript objects; see the various JS output tabs above.</p>
<h2>Optional Record Fields</h2>
<p>ReScript <a href="/blog/release-10-0-0#experimental-optional-record-fields"><code>v10</code></a> introduced optional record fields. This means that you can define fields that can be omitted when creating the record. It looks like this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  age: int,
  name?: string
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>Notice how <code>name</code> has a suffixed <code>?</code>. That means that the field itself is <em>optional</em>.</p>
<h3>Creation</h3>
<p>You can omit any optional fields when creating a record. Not setting an optional field will default the field's value to <code>None</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  age: int,
  name?: string
}</p>
<p>let me = {
  age: 5,
  name: "Big ReScript"
}</p>
<p>let friend = {
  age: 7
}</p>
<pre class="codehilite"><code>```js
var me = {
  age: 5,
  name: &quot;Big ReScript&quot;
};

var friend = {
  age: 7
};
</code></pre>

<p></CodeTab></p>
<p>This has consequences for pattern matching, which we'll expand a bit on soon.</p>
<h2>Immutable Update</h2>
<p>Updating an optional field via an immutable update above lets you set that field value without needing to care whether it's optional or not.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  age: int,
  name?: string
}</p>
<p>let me = {
  age: 123,
  name: "Hello"
}</p>
<p>let withoutName = {
  ...me,
  name: "New Name"
}</p>
<pre class="codehilite"><code>```js
import * as Caml_obj from &quot;./stdlib/caml_obj.js&quot;;

var me = {
  age: 123,
  name: &quot;Hello&quot;
};

var newrecord = Caml_obj.obj_dup(me);

newrecord.name = &quot;New Name&quot;;

var withoutName = newrecord;
</code></pre>

<p></CodeTab></p>
<p>However, if you want to set the field to an optional value, you prefix that value with <code>?</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  age: int,
  name?: string
}</p>
<p>let me = {
  age: 123,
  name: "Hello"
}</p>
<p>let maybeName = Some("My Name")</p>
<p>let withoutName = {
  ...me,
  name: ?maybeName
}</p>
<pre class="codehilite"><code>```js
import * as Caml_obj from &quot;./stdlib/caml_obj.js&quot;;

var me = {
  age: 123,
  name: &quot;Hello&quot;
};

var maybeName = &quot;My Name&quot;;

var newrecord = Caml_obj.obj_dup(me);

newrecord.name = maybeName;

var withoutName = newrecord;
</code></pre>

<p></CodeTab></p>
<p>You can unset an optional field's value via that same mechanism by setting it to <code>?None</code>.</p>
<h3>Pattern Matching on Optional Fields</h3>
<p><a href="pattern-matching-destructuring">Pattern matching</a>, one of ReScript's most important features, has two caveats when you deal with optional fields.</p>
<p>When matching on the value directly, it's an <code>option</code>. Example:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type person = {
  age: int,
  name?: string,
}

let me = {
  age: 123,
  name: &quot;Hello&quot;,
}

let isRescript = switch me.name {
| Some(&quot;ReScript&quot;) =&gt; true
| Some(_) | None =&gt; false
}
</code></pre>

<pre class="codehilite"><code class="language-js">var isRescript;

isRescript = &quot;Hello&quot; === &quot;ReScript&quot; ? true : false;

var me = {
  age: 123,
  name: &quot;Hello&quot;
};
</code></pre>

<p></CodeTab></p>
<p>But, when matching on the field as part of the general record structure, it's treated as the underlying, non-optional value:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type person = {
  age: int,
  name?: string,
}

let me = {
  age: 123,
  name: &quot;Hello&quot;,
}

let isRescript = switch me {
| {name: &quot;ReScript&quot;} =&gt; true
| _ =&gt; false
}
</code></pre>

<pre class="codehilite"><code class="language-js">var isRescript;

isRescript = &quot;Hello&quot; === &quot;ReScript&quot; ? true : false;

var me = {
  age: 123,
  name: &quot;Hello&quot;
};
</code></pre>

<p></CodeTab></p>
<p>Sometimes you <em>do</em> want to know whether the field was set or not. You can tell the pattern matching engine about that by prefixing your option match with <code>?</code>, like this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type person = {
  age: int,
  name?: string,
}

let me = {
  age: 123,
  name: &quot;Hello&quot;,
}

let nameWasSet = switch me {
| {name: ?None} =&gt; false
| {name: ?Some(_)} =&gt; true
}
</code></pre>

<pre class="codehilite"><code class="language-js">var nameWasSet = true;

var me = {
  age: 123,
  name: &quot;Hello&quot;
};
</code></pre>

<p></CodeTab></p>
<h2>Record Type Spread</h2>
<p>In ReScript v11, you can now spread one or more record types into a new record type. It looks like this:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  id: string,
  name: string,
}

type b = {
  age: int
}

type c = {
  ...a,
  ...b,
  active: bool
}
</code></pre>

<p><code>type c</code> will now be:</p>
<pre class="codehilite"><code class="language-rescript">type c = {
  id: string,
  name: string,
  age: int,
  active: bool,
}
</code></pre>

<p>Record type spreads act as a 'copy-paste' mechanism for fields from one or more records into a new record. This operation inlines the fields from the spread records directly into the new record definition, while preserving their original properties, such as whether they are optional or mandatory. It's important to note that duplicate field names are not allowed across the records being spread, even if the fields have the same type.</p>
<h2>Record Type Coercion</h2>
<p>Record type coercion gives us more flexibility when passing around records in our application code. In other words, we can now coerce a record <code>a</code> to be treated as a record <code>b</code> at the type level, as long as the original record <code>a</code> contains the same set of fields in <code>b</code>. Here's an example:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  name: string,
  age: int,
}

type b = {
  name: string,
  age: int,
}

let nameFromB = (b: b) =&gt; b.name

let a: a = {
  name: &quot;Name&quot;,
  age: 35,
}

let name = nameFromB(a :&gt; b)
</code></pre>

<p>Notice how we <em>coerced</em> the value <code>a</code> to type <code>b</code> using the coercion operator <code>:&gt;</code>. This works because they have the same record fields. This is purely at the type level, and does not involve any runtime operations.</p>
<p>Additionally, we can also coerce records from <code>a</code> to <code>b</code> whenever <code>a</code> is a super-set of <code>b</code> (i.e. <code>a</code> containing all the fields of <code>b</code>, and more). The same example as above, slightly altered:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  id: string,
  name: string,
  age: int,
  active: bool,
}

type b = {
  name: string,
  age: int,
}

let nameFromB = (b: b) =&gt; b.name

let a: a = {
  id: &quot;1&quot;,
  name: &quot;Name&quot;,
  age: 35,
  active: true,
}

let name = nameFromB(a :&gt; b)
</code></pre>

<p>Notice how <code>a</code> now has more fields than <code>b</code>, but we can still coerce <code>a</code> to <code>b</code> because <code>b</code> has a subset of the fields of <code>a</code>.</p>
<p>In combination with <a href="/docs/manual/latest/record#optional-record-fields">optional record fields</a>, one may coerce a mandatory field of an <code>option</code> type to an optional field:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  name: string,

  // mandatory, but explicitly typed as option&lt;int&gt;
  age: option&lt;int&gt;,
}

type b = {
  name: string,
  // optional field
  age?: int,
}

let nameFromB = (b: b) =&gt; b.name

let a: a = {
  name: &quot;Name&quot;,
  age: Some(35),
}

let name = nameFromB(a :&gt; b)
</code></pre>

<h2>Tips &amp; Tricks</h2>
<h3>Record Types Are Found By Field Name</h3>
<p>With records, you <strong>cannot</strong> say "I'd like this function to take any record type, as long as they have the field <code>age</code>". The following <strong>won't work as intended</strong>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type person = {age: int, name: string}
type monster = {age: int, hasTentacles: bool}

let getAge = (entity) =&gt; entity.age
</code></pre>

<pre class="codehilite"><code class="language-js">function getAge(entity) {
  return entity.age;
}
</code></pre>

<p></CodeTab></p>
<p>Instead, <code>getAge</code> will infer that the parameter <code>entity</code> must be of type <code>monster</code>, the closest record type with the field <code>age</code>. The following code's last line fails:</p>
<pre class="codehilite"><code class="language-res">let kraken = {age: 9999, hasTentacles: true}
let me = {age: 5, name: &quot;Baby ReScript&quot;}

getAge(kraken)
getAge(me) // type error!
</code></pre>

<p>The type system will complain that <code>me</code> is a <code>person</code>, and that <code>getAge</code> only works on <code>monster</code>. If you need such capability, use ReScript objects, described <a href="object.md">here</a>.</p>
<h3>Optional Fields in Records Can Be Useful for Bindings</h3>
<p>Many JavaScript APIs tend to have large configuration objects that can be a bit annoying to model as records, since you previously always needed to specify all record fields when creating a record. </p>
<p>Optional record fields, introduced in <a href="/blog/release-10-0-0#experimental-optional-record-fields"><code>v10</code></a>, is intended to help with this. Optional fields will let you avoid having to specify all fields, and let you just specify the one's you care about. A significant improvement in ergonomics for bindings and other APIs with for example large configuration objects.</p>
<h2>Design Decisions</h2>
<p>After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.</p>
<ol>
<li>The truth is that most of the times in your app, your data's shape is actually fixed, and if it's not, it can potentially be better represented as a combination of variant (introduced next) + record instead.</li>
<li>Since a record type is resolved through finding that single explicit type declaration (we call this "nominal typing"), the type error messages end up better than the counterpart ("structural typing", like for tuples). This makes refactoring easier; changing a record type's fields naturally allows the compiler to know that it's still the same record, just misused in some places. Otherwise, under structural typing, it might get hard to tell whether the definition site or the usage site is wrong.</li>
</ol><h1>bind-to-global-js-values</h1><hr />
<p>title: "Bind to Global JS Values"
description: "JS interop with global JS values in ReScript"
canonical: "/docs/manual/latest/bind-to-global-js-values"</p>
<hr />
<h1>Bind to Global JS Values</h1>
<p><strong>First</strong>, make sure the value you'd like to model doesn't already exist in our <a href="api/js">provided API</a>.</p>
<p>Some JS values, like <code>setTimeout</code>, live in the global scope. You can bind to them like so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val external setTimeout: (unit =&gt; unit, int) =&gt; float = "setTimeout"
@val external clearTimeout: float =&gt; unit = "clearTimeout"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>(We already provide <code>setTimeout</code>, <code>clearTimeout</code> and others in the <a href="api/js/global">Js.Global</a> module).</p>
<p>This binds to the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrworkerGlobalScope/setTimeout"><code>setTimeout</code></a> methods and the corresponding <code>clearTimeout</code>. The <code>external</code>'s type annotation specifies that <code>setTimeout</code>:</p>
<ul>
<li>Takes a function that accepts <code>unit</code> and returns <code>unit</code> (which on the JS side turns into a function that accepts nothing and returns nothing aka <code>undefined</code>),</li>
<li>and an integer that specifies the duration before calling said function,</li>
<li>returns a number that is the timeout's ID. This number might be big, so we're modeling it as a float rather than the 32-bit int.</li>
</ul>
<h3>Tips &amp; Tricks</h3>
<p><strong>The above isn't ideal</strong>. See how <code>setTimeout</code> returns a <code>float</code> and <code>clearTimeout</code> accepts one. There's no guarantee that you're passing the float created by <code>setTimeout</code> into <code>clearTimeout</code>! For all we know, someone might pass it <code>Math.random()</code> into the latter.</p>
<p>We're in a language with a great type system now! Let's leverage a popular feature to solve this problem: abstract types.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type timerId
@val external setTimeout: (unit =&gt; unit, int) =&gt; timerId = "setTimeout"
@val external clearTimeout: timerId =&gt; unit = "clearTimeout"</p>
<p>let id = setTimeout(() =&gt; Js.log("hello"), 100)
clearTimeout(id)</p>
<pre class="codehilite"><code>```js
var id = setTimeout(function (param) {
  console.log(&quot;hello&quot;);
}, 100);

clearTimeout(id);
</code></pre>

<p></CodeTab></p>
<p>Clearly, <code>timerId</code> is a type that can only be created by <code>setTimeout</code>! Now we've guaranteed that <code>clearTimeout</code> <em>will</em> be passed a valid ID. Whether it's a number under the hood is now a mere implementation detail.</p>
<p>Since <code>external</code>s are inlined, we end up with JS output as readable as hand-written JS.</p>
<h2>Global Modules</h2>
<p>If you want to bind to a value inside a global module, e.g. <code>Math.random</code>, attach a <code>scope</code> to your <code>val</code> external:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@scope("Math") @val external random: unit =&gt; float = "random"
let someNumber = random()</p>
<pre class="codehilite"><code>```js
var someNumber = Math.random();
</code></pre>

<p></CodeTab></p>
<p>you can bind to an arbitrarily deep object by passing a tuple to <code>scope</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val @scope(("window", "location", "ancestorOrigins"))
external length: int = "length"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>This binds to <code>window.location.ancestorOrigins.length</code>.</p>
<h2>Special Global Values</h2>
<p>Global values like <code>__filename</code> and <code>__DEV__</code> don't always exist; you can't even model them as an <code>option</code>, since the mere act of referring to them in ReScript (then compiled into JS) would trigger the usual <code>Uncaught ReferenceError: __filename is not defined</code> error in e.g. the browser environment.</p>
<p>For these troublesome global values, ReScript provides a special approach: <code>%external(a_single_identifier)</code>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch %external(<strong>DEV</strong>) {
| Some(_) =&gt; Js.log("dev mode")
| None =&gt; Js.log("production mode")
}</p>
<pre class="codehilite"><code>```js
var match = typeof __DEV__ === &quot;undefined&quot; ? undefined : __DEV__;

if (match !== undefined) {
  console.log(&quot;dev mode&quot;);
} else {
  console.log(&quot;production mode&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>That first line's <code>typeof</code> check won't trigger a JS ReferenceError.</p>
<p>Another example:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch %external(__filename) {
| Some(f) =&gt; Js.log(f)
| None =&gt; Js.log("non-node environment")
};</p>
<pre class="codehilite"><code>```js
var match = typeof (__filename) === &quot;undefined&quot; ? undefined : (__filename);

if (match !== undefined) {
  console.log(match);
} else {
  console.log(&quot;non-node environment&quot;);
}
</code></pre>

<p></CodeTab></p>
<!-- TODO: revamp this page. Not good. Tell to use globalThis["foo"], and look in our stdlib --><h1>inlining-constants</h1><hr />
<p>title: "Inlining Constants"
description: "Inlining constants"
canonical: "/docs/manual/latest/inlining-constants"</p>
<hr />
<h1>Inlining Constants</h1>
<p>Sometime, in the JavaScript output, you might want a certain value to be forcefully inlined. For example:</p>
<pre class="codehilite"><code class="language-js">if (process.env.mode === 'development') {
  console.log(&quot;Dev-only code here!&quot;)
}
</code></pre>

<p>The reason is that your JavaScript bundler (e.g. Webpack) might turn that into:</p>
<pre class="codehilite"><code class="language-js">if ('production' === 'development') {
  console.log(&quot;Dev-only code here!&quot;)
}
</code></pre>

<p>Then your subsequent Uglifyjs optimization would remove that entire <code>if</code> block. This is how projects like ReactJS provide a development mode code with plenty of dev warnings, while ensuring that the uglified (minified) production code is free of those expensive blocks.</p>
<p>So, in ReScript, producing that example <code>if (process.env.mode === 'development')</code> output is important. This first try doesn't work:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val external process: 'a = "process"</p>
<p>let mode = "development"</p>
<p>if (process["env"]["mode"] === mode) {
  Js.log("Dev-only code here!")
}</p>
<pre class="codehilite"><code>```js
var mode = &quot;development&quot;;

if (process.env.mode === mode) {
  console.log(&quot;Dev-only code here!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>The JS output shows <code>if (process.env.mode === mode)</code>, which isn't what we wanted. To inline <code>mode</code>'s value, use <code>@inline</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val external process: 'a = "process"</p>
<p>@inline
let mode = "development"</p>
<p>if (process["env"]["mode"] === mode) {
  Js.log("Dev-only code here!")
}</p>
<pre class="codehilite"><code>```js
if (process.env.mode === &quot;development&quot;) {
  console.log(&quot;Dev-only code here!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>Now your resulting JS code can pass through Webpack and Uglifyjs like the rest of your JavaScript code, and that whole <code>console.log</code> can be removed.</p>
<p>The inlining currently only works for <strong>string, float and boolean</strong>.</p>
<h2>Tips &amp; Tricks</h2>
<p>This is <strong>not</strong> an optimization. This is an edge-case feature for folks who absolutely need particular values inlined for a JavaScript post-processing step, like conditional compilation. Beside the difference in code that the conditional compilation might end up outputting, there's no performance difference between inlining and not inlining simple values in the eyes of a JavaScript engine.</p><h1>introduction</h1><hr />
<p>title: "Introduction"
description: "The hows and whys of ReScript"
canonical: "/docs/manual/latest/introduction"</p>
<hr />
<h1>ReScript</h1>
<p>Ever wanted a language like JavaScript, but without the warts, with a great type system, and with a lean build toolchain that doesn't waste your time?</p>
<p>ReScript looks like JS, acts like JS, and compiles to the highest quality of clean, readable and performant JS, directly runnable in browsers and Node.</p>
<p><strong>This means you can pick up ReScript and access the vast JavaScript ecosystem and tooling as if you've known ReScript for a long time!</strong></p>
<p><strong>ReScript is the language for folks who don't necessarily love JavaScript, but who still acknowledge its importance</strong>.</p>
<h2>Difference vs TypeScript</h2>
<p>We respect TypeScript very much and think that it's a positive force in the JavaScript ecosystem. ReScript shares some of the same goals as TypeScript, but is different enough regarding some important nuances:</p>
<ul>
<li>
<p>TypeScript's (admittedly noble) goal is to cover the entire JavaScript feature set and more. <strong>ReScript covers only a curated subset of JavaScript</strong>. For example, we emphasize plain data + functions over classes, clean <a href="pattern-matching-destructuring.md">pattern matching</a> over fragile <code>if</code>s and virtual dispatches, <a href="variant.md">proper data modeling</a> over string abuse, etc. JavaScript supersets will only grow larger over time; ReScript doesn't. *</p>
</li>
<li>
<p>Consequently, TypeScript's type system is necessarily complex, pitfalls-ridden, potentially requires tweaking, sometimes slow, and requires quite a bit of noisy annotations that often feel like manual bookkeeping rather than clear documentation. In contrast, ReScript's type system:</p>
</li>
<li>
<p>Is deliberately curated to be a simple subset most folks will have an easier time to use.</p>
</li>
<li>Has <strong>no</strong> pitfalls, aka the type system is "sound" (the types will always be correct). E.g. If a type isn't marked as nullable, its value will never lie and let through some <code>undefined</code> value silently. <strong>ReScript code has no null/undefined errors</strong>.</li>
<li>Is the same for everyone. No knobs, no bikeshedding opportunity.</li>
<li>Runs extremely fast precisely thanks to its simplicity and curation. It's one of the fastest compiler &amp; build system toolchains for JavaScript development.</li>
<li>
<p><strong>Doesn't need type annotations</strong>. Annotate as much or as little as you'd like. The types are inferred by the language (and, again, are guaranteed correct).</p>
</li>
<li>
<p>Migrating to TypeScript is done "breadth-first," whereas migrating to ReScript is done "depth-first." You can convert your codebase to TypeScript by "turning it on" for all files and annotate here and there; but how much type safety did you gain? How do you measure it? Type errors can still slip in and out of the converted pieces. For ReScript, our interop features draw clear boundaries: there's pure ReScript code, and there's JS interop code. Every piece of converted ReScript code is 100% clean. You'd convert file by file and each conversion increases your safety monotonically.</p>
</li>
</ul>
<p>* When you absolutely need to write or interoperate with free-for-all JavaScript, we expose enough escape hatches for you.</p>
<h2>Other Highlights</h2>
<p>Aside from the aforementioned simple, robust and fast type system, ReScript presents a few more advantages.</p>
<h3>Faster than JavaScript</h3>
<p>JavaScript's been aggressively optimized by talented engineers over a long span. Unfortunately, even for seasoned JS devs, it can be hard to know how to properly leverage JS's performance. ReScript's type system and compiler naturally guides you toward writing code that's very often performant by default, with good leverage of various Just-In-Time optimizations (hidden classes, inline caching, avoiding deopts, etc).</p>
<p>A widespread adage to write fast JavaScript code is to write as if there's a type system (in order to trigger JS engines' good optimization heuristics); ReScript gives you a real one and generates code that's friendly to optimizations by default.</p>
<h3>High Quality Dead Code Elimination</h3>
<p>The JavaScript ecosystem is very reliant on dependencies. Shipping the final product inevitably drags in a huge amount of code, lots of which the project doesn't actually use. These regions of dead code impact loading, parsing and interpretation speed. ReScript provides powerful dead code elimination at all levels:</p>
<ul>
<li>Function- and module-level code elimination is facilitated by the well-engineered type system and purity analysis.</li>
<li>At the global level, ReScript generates code that is naturally friendly to dead code elimination done by bundling tools such as <a href="https://github.com/rollup/rollup">Rollup</a> and <a href="https://developers.google.com/closure/compiler/">Closure Compiler</a>, after its own sophisticated elimination pass.</li>
<li>The same applies for ReScript's own tiny runtime (which is written in ReScript itself).</li>
</ul>
<h3>Tiny JS Output</h3>
<p>A <code>Hello world</code> ReScript program generates <strong>20 bytes</strong> of JS code. Additionally, the standard library pieces you require in are only included when needed.</p>
<h3>Fast Iteration Loop</h3>
<p>ReScript's build time is <strong>one or two orders of magnitude</strong> faster than alternatives. In its watcher mode, the build system usually finishes before you switch screen from the editor to the terminal tab (two digits of milliseconds). A fast iteration cycle reduces the need of keeping one's mental state around longer; this in turn allows one to stay in the flow longer and more often.</p>
<h3>Readable Output &amp; Great Interop</h3>
<p>Unreadable JavaScript code generated from other compiled-to-js languages makes it so that it could be, practically speaking:</p>
<ul>
<li>Hard to debug (cryptic stack trace, mangled variable names)</li>
<li>Hard to learn from (non-straightforward mapping of concepts from one language to another)</li>
<li>Hard to profile for performance (unclear what runtime performance cost there is)</li>
<li>Hard to integrate with existing hand-written JS code</li>
</ul>
<p>ReScript's JS output is very readable. This is especially important while learning, where users might want to understand how the code's compiled, and to audit for bugs.</p>
<p>This characteristic, combined with a fully-featured JS interop system, allows ReScript code to be inserted into an existing JavaScript codebase almost unnoticed.</p>
<h3>Preservation of Code Structure</h3>
<p>ReScript maps one source file to one JavaScript output file. This eases the integration of existing tools such as bundlers and test runners. You can even start writing a single file without much change to your build setup. Each file's code structure is approximately preserved, too.</p>
<h2>Conclusion</h2>
<p>We hope the above gave you enough of an idea of ReScript and its differentiators. Feel free to <a href="/try">try it online</a> to get a feel!</p><h1>control-flow</h1><hr />
<p>title: "If-Else &amp; Loops"
description: "If, else, ternary, for, and while"
canonical: "/docs/manual/latest/control-flow"</p>
<hr />
<h1>If-Else &amp; Loops</h1>
<p>ReScript supports <code>if</code>, <code>else</code>, ternary expression (<code>a ? b : c</code>), <code>for</code> and <code>while</code>.</p>
<p>ReScript also supports our famous pattern matching, which will be covered in <a href="pattern-matching-destructuring.md">its own section</a></p>
<h2>If-Else &amp; Ternary</h2>
<p>Unlike its JavaScript counterpart, ReScript's <code>if</code> is an expression; they evaluate to their body's content:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let message = if isMorning {
  &quot;Good morning!&quot;
} else {
  &quot;Hello!&quot;
}
</code></pre>

<pre class="codehilite"><code class="language-js">var message = isMorning ? &quot;Good morning!&quot; : &quot;Hello!&quot;;
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> an <code>if-else</code> expression without the final <code>else</code> branch implicitly gives <code>()</code> (aka the <code>unit</code> type). So this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">if showMenu {
  displayMenu()
}
</code></pre>

<pre class="codehilite"><code class="language-js">if (showMenu) {
  displayMenu();
}
</code></pre>

<p></CodeTab></p>
<p>is basically the same as:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">if showMenu {
  displayMenu()
} else {
  ()
}
</code></pre>

<pre class="codehilite"><code class="language-js">if (showMenu) {
  displayMenu()
}
</code></pre>

<p></CodeTab></p>
<p>Here's another way to look at it. This is clearly wrong:</p>
<pre class="codehilite"><code class="language-res">let result = if showMenu {
  1 + 2
}
</code></pre>

<p>It'll give a type error, saying basically that the implicit <code>else</code> branch has the type <code>unit</code> while the <code>if</code> branch has type <code>int</code>. Intuitively, this makes sense: what would <code>result</code>'s value be, if <code>showMenu</code> was <code>false</code>?</p>
<p>We also have ternary sugar, but <strong>we encourage you to prefer if-else when possible</strong>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let message = isMorning ? &quot;Good morning!&quot; : &quot;Hello!&quot;
</code></pre>

<pre class="codehilite"><code class="language-js">var message = isMorning ? &quot;Good morning!&quot; : &quot;Hello!&quot;;
</code></pre>

<p></CodeTab></p>
<p><strong><code>if-else</code> and ternary are much less used</strong> in ReScript than in other languages; <a href="pattern-matching-destructuring.md">Pattern-matching</a> kills a whole category of code that previously required conditionals.</p>
<h2>For Loops</h2>
<p>For loops iterate from a starting value up to (and including) the ending value.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">for i in startValueInclusive to endValueInclusive {
  Js.log(i)
}
</code></pre>

<pre class="codehilite"><code class="language-js">for(var i = startValueInclusive; i &lt;= endValueInclusive; ++i){
  console.log(i);
}
</code></pre>

<p></CodeTab></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// prints: 1 2 3, one per line
for x in 1 to 3 {
  Js.log(x)
}</p>
<pre class="codehilite"><code>```js
for(var x = 1; x &lt;= 3; ++x){
  console.log(x);
}
</code></pre>

<p></CodeTab></p>
<p>You can make the <code>for</code> loop count in the opposite direction by using <code>downto</code>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">for i in startValueInclusive downto endValueInclusive {
  Js.log(i)
}
</code></pre>

<pre class="codehilite"><code class="language-js">for(var i = startValueInclusive; i &gt;= endValueInclusive; --i){
  console.log(i);
}
</code></pre>

<p></CodeTab></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// prints: 3 2 1, one per line
for x in 3 downto 1 {
  Js.log(x)
}</p>
<pre class="codehilite"><code>```js
for(var x = 3; x &gt;= 1; --x){
  console.log(x);
}
</code></pre>

<p></CodeTab></p>
<h2>While Loops</h2>
<p>While loops execute its body code block while its condition is true.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">while testCondition {
  // body here
}
</code></pre>

<pre class="codehilite"><code class="language-js">while (testCondition) {
  // body here
}
</code></pre>

<p></CodeTab></p>
<h3>Tips &amp; Tricks</h3>
<p>There's no loop-breaking <code>break</code> keyword (nor early <code>return</code> from functions, for that matter) in ReScript. However, we can break out of a while loop easily through using a <a href="mutation.md">mutable binding</a>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let break = ref(false)</p>
<p>while !break.contents {
  if Js.Math.random() &gt; 0.3 {
    break := true
  } else {
    Js.log("Still running")
  }
}</p>
<pre class="codehilite"><code>```js
var $$break = {
  contents: false
};

while(!$$break.contents) {
  if (Math.random() &gt; 0.3) {
    $$break.contents = true;
  } else {
    console.log(&quot;Still running&quot;);
  }
};
</code></pre>

<p></CodeTab></p><h1>project-structure</h1><hr />
<p>title: "Project Structure"
description: "Notes on project structure and other rough ReScript guidelines"
canonical: "/docs/manual/latest/project-structure"</p>
<hr />
<h1>Project Structure</h1>
<p>These are the existing, non-codified community practices that are currently propagated through informal agreement. We might remove some of them at one point, and enforce some others. Right now, they're just recommendations for ease of newcomers.</p>
<h2>File Casing</h2>
<p>Capitalized file names (aka first letter upper-cased).</p>
<p><strong>Justification</strong>: Module names can only be capitalized. Newcomers often ask how a file maps to a module, and why <code>draw.res</code> maps to the module <code>Draw</code>, and sometimes try to refer to a module through uncapitalized identifiers. Using <code>Draw.res</code> makes this mapping more straightforward. It also helps certain file names that'd be awkward in uncapitalized form: <code>uRI.res</code>.</p>
<h2>Ignore <code>.merlin</code> File</h2>
<p>This is generated by the build system and you should not have to manually edit it. Don't check it into the repo.</p>
<p><strong>Justification</strong>: <code>.merlin</code> is for editor tooling. The file contains absolute paths, which are also not cross-platform (e.g. Windows paths are different).</p>
<h2>Folders</h2>
<p>Try not to have too many nested folders. Keep your project flat, and have fewer files (reminder: you can use nested modules).</p>
<p><strong>Justification</strong>: The file system is a <em>tree</em>, but your code's dependencies are a <em>graph</em>. Because of that, any file &amp; folder organization is usually imperfect. While it's still valuable to group related files together in a folder, the time wasted debating &amp; getting decision paralysis over these far outweight their benefits. We'll always recommend you to Get Work Done instead of debating about these issues.</p>
<h2>Third-party Dependencies</h2>
<p>Keep them to a minimum.</p>
<p><strong>Justification</strong>: A compiled, statically typed language cannot model its dependencies easily by muddling along like in a dynamic language, especially when we're still piggy-backing on NPM/Yarn (to reduce learning overhead in the medium-term). Keeping dependencies simple &amp; lean helps reduce possibility of conflicts (e.g. two diamond dependencies, or clashing interfaces).</p>
<h2>Documentation</h2>
<p>Have them. Spend more effort making them great (examples, pitfalls) and professional rather than <em>just</em> fancy-looking. Do use examples, and avoid using names such as <code>foo</code> and <code>bar</code>. There's always more concrete names (it's an example, no need to be abstract/generalized just yet. The API docs will do this plentily). For blog posts, don't repeat the docs themselves, describe the <em>transition</em> from old to new, and why (e.g. "it was a component, now it's a function, because ...").</p>
<p><strong>Justification</strong>: It's hard for newcomers to distinguish between a simple/decent library and one that's fancy-looking. For the sake of the community, don't try too hard to one-up each other's libraries. Do spread the words, but use your judgement too.</p>
<h2>PPX &amp; Other Meta-tools</h2>
<p>Keep them to a minimum. PPX, unless used in renown cases (printer, accessors and serializer/deserializer generation), can cause big learning churn for newcomers; on top of the syntax, semantics, types, build tool &amp; FFI that they already have to learn, learning per-library custom transformations of the code is an extra step. More invasive macros makes the code itself less semantically meaningful too, since the essence would be hiding somewhere else.</p>
<h2>Paradigm</h2>
<p>Don't abuse overly fancy features. Do leave some breathing room for future APIs but don't over-architect things.</p>
<p><strong>Justification</strong>: Simple code helps newcomers understand and potentially contribute to your code. Contributing is the best way for them to learn. The extra help you receive might also surpass the gain of using a slightly more clever language trick. But do try new language tricks in some of more casual projects! You might discover new ways of architecting code.</p>
<h2>Publishing</h2>
<p>If it's a wrapper for a JS library, don't publish the JS artifacts. If it's a legit library, publish the artifacts in lib/js if you think JS consumers might use it. This is especially the case when you gradually convert a JS lib to ReScript while not breaking existing JS consumers.</p>
<p>Do put the keywords <code>"rescript"</code> in your package.json <code>keywords</code> field. This allows us to find the library much more easily for future purposes.</p>
<p><strong>Justification</strong>: Be nice to JS consumers of your library. They're your future ReScripters.</p><h1>build-external-stdlib</h1><hr />
<p>title: "External Stdlib"
metaTitle: "External Stdlib"
description: "Configuring an external ReScript stdlib package"
canonical: "/docs/manual/latest/build-external-stdlib"</p>
<hr />
<h1>External Stdlib</h1>
<p><strong>Since 9.0</strong></p>
<p>Your ReScript project depends on the <code>rescript</code> package as a <a href="https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file"><code>devDependency</code></a>, which includes our compiler, build system and runtime like <code>Belt</code>. However, you had to move it to <code>dependency</code> in <code>package.json</code> if you publish your code:
- To Docker or other low-storage deployment devices.
- For pure JS/TS consumers who probably won't install <code>bs-platform</code> in their own project.</p>
<p>In these cases, the size or mere presence of <code>bs-platform</code> can be troublesome, since it includes not just our necessary runtime like <code>Belt</code>, but also our compiler and build system.</p>
<p>To solve that, we now publish our runtime as a standalone package at <a href="https://www.npmjs.com/package/@rescript/std"><code>@rescript/std</code></a>, whose versions mirror <code>bs-platform</code>'s. Now you can keep <code>bs-platform</code> as a <code>devDependency</code> and have only <code>@rescript/std</code> as your runtime <code>dependency</code>.</p>
<p><strong>This is an advanced feature</strong>. Please only use it in the aforementioned scenarios. If you already use a JS bundler with dead code elimination, you might not need this feature.</p>
<h2>Configuration</h2>
<p>Say you want to publish a JS-only ReScript 9.0 library. Install the packages like this:</p>
<pre class="codehilite"><code class="language-sh">npm install bs-platform@9.0.0 --save-dev
npm install @rescript/std@9.0.0
</code></pre>

<p>Then add this to <code>rescript.json</code>:</p>
<pre class="codehilite"><code class="language-json">{
  // ...
  &quot;external-stdlib&quot; : &quot;@rescript/std&quot;
}
</code></pre>

<p>Now the compiled JS code will import using the path defined by <code>external-stdlib</code>. Check the JS output tab:</p>
<p><CodeTab labels={["ReScript", "JS output"]}></p>
<pre class="codehilite"><code class="language-res">Array.forEach([1, 2, 3], num =&gt; Js.log(num))
</code></pre>

<pre class="codehilite"><code class="language-js">// Note the require path starting with &quot;@rescript/std&quot;.
var Belt_Array = require(&quot;@rescript/std/lib/js/belt_Array.js&quot;);

Belt_Array.forEach([1, 2, 3], function (num) {
  console.log(num);
});
</code></pre>

<p></CodeTab></p>
<p><strong>Make sure the version number of <code>bs-platform</code> and <code>@rescript/std</code> match in your <code>package.json</code></strong> to avoid running into runtime issues due to mismatching stdlib assumptions.</p><h1>scoped-polymorphic-types</h1><hr />
<p>title: "Scoped Polymorphic Types"
description: "Scoped Polymorphic Types in ReScript"
canonical: "/docs/manual/latest/scoped-polymorphic-types"</p>
<hr />
<h1>Scoped Polymorphic Types</h1>
<p>Scoped Polymorphic Types in ReScript are functions with the capability to handle arguments of any type within a specific scope. This feature is particularly valuable when working with JavaScript APIs, as it allows your functions to accommodate diverse data types while preserving ReScript's strong type checking.</p>
<h2>Definition and Usage</h2>
<p>Scoped polymorphic types in ReScript offer a flexible and type-safe way to handle diverse data types within specific scopes. This documentation provides an example to illustrate their usage in a JavaScript context.</p>
<h3>Example: Logging API</h3>
<p>Consider a logging example within a JavaScript context that processes various data types:</p>
<pre class="codehilite"><code class="language-js">const logger = {
  log: (data) =&gt; {
    if (typeof data === &quot;string&quot;) {
      /* handle string */
    } else if (typeof data === &quot;number&quot;) {
      /* handle number */
    } else {
      /* handle other types */
    }
  },
};
</code></pre>

<p>In ReScript, we can bind to this function as a record with a scoped polymorphic function type:</p>
<p>```res prelude
type logger = { log: 'a. 'a =&gt; unit }</p>
<p>@module("jsAPI") external getLogger: unit =&gt; logger = "getLogger"</p>
<pre class="codehilite"><code>The `logger` type represents a record with a single field `log`, which is a scoped polymorphic function type `'a. 'a =&gt; unit`. The `'a` indicates a type variable that can be any type within the scope of the `log` function.

Now, we can utilize the function obtained from `getLogger`:

&lt;CodeTab labels={[&quot;ReScript&quot;, &quot;JS Output&quot;]}&gt;

```res example
let myLogger = getLogger()

myLogger.log(&quot;Hello, ReScript!&quot;)
myLogger.log(42)
</code></pre>

<pre class="codehilite"><code class="language-js">var myLogger = JsAPI.getLogger();

myLogger.log(&quot;Hello, ReScript!&quot;);
myLogger.log(42);
</code></pre>

<p></CodeTab></p>
<p>In this example, we create an instance of the logger by calling <code>getLogger()</code>, and then we can use the <code>log</code> function on the <code>myLogger</code> object to handle different data types.</p>
<h2>Limitations of Normal Polymorphic Types</h2>
<p>Let's consider the same logging example in ReScript, but this time using normal polymorphic types:</p>
<pre class="codehilite"><code class="language-res">type logger&lt;'a&gt; = { log: 'a =&gt; unit}

@module(&quot;jsAPI&quot;) external getLogger: unit =&gt; logger&lt;'a&gt; = &quot;getLogger&quot;
</code></pre>

<p>In this case, the <code>logger</code> type is a simple polymorphic function type <code>'a =&gt; unit</code>. However, when we attempt to use this type in the same way as before, we encounter an issue:</p>
<pre class="codehilite"><code class="language-res">let myLogger = getLogger()

myLogger.log(&quot;Hello, ReScript!&quot;)
myLogger.log(42) // Type error!
</code></pre>

<p>The problem arises because the type inference in ReScript assigns a concrete type to the <code>logger</code> function based on the first usage. In this example, after the first call to <code>myLogger</code>, the compiler infers the type <code>logger&lt;string&gt;</code> for <code>myLogger</code>. Consequently, when we attempt to pass an argument of type <code>number</code> in the next line, a type error occurs because it conflicts with the inferred type <code>logger&lt;string&gt;</code>.</p>
<p>In contrast, scoped polymorphic types, such as <code>'a. 'a =&gt; unit</code>, overcome this limitation by allowing type variables within the scope of the function. They ensure that the type of the argument is preserved consistently within that scope, regardless of the specific value used in the first invocation.</p>
<h2>Limitations of Scoped Polymorphic Types</h2>
<p>Scoped polymorphic types work only when they are directly applied to let-bindings or record fields (as demonstrated in the logger example above). They can neither be applied to function bodies, nor to separate type definitions:</p>
<pre class="codehilite"><code class="language-res">exception Abort

let testExn: 'a. unit =&gt; 'a = () =&gt; raise(Abort) // Works!

let testExn2 = (): 'a. 'a = raise(Abort) // Syntax error!
type fn = 'a. 'a =&gt; unit // Syntax error!
</code></pre><h1>build-configuration</h1><hr />
<p>title: "Configuration"
metaTitle: "Build System Configuration"
description: "Details about the configuration of the ReScript build system (rescript.json)"
canonical: "/docs/manual/latest/build-configuration"</p>
<hr />
<h1>Configuration</h1>
<p><code>rescript.json</code> (or <code>bsconfig.json</code> in versions prior ReScript 11) is the single, mandatory build meta file needed for <code>rescript</code>.</p>
<p><strong>The complete configuration schema is <a href="./build-configuration-schema">here</a></strong>. We'll <em>non-exhaustively</em> highlight the important parts in prose below.</p>
<h2>name, namespace</h2>
<p><code>name</code> is the name of the library, used as its "namespace". You can activate namespacing through <code>"namespace": true</code> in your <code>rescript.json</code>. Namespacing is almost <strong>mandatory</strong>; we haven't turned it on by default yet to preserve backward-compatibility.</p>
<p><strong>Explanation</strong>: by default, your files, once used as a third-party dependency, are available globally to the consumer. E.g. if you have an <code>Util.re</code> and the consumer also has a file of the same name, they will clash. Turning on <code>namespace</code> avoids this by wrapping all your own project's files into an extra module layer; instead of a global <code>Util</code> module, the consumer will see you as <code>MyProject.Util</code>. <strong>The namespacing affects your consumers, not yourself</strong>.</p>
<p>Aka, in ReScript, "namespace" is just a fancy term for an auto-generated module that wraps all your project's files (efficiently and correctly, of course!) for third-party consumption.</p>
<p>We don't do folder-level namespacing for your own project; all your own file names must be unique. This is a constraint that enables several features such as fast search and easier project reorganization.</p>
<p><strong>Note</strong>: the <code>rescript.json</code> <code>name</code> should be the same as the <code>package.json</code> <code>name</code>, to avoid confusing corner-cases. However, this means that you can't use a camelCased names such as <code>MyProject</code>, since <code>package.json</code> and npm forbid you to do so (some file systems are case-insensitive). To have the namespace/module as <code>MyProject</code>, write <code>"name": "my-project"</code>. ReScript will turn that into the camelCased name correctly.</p>
<p><strong>Note on custom namespacing</strong>: if for some reason, you need a namespace that is different from what your <code>name</code> will produce, you can directly send a string to the <code>namespace</code> option. For example, if your package is a binding named <code>bs-some-thing</code>, you can use <code>"namespace": "some-thing"</code> to get <code>SomeThing</code> namespace instead of <code>BsSomeThing</code>.</p>
<h2>sources</h2>
<p>Your source files need to be specified explicitly (we don't want to accidentally drill down into some unrelated directories). Examples:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;sources&quot;: [&quot;src&quot;, &quot;examples&quot;]
}
</code></pre>

<pre class="codehilite"><code class="language-json">{
  &quot;sources&quot;: {
    &quot;dir&quot;: &quot;src&quot;,
    &quot;subdirs&quot;: [&quot;page&quot;]
  }
}
</code></pre>

<pre class="codehilite"><code class="language-json">{
  &quot;sources&quot;: [
    &quot;examples&quot;,
    {
      &quot;dir&quot;: &quot;src&quot;,
      &quot;subdirs&quot;: true // recursively builds every subdirectory
    }
  ]
}
</code></pre>

<p>You can mark your directories as dev-only (for e.g. tests). These won't be built and exposed to third-parties, or even to other "dev" directories in the same project:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;sources&quot; : {
    &quot;dir&quot; : &quot;test&quot;,
    &quot;type&quot; : &quot;dev&quot;
  }
}
</code></pre>

<p>You can also explicitly allow which modules can be seen from outside. This feature is especially useful for library authors who want to have a single entry point for their users. <br />
Here, the file <code>src/MyMainModule.res</code> is exposed to outside consumers, while all other files are private.</p>
<pre class="codehilite"><code class="language-json">{
  &quot;sources&quot;: {
    &quot;dir&quot;: &quot;src&quot;,
    &quot;public&quot;: [&quot;MyMainModule&quot;]
  },
}
</code></pre>

<h2>bs-dependencies, bs-dev-dependencies</h2>
<p>List of ReScript dependencies. Just like <code>package.json</code>'s dependencies, they'll be searched in <code>node_modules</code>.</p>
<p>Note that only sources marked with <code>"type":"dev"</code> will be able to resolve modules from <code>bs-dev-dependencies</code>.</p>
<h2>pinned-dependencies</h2>
<p><strong>Since 8.4</strong>: List of pinned dependencies. A pinned dependency will always be rebuilt whenever you build a toplevel package (e.g. your main app) with <code>rescript</code>.</p>
<p>This is useful for working on multiple independent ReScript packages simultaneously. More usage details can be found in our dedicated <a href="./build-pinned-dependencies">pinned dependencies</a> page.</p>
<h2>external-stdlib</h2>
<p><strong>Since 9.0</strong>: This setting allows depending on an externally built stdlib package (instead of a locally built stdlib runtime). Useful for shipping packages that are only consumed in JS or TS without any dependencies to the ReScript development toolchain.</p>
<p>More details can be found on our <a href="./build-external-stdlib">external stdlib</a> page.</p>
<h2>js-post-build</h2>
<p>Hook that's invoked every time a file is recompiled. Good for JS build system interop, but please use it <strong>sparingly</strong>. Calling your custom command for every recompiled file slows down your build and worsens the building experience for even third-party users of your lib.</p>
<p>Example:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;js-post-build&quot;: {
    &quot;cmd&quot;: &quot;/path/to/node ../../postProcessTheFile.js&quot;
  }
}
</code></pre>

<p>Note that the path resolution for the command (<code>node</code> in this case) is done so:</p>
<ul>
<li><code>/myCommand</code> is resolved into <code>/myCommand</code></li>
<li><code>package/myCommand</code> is resolved into <code>node_modules/package/myCommand</code></li>
<li><code>./myCommand</code> is resolved into <code>myProjectRoot/myCommand</code></li>
<li><code>myCommand</code> is just called as <code>myCommand</code>, aka a globally available executable. But note that ReScript doesn't read into your shell's environment, so if you put e.g. <code>node</code>, it won't find it unless you specify an absolute path. Alternatively, add <code>#!/usr/local/bin/node</code> to the top of your script to directly call it without prepending <code>node</code>.</li>
</ul>
<p>The command itself is called from inside <code>lib/bs</code>.</p>
<h2>package-specs</h2>
<p>Output to either CommonJS (the default) or ES6 modules. Example:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;package-specs&quot;: {
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;in-source&quot;: true
  }
}
</code></pre>

<ul>
<li><code>"module": "es6-global"</code> resolves <code>node_modules</code> using relative paths. Good for development-time usage of ES6 in conjunction with browsers like Safari and Firefox that support ES6 modules today. <strong>No more dev-time bundling</strong>!</li>
<li><code>"in-source": true</code> generates output alongside source files. If you omit it, it'll generate the artifacts into <code>lib/js</code>. The output directory is not configurable otherwise.</li>
</ul>
<p>This configuration only applies to you, when you develop the project. When the project is used as a third-party library, the consumer's own <code>rescript.json</code> <code>package-specs</code> overrides the configuration here, logically.</p>
<h2>suffix</h2>
<p><strong>Since 11.0</strong>: The suffix can now be freely chosen. However, we still suggest you stick to the convention and use
one of the following:<br />
- <code>".js</code>
- <code>".mjs"</code>
- <code>".cjs"</code>
- <code>".res.js"</code>
- <code>".res.mjs"</code>
- <code>".res.cjs"</code>
- <code>".bs.js"</code>
- <code>".bs.mjs"</code>
- <code>".bs.cjs"</code></p>
<p>Currently prefer <code>.bs.js</code> for now.</p>
<h3>Design Decisions</h3>
<p>Generating JS files with the <code>.bs.js</code> suffix means that, on the JS side, you can do <code>const myReScriptFile = require('./theFile.bs')</code>. The benefits:</p>
<ul>
<li>It's immediately clear that we're dealing with a generated JS file here.</li>
<li>It avoids clashes with a potential <code>theFile.js</code> file in the same folder.</li>
<li>It avoids the need of using a build system loader for ReScript files. This + in-source build means integrating a ReScript project into your pure JS codebase <strong>basically doesn't touch anything in your build pipeline at all</strong>.</li>
<li><a href="/docs/gentype/latest/introduction">genType</a> requires <code>bs.js</code> for compiled JS artifacts. If you are using <code>genType</code>, you need to use <code>bs.js</code> for now.</li>
</ul>
<h2>uncurried</h2>
<p><strong>Since 11.0</strong>: While we strongly encourage all users to use uncurried mode, it is still possible to opt out. Just set <code>"uncurried"</code> to <code>false</code> to get the old behavior back:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;uncurried&quot;: false
}
</code></pre>

<p>More details can be found in the <a href="/blog/uncurried-mode">blogpost about "Uncurried Mode"</a>.</p>
<h2>warnings</h2>
<p>Selectively turn on/off certain warnings and/or turn them into hard errors. Example:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;warnings&quot;: {
    &quot;number&quot;: &quot;-44-102&quot;,
    &quot;error&quot;: &quot;+5&quot;
  }
}
</code></pre>

<p>Turn off warning <code>44</code> and <code>102</code> (polymorphic comparison). Turn warning <code>5</code> (partial application whose result has function type and is ignored) into a hard error.</p>
<p>The warning numbers are shown in the build output when they're triggered. See <a href="./warning-numbers">Warning Numbers</a> for the complete list.</p>
<h2>bsc-flags</h2>
<p>Extra flags to pass to the compiler. For advanced usages.</p>
<h2>Environment Variables</h2>
<p>We heavily disrecommend the usage of environment variables, but for certain cases, they're justified.</p>
<h3>Error Output Coloring: <code>NINJA_ANSI_FORCED</code></h3>
<p>This is mostly for other programmatic usage of <code>rescript</code> where outputting colors is not desired.</p>
<p>When <code>NINJA_ANSI_FORCED</code> is set to <code>1</code>: <code>rescript</code> produces color.
When <code>NINJA_ANSI_FORCED</code> is set to <code>0</code>: <code>rescript</code> doesn't produce color.
When <code>NINJA_ANSI_FORCED</code> is not set: <code>rescript</code> might or might not produce color, depending on a smart detection of where it's outputted.</p>
<blockquote>
<p>Note that the underlying compiler will always be passed <code>-color always</code>. See more details in <a href="https://github.com/rescript-lang/rescript-compiler/issues/2984#issuecomment-410669163">this issue</a>.</p>
</blockquote><h1>exception</h1><hr />
<p>title: "Exception"
description: "Exceptions and exception handling in ReScript"
canonical: "/docs/manual/latest/exception"</p>
<hr />
<h1>Exception</h1>
<p>Exceptions are just a special kind of variant, thrown in <strong>exceptional</strong> cases (don't abuse them!).</p>
<h2>Usage</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let getItem = (item: int) =&gt;
  if (item === 3) {
    // return the found item here
    1
  } else {
    raise(Not_found)
  }</p>
<p>let result =
  try {
    getItem(2)
  } catch {
  | Not_found =&gt; 0 // Default value if getItem throws
  }</p>
<pre class="codehilite"><code>```js
var Caml_js_exceptions = require(&quot;./stdlib/caml_js_exceptions.js&quot;);

function getItem(item) {
  if (item === 3) {
    return 1;
  }
  throw {
    RE_EXN_ID: &quot;Not_found&quot;,
    Error: new Error()
  };
}

var result;

try {
  result = getItem(2);
}
catch (raw_exn){
  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.RE_EXN_ID === &quot;Not_found&quot;) {
    result = 0;
  } else {
    throw exn;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Note that the above is just for demonstration purposes; in reality, you'd return an <code>option&lt;int&gt;</code> directly from <code>getItem</code> and avoid the <code>try</code> altogether.</p>
<p>You can directly match on exceptions <em>while</em> getting another return value from a function:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
switch list{1, 2, 3}-&gt;List.getExn(4) {
| item =&gt; Js.log(item)
| exception Not_found =&gt; Js.log("No such item found!")
}</p>
<pre class="codehilite"><code>```js
var List = require(&quot;./stdlib/list.js&quot;);
var Caml_js_exceptions = require(&quot;./stdlib/caml_js_exceptions.js&quot;);

var exit = 0;

var item;

try {
  item = List.find((function (i) {
          return i === 4;
        }), {
        hd: 1,
        tl: {
          hd: 2,
          tl: {
            hd: 3,
            tl: /* [] */0
          }
        }
      });
  exit = 1;
}
catch (raw_exn){
  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.RE_EXN_ID === &quot;Not_found&quot;) {
    console.log(&quot;No such item found!&quot;);
  } else {
    throw exn;
  }
}

if (exit === 1) {
  console.log(item);
}
</code></pre>

<p></CodeTab></p>
<p>You can also make your own exceptions like you'd make a variant (exceptions need to be capitalized too).</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
exception InputClosed(string)
// later on
raise(InputClosed("The stream has closed!"))</p>
<pre class="codehilite"><code>```js
var Caml_exceptions = require(&quot;./stdlib/caml_exceptions.js&quot;);

var InputClosed = Caml_exceptions.create(&quot;MyFile.InputClosed&quot;);

throw {
  RE_EXN_ID: InputClosed,
  _1: &quot;The stream has closed!&quot;,
  Error: new Error()
};
</code></pre>

<p></CodeTab></p>
<h2>Catching JS Exceptions</h2>
<p>To distinguish between JavaScript exceptions and ReScript exceptions, ReScript namespaces JS exceptions under the <code>Js.Exn.Error(payload)</code> variant. To catch an exception thrown from the JS side:</p>
<p>Throw an exception from JS:</p>
<pre class="codehilite"><code class="language-js">// Example.js

exports.someJsFunctionThatThrows = () =&gt; {
    throw new Error(&quot;A Glitch in the Matrix!&quot;);
}
</code></pre>

<p>Then catch it from ReScript:</p>
<pre class="codehilite"><code class="language-res">// import the method in Example.js
@module(&quot;./Example&quot;) 
external someJsFunctionThatThrows: () =&gt; unit = &quot;someJsFunctionThatThrows&quot;

try {
  // call the external method
  someJSFunctionThatThrows()
} catch {
| Js.Exn.Error(obj) =&gt;
  switch Js.Exn.message(obj) {
  | Some(m) =&gt; Js.log(&quot;Caught a JS exception! Message: &quot; ++ m)
  | None =&gt; ()
  }
}
</code></pre>

<p>The <code>obj</code> here is of type <code>Js.Exn.t</code>, intentionally opaque to disallow illegal operations. To operate on <code>obj</code>, do like the code above by using the standard library's <a href="api/js/exn"><code>Js.Exn</code></a> module's helpers.</p>
<h2>Raise a JS Exception</h2>
<p><code>raise(MyException)</code> raises a ReScript exception. To raise a JavaScript exception (whatever your purpose is), use <code>Js.Exn.raiseError</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myTest = () =&gt; {
  Js.Exn.raiseError("Hello!")
}</p>
<pre class="codehilite"><code>```js
var Js_exn = require(&quot;./stdlib/js_exn.js&quot;);

function myTest() {
  return Js_exn.raiseError(&quot;Hello!&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>Then you can catch it from the JS side:</p>
<pre class="codehilite"><code class="language-js">// after importing `myTest`...
try {
  myTest()
} catch (e) {
  console.log(e.message) // &quot;Hello!&quot;
}
</code></pre>

<h2>Catch ReScript Exceptions from JS</h2>
<p>The previous section is less useful than you think; to let your JS code work with your exception-throwing ReScript code, the latter doesn't actually need to throw a JS exception. ReScript exceptions can be used by JS code!</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
exception BadArgument({myMessage: string})</p>
<p>let myTest = () =&gt; {
  raise(BadArgument({myMessage: "Oops!"}))
}</p>
<pre class="codehilite"><code>```js
var Caml_exceptions = require(&quot;./stdlib/caml_exceptions.js&quot;);

var BadArgument = Caml_exceptions.create(&quot;Playground.BadArgument&quot;);

function myTest() {
  throw {
    RE_EXN_ID: BadArgument,
    myMessage: &quot;Oops!&quot;,
    Error: new Error()
  };
}
</code></pre>

<p></CodeTab></p>
<p>Then, in your JS:</p>
<pre class="codehilite"><code class="language-js">// after importing `myTest`...
try {
  myTest()
} catch (e) {
  console.log(e.myMessage) // &quot;Oops!&quot;
  console.log(e.Error.stack) // the stack trace
}
</code></pre>

<blockquote>
<p>Note: <code>RE_EXN_ID</code> is an internal field for bookkeeping purposes. Don't use it on the JS side. Use the other fields.</p>
</blockquote>
<p>The above <code>BadArgument</code> exception takes an inline record type. We special-case compile the exception as <code>{RE_EXN_ID, myMessage, Error}</code> for good ergonomics. If the exception instead took ordinary positional arguments, l like the standard library's <code>Invalid_argument("Oops!")</code>, which takes a single argument, the argument is compiled to JS as the field <code>_1</code> instead. A second positional argument would compile to <code>_2</code>, etc.</p>
<h2>Tips &amp; Tricks</h2>
<p>When you have ordinary variants, you often don't <strong>need</strong> exceptions. For example, instead of throwing when <code>item</code> can't be found in a collection, try to return an <code>option&lt;item&gt;</code> (<code>None</code> in this case) instead.</p>
<h3>Catch Both ReScript and JS Exceptions in the Same <code>catch</code> Clause</h3>
<pre class="codehilite"><code class="language-res">try {
  someOtherJSFunctionThatThrows()
} catch {
| Not_found =&gt; ... // catch a ReScript exception
| Invalid_argument(_) =&gt; ... // catch a second ReScript exception
| Js.Exn.Error(obj) =&gt; ... // catch the JS exception
}
</code></pre>

<p>This technically works, but hopefully you don't ever have to work with such code...</p><h1>editor-plugins</h1><hr />
<p>title: "Editor Plugins"
description: "List of ReScript editor plugins"
canonical: "/docs/manual/latest/editor-plugins"</p>
<hr />
<h1>Editor Plugins</h1>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=chenglou92.rescript-vscode">VSCode</a></li>
<li><a href="https://github.com/rescript-lang/rescript-sublime">Sublime Text</a></li>
<li><a href="https://github.com/rescript-lang/vim-rescript">Vim/Neovim</a></li>
</ul>
<h2>Community Supported</h2>
<p>We don't officially support these; use them at your own risk!</p>
<ul>
<li><a href="https://github.com/nkrkv/nvim-treesitter-rescript">Neovim Tree-sitter</a></li>
<li><a href="https://github.com/reasonml-editor/reasonml-idea-plugin">IDEA</a></li>
<li><a href="https://github.com/reasonml-editor/reason-mode">Emacs</a> (only legacy <code>v8.0.0</code> Reason/OCaml syntax support)</li>
</ul><h1>build-configuration-schema</h1><hr />
<p>title: "Configuration Schema"
metaTitle: "Build System Configuration Schema"
description: "Schema exploration widget for the ReScript configuration file"
canonical: "/docs/manual/latest/build-configuration-schema"</p>
<hr />
<p>import dynamic from "next/dynamic";</p>
<p>export const Docson = dynamic(
  () =&gt;
    import("src/components/Docson").then((comp) =&gt; {
      return comp.make;
    }),
  {
    ssr: false,
    loading: () =&gt; <div> Loading... </div>,
  }
);</p>
<p>export default function BuildConfigurationSchemaPage() {
  return <Docson tag="master" />;
}</p><h1>reserved-keywords</h1><hr />
<p>title: "Reserved Keyword"
description: "All reserved keywords in ReScript"
canonical: "/docs/manual/latest/reserved-keywords"</p>
<hr />
<h1>Reserved Keywords</h1>
<blockquote>
<p><strong>Note</strong>: Some of these words are reserved purely for backward compatibility.</p>
<p>If you <em>need</em> to use one of these names as binding and/or field name, see <a href="use-illegal-identifier-names.md">Use Illegal Identifier Names</a>.</p>
</blockquote>
<ul>
<li><code>and</code></li>
<li><code>as</code></li>
<li><code>assert</code></li>
</ul>
<!-- - `begin` -->

<!-- - `class` -->
<ul>
<li><code>constraint</code></li>
</ul>
<!-- - `do` -->
<!-- - `done` -->

<ul>
<li><code>else</code></li>
</ul>
<!-- - `end` -->
<!-- - `esfun` -->
<ul>
<li><code>exception</code></li>
<li>
<p><code>external</code></p>
</li>
<li>
<p><code>false</code></p>
</li>
<li><code>for</code></li>
</ul>
<!-- - `fun` -->
<!-- - `function` -->
<!-- - `functor` -->

<ul>
<li><code>if</code></li>
<li><code>in</code></li>
<li><code>include</code></li>
</ul>
<!-- - `inherit` -->
<!-- - `initializer` -->

<ul>
<li><code>lazy</code></li>
<li>
<p><code>let</code></p>
</li>
<li>
<p><code>module</code></p>
</li>
<li><code>mutable</code></li>
</ul>
<!-- - `new` -->
<!-- - `nonrec` -->

<!-- - `object` -->
<ul>
<li><code>of</code></li>
<li><code>open</code></li>
</ul>
<!-- - `or` -->

<!-- - `pri` -->
<!-- - `pub` -->

<ul>
<li><code>rec</code></li>
</ul>
<!-- - `sig` -->
<!-- - `struct` -->
<ul>
<li><code>switch</code></li>
</ul>
<!-- - `then` -->
<ul>
<li><code>true</code></li>
<li><code>try</code></li>
<li><code>type</code></li>
</ul>
<!-- - `val` -->
<!-- - `virtual` -->

<ul>
<li><code>when</code></li>
<li><code>while</code></li>
<li><code>with</code></li>
</ul><h1>pipe</h1><hr />
<p>title: "Pipe"
description: "The Pipe operator (-&gt;)"
canonical: "/docs/manual/latest/pipe"</p>
<hr />
<h1>Pipe</h1>
<p>ReScript provides a tiny but surprisingly useful operator <code>-&gt;</code>, called the "pipe", that allows you to "flip" your code inside-out. <code>a(b)</code> becomes <code>b-&gt;a</code>. It's a simple piece of syntax that doesn't have any runtime cost.</p>
<p>Why would you use it? Imagine you have the following:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">validateAge(getAge(parseData(person)))
</code></pre>

<pre class="codehilite"><code class="language-js">validateAge(getAge(parseData(person)));
</code></pre>

<p></CodeTab></p>
<p>This is slightly hard to read, since you need to read the code from the innermost part, to the outer parts. Use pipe to streamline it:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">person
  -&gt;parseData
  -&gt;getAge
  -&gt;validateAge
</code></pre>

<pre class="codehilite"><code class="language-js">validateAge(getAge(parseData(person)));
</code></pre>

<p></CodeTab></p>
<p>Basically, <code>parseData(person)</code> is transformed into <code>person-&gt;parseData</code>, and <code>getAge(person-&gt;parseData)</code> is transformed into <code>person-&gt;parseData-&gt;getAge</code>, etc.</p>
<p><strong>This works when the function takes more than one argument too</strong>.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">a(one, two, three)
</code></pre>

<pre class="codehilite"><code class="language-js">a(one, two, three);
</code></pre>

<p></CodeTab></p>
<p>is the same as</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">one-&gt;a(two, three)
</code></pre>

<pre class="codehilite"><code class="language-js">a(one, two, three);
</code></pre>

<p></CodeTab></p>
<p>This also works with labeled arguments.</p>
<p>Pipes are used to emulate object-oriented programming. For example, <code>myStudent.getName</code> in other languages like Java would be <code>myStudent-&gt;getName</code> in ReScript (equivalent to <code>getName(myStudent)</code>). This allows us to have the readability of OOP without the downside of dragging in a huge class system just to call a function on a piece of data.</p>
<h2>Tips &amp; Tricks</h2>
<p>Do <strong>not</strong> abuse pipes; they're a means to an end. Inexperienced engineers sometimes shape a library's API to take advantage of the pipe. This is backwards.</p>
<h2>JS Method Chaining</h2>
<p><em>This section requires understanding of <a href="bind-to-js-function.md#object-method">our binding API</a></em>.</p>
<p>JavaScript's APIs are often attached to objects, and are often chainable, like so:</p>
<pre class="codehilite"><code class="language-js">const result = [1, 2, 3].map(a =&gt; a + 1).filter(a =&gt; a % 2 === 0);

asyncRequest()
  .setWaitDuration(4000)
  .send();
</code></pre>

<p>Assuming we don't need the chaining behavior above, we'd bind to each case this using <a href="/syntax-lookup#send-decorator"><code>@send</code></a> from the aforementioned binding API page:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
type request
@val external asyncRequest: unit =&gt; request = "asyncRequest"
@send external setWaitDuration: (request, int) =&gt; request = "setWaitDuration"
@send external send: request =&gt; unit = "send"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>You'd use them like this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let result = Js.Array2.filter(
  Js.Array2.map([1, 2, 3], a =&gt; a + 1),
  a =&gt; mod(a, 2) == 0
)</p>
<p>send(setWaitDuration(asyncRequest(), 4000))</p>
<pre class="codehilite"><code>```js
var result = [1, 2, 3].map(function(a) {
  return a + 1 | 0;
}).filter(function(a) {
  return a % 2 === 0;
});

asyncRequest().setWaitDuration(4000).send();
</code></pre>

<p></CodeTab></p>
<p>This looks much worse than the JS counterpart! Clean it up visually with pipe:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let result = [1, 2, 3]
  -&gt;Js.Array2.map(a =&gt; a + 1)
  -&gt;Js.Array2.filter(a =&gt; mod(a, 2) == 0)</p>
<p>asyncRequest()-&gt;setWaitDuration(4000)-&gt;send</p>
<pre class="codehilite"><code>```js
var result = [1, 2, 3].map(function(a) {
  return a + 1 | 0;
}).filter(function(a) {
  return a % 2 === 0;
});

asyncRequest().setWaitDuration(4000).send();
</code></pre>

<p></CodeTab></p>
<h2>Pipe Into Variants</h2>
<p>You can pipe into a variant's constructor as if it was a function:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let result = name-&gt;preprocess-&gt;Some
</code></pre>

<pre class="codehilite"><code class="language-js">var result = preprocess(name);
</code></pre>

<p></CodeTab></p>
<p>We turn this into:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let result = Some(preprocess(name))
</code></pre>

<pre class="codehilite"><code class="language-js">var result = preprocess(name);
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong> that using a variant constructor as a function wouldn't work anywhere else beside here.</p>
<h2>Pipe Placeholders</h2>
<p>A placeholder is written as an underscore and it tells ReScript that you want to fill in an argument of a function later. These two have equivalent meaning:</p>
<pre class="codehilite"><code class="language-res">let addTo7 = (x) =&gt; add3(3, x, 4)
let addTo7 = add3(3, _, 4)
</code></pre>

<p>Sometimes you don't want to pipe the value you have into the first position. In these cases you can mark a placeholder value to show which argument you would like to pipe into.</p>
<p>Let's say you have a function <code>namePerson</code>, which takes a <code>person</code> then a <code>name</code> argument. If you are transforming a person then pipe will work as-is:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">makePerson(~age=47)
  -&gt;namePerson(&quot;Jane&quot;)
</code></pre>

<pre class="codehilite"><code class="language-js">namePerson(makePerson(47), &quot;Jane&quot;);
</code></pre>

<p></CodeTab></p>
<p>If you have a name that you want to apply to a person object, you can use a placeholder:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">getName(input)
  -&gt;namePerson(personDetails, _)
</code></pre>

<pre class="codehilite"><code class="language-js">var __x = getName(input);
namePerson(personDetails, __x);
</code></pre>

<p></CodeTab></p>
<p>This allows you to pipe into any positional argument. It also works for named arguments:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">getName(input)
  -&gt;namePerson(~person=personDetails, ~name=_)
</code></pre>

<pre class="codehilite"><code class="language-js">var __x = getName(input);
namePerson(personDetails, __x);
</code></pre>

<p></CodeTab></p>
<h2>Triangle Pipe (Deprecated)</h2>
<p>You might see usages of another pipe, <code>|&gt;</code>, in some codebases. These are deprecated.</p>
<p>Unlike <code>-&gt;</code> pipe, the <code>|&gt;</code> pipe puts the subject as the last (not first) argument of the function. <code>a |&gt; f(b)</code> turns into <code>f(b, a)</code>.</p>
<p>For a more thorough discussion on the rationale and differences between the two operators, please refer to the <a href="https://www.javierchavarri.com/data-first-and-data-last-a-comparison/">Data-first and Data-last comparison by Javier Chávarri</a></p><h1>faq</h1><hr />
<p>title: "FAQ"
description: "Frequently asked questions about ReScript and its ecosystem"
canonical: "/docs/manual/latest/faq"</p>
<hr />
<h1>Frequently Asked Questions</h1>
<p><strong>What's the goal of this project?</strong></p>
<p>We aim to provide the best typed language experience for the JavaScript platform.</p>
<p><strong>What’s the relationship with BuckleScript?</strong></p>
<p>BuckleScript is ReScript's old branding, with a sharper focus on proper JS support and familiarity which we previously couldn't achieve to the degree we wanted, due to us needing to cater to various different crowds.</p>
<p><strong>What’s ReScript's relationship with OCaml?</strong></p>
<p>We reuse and adjust the excellent type system and lots of other high quality components from OCaml for JS experience. 
Additionally, ReScript provides its own syntax, build system, IDE, backend, JS interop, extra language features, etc. </p>
<p>The ReScript toolchain is developed using OCaml, however, the version of ReScript is decoupled against the version of OCaml, 
ReScript compiler should build against any reasonable modern version of OCaml compiler.</p>
<p>For the majority of ReScript users, they don't need to learn OCaml or use OCaml toolchain to be productive in ReScript.</p>
<p><strong>What’s the relationship with Reason?</strong></p>
<p>See <a href="/blog/bucklescript-is-rebranding">here</a>. Reason is a syntax layer for OCaml that BuckleScript also adopted. The current ReScript compiler also supports the old Reason syntax v3.6 for backward compatibility. We will support it for a long time to make sure existing users do not get breaking changes.</p>
<p><strong>I come from Reason/OCaml. Will ReScript keep supporting X?</strong></p>
<p>Please see our <a href="/blog/a-note-on-bucklescripts-future-commitments">blog post</a> on this matter.</p>
<p><strong>Where can I see the docs in old Reason/OCaml syntax?</strong></p>
<p>Switch the doc version to <code>v8.0.0</code> in the sidebar on the left!</p>
<p><strong>Will ReScript support native compilation eventually?</strong></p>
<p>Our focus is a solid JS story right now. In the future, if there’s strong demand, we might consider it.</p>
<p><strong>What’s the current state of ReScript?</strong></p>
<p>Currently, we're actively working on the editor support.</p>
<p><strong>When will we get the <code>async/await</code> keywords?</strong></p>
<p>See our answer on the <a href="promise">Async &amp; Promise</a> page's intro.</p>
<p><strong>Why create a new syntax?</strong></p>
<p>The existing Reason syntax is owned by a different team with a different vision. Reason aims to be 100% compatible with OCaml syntax and to support all versions of OCaml. In the last few years, we've drawn the conclusion that it’s very hard to deliver such goal without sacrificing user experience. The other reason is that we feel it’s better to have the same vision as a team so that we can make more coherent decisions.</p>
<p><strong>Who is behind the project?</strong></p>
<p>The ReScript team (Hongbo, Cheng, Cristiano, Maxim, Patrick, Ricky).</p>
<p><strong>We have a new forum; will we also have our own Discord?</strong></p>
<p>Not now. We've found that too much important information get casually passed in Discord then lost within the noise. We prefer folks to communicate on the <a href="https://forum.rescript-lang.org">forum</a>. This is nicer to the less active members.</p>
<p>The team doesn't use the old Discord anymore. We encourage you to move your questions to the forum instead.</p><h1>try</h1><hr />
<p>title: "Try"
description: "Try ReScript via Command Line"
canonical: "/docs/manual/latest/try"</p>
<hr />
<h2>Try Online</h2>
<p>Our <a href="/try">Playground</a> lets you try ReScript online, and comes with <a href="/docs/react/latest/introduction">ReScript-React</a> and the new <a href="https://github.com/rescript-association/rescript-core">ReScript-Core</a> standard library preinstalled.</p><h1>api</h1><h1>Overview</h1>
<p>ReScript ships 3 modules in its standard library.</p>
<ul>
<li><a href="api/js">Js</a>: bindings for all your familiar JavaScript APIs.</li>
<li><a href="api/belt">Belt</a>: extra collections and helpers not available in JavaScript.</li>
<li><a href="api/dom">Dom</a>: Dom related types and modules.</li>
</ul>
<p>Usage heuristics:</p>
<ul>
<li>Default to using the <code>Js</code> module. Most of the APIs in it are runtime-free and compile down to clean, readable JavaScript, which is our priority.</li>
<li>For other APIs that aren't available in regular JavaScript (and thus don't exist in our <code>Js</code> bindings), use Belt. For example, prefer <code>Js.Array2</code> over <code>Belt.Array</code>.</li>
<li>The <code>Dom</code> module contains our standardized types used by various userland DOM bindings. Due to the complexity of DOM, we don't mind that you ignore this module and build your application-specific DOM bindings.</li>
</ul>
<p><strong>Note</strong>: we do not recommend other userland standard library alternatives (unless it's DOM bindings). These cause confusion and split points for the community.</p><h1>async-await</h1><hr />
<p>title: "Async / Await"
description: "Async / await for asynchronous operations"
canonical: "/docs/manual/latest/async-await"</p>
<hr />
<!-- This prelude is used in many different followup examples, so we use it to shorten the noise of the example code. -->
<div className="hidden">

```res prelude
@val external fetchUserMail: string => promise<string> = "GlobalAPI.fetchUserMail"
@val external sendAnalytics: string => promise<unit> = "GlobalAPI.sendAnalytics"

<pre class="codehilite"><code>&lt;/div&gt;

&lt;!-- See https://github.com/cristianoc/rescript-compiler-experiments/pull/1#issuecomment-1131182023 for all async/await use-case examples --&gt;

# Async / Await

ReScript comes with `async` / `await` support to make asynchronous, `Promise` based code easier to read and write. This feature is very similar to its JS equivalent, so if you are already familiar with JS' `async` / `await`, you will feel right at home.

## How it looks 

Let's start with a quick example to show-case the syntax:


&lt;CodeTab labels={[&quot;ReScript&quot;, &quot;JS Output&quot;]}&gt;

```res
// Some fictive functionality that offers asynchronous network actions
@val external fetchUserMail: string =&gt; promise&lt;string&gt; = &quot;GlobalAPI.fetchUserMail&quot;
@val external sendAnalytics: string =&gt; promise&lt;unit&gt; = &quot;GlobalAPI.sendAnalytics&quot;

// We use the `async` keyword to allow the use of `await` in the function body
let logUserDetails = async (userId: string) =&gt; {
  // We use `await` to fetch the user email from our fictive user endpoint
  let email = await fetchUserMail(userId)

  await sendAnalytics(`User details have been logged for ${userId}`)

  Js.log(`Email address for user ${userId}: ${email}`)
}
</code></pre>




<pre class="codehilite"><code class="language-js">async function logUserDetails(userId) {
  var email = await GlobalAPI.fetchUserMail(userId);
  await GlobalAPI.sendAnalytics(&quot;User details have been logged for &quot; + userId + &quot;&quot;);
  console.log(&quot;Email address for user &quot; + userId + &quot;: &quot; + email + &quot;&quot;);
}
</code></pre>



</CodeTab>

As we can see above, an `async` function is defined via the `async` keyword right before the function's parameter list. In the function body, we are now able to use the `await` keyword to explicitly wait for a `Promise` value and assign its content to a let binding `email`.

You will probably notice that this looks very similar to `async` / `await` in JS, but there are still a few details that are specific to ReScript. The next few sections will go through all the details that are specific to the ReScript type system.

## Basics

- You may only use `await` in `async` function bodies
- `await` may only be called on a `promise` value
- `await` calls are expressions, therefore they can be used in pattern matching (`switch`)
- A function returning a `promise<'a>` is equivalent to an `async` function returning a value `'a` (important for writing signature files and bindings)
- `promise` values and types returned from an `async` function don't auto-collapse into a "flat promise" like in JS (more on this later)


## Types and `async` functions

### `async` function type signatures

Function type signatures (i.e defined in signature files) don't require any special keywords for `async` usage. Whenever you want to type an `async` function, use a `promise` return type.


<pre class="codehilite"><code class="language-resi">// Demo.resi

let fetchUserMail: string =&gt; promise&lt;string&gt;
</code></pre>



The same logic applies to type definitions in `.res` files:

```res example
// function type
type someAsyncFn = int => promise<int>

// Function type annotation
let fetchData: string => promise<string> = async (userId) => {
  await fetchUserMail(userId)
}

<pre class="codehilite"><code>**BUT:** When typing `async` functions in your implementation files, you need to omit the `promise&lt;'a&gt;` type:

```res
// This function is compiled into a `string =&gt; promise&lt;string&gt;` type.
// The promise&lt;...&gt; part is implicitly added by the compiler.
let fetchData = async (userId: string): string =&gt; {
  await fetchUserMail(&quot;test&quot;)
}
</code></pre>



For completeness reasons, let's expand the full signature and inline type definitions in one code snippet:


<pre class="codehilite"><code class="language-res">// Note how the inline return type uses `string`, while the type definition uses `promise&lt;string&gt;`
let fetchData: string =&gt; promise&lt;string&gt; = async (userId: string): string {
  await fetchUserMail(userId)
}
</code></pre>



**Note:** In a practical scenario you'd either use a type signature, or inline types, not both at the same time. In case you are interested in the design decisions, check out [this discussion](https://github.com/rescript-lang/rescript-compiler/pull/5913#issuecomment-1359003870).

### Promises don't auto-collapse in async functions

In JS, nested promises (i.e. `promise<promise<'a>>`) will automatically collapse into a flat promise (`promise<'a>`). This is not the case in ReScript. Use the `await` function to manually unwrap any nested promises within an `async` function instead.


<pre class="codehilite"><code class="language-res">let fetchData = async (userId: string): string =&gt; {
  // We can't just return the result of `fetchUserMail`, otherwise we'd get a
  // type error due to our function return type of type `string`
  await fetchUserMail(userId)
}
</code></pre>



## Error handling

You may use `try / catch` or `switch` to handle exceptions during async execution.


<pre class="codehilite"><code class="language-res">// For simulation purposes
let authenticate = async () =&gt; {
  raise(Js.Exn.raiseRangeError(&quot;Authentication failed.&quot;))
}

let checkAuth = async () =&gt; {
  try {
    await authenticate()
  } catch {
  | Js.Exn.Error(e) =&gt;
    switch Js.Exn.message(e) {
    | Some(msg) =&gt; Js.log(&quot;JS error thrown: &quot; ++ msg)
    | None =&gt; Js.log(&quot;Some other exception has been thrown&quot;)
    }
  }
}
</code></pre>



Note how we are essentially catching JS errors the same way as described in our [Exception](exception#catch-rescript-exceptions-from-js) section.

You may unify error and value handling in a single switch as well:


<pre class="codehilite"><code class="language-res">let authenticate = async () =&gt; {
  raise(Js.Exn.raiseRangeError(&quot;Authentication failed.&quot;))
}

let checkAuth = async () =&gt; {
  switch await authenticate() {
  | _ =&gt; Js.log(&quot;ok&quot;)
  | exception Js.Exn.Error(e) =&gt; 
    switch Js.Exn.message(e) {
    | Some(msg) =&gt; Js.log(&quot;JS error thrown: &quot; ++ msg)
    | None =&gt; Js.log(&quot;Some other exception has been thrown&quot;)
    }
  }
}
</code></pre>



**Important:** When using `await` with a `switch`, always make sure to put the actual await call in the `switch` expression, otherwise your `await` error will not be caught.

## Piping `await` calls

You may want to pipe the result of an `await` call right into another function.
This can be done by wrapping your `await` calls in a new `{}` closure.

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
@val external fetchUserMail: string => promise<string> = "GlobalAPI.fetchUserMail"

let fetchData = async () => {
  let mail = {await fetchUserMail("1234")}->Js.String2.toUpperCase
  Js.log(`All upper-cased mail: ${mail}`)
}

<pre class="codehilite"><code>```js
async function fetchData(param) {
  var mail = (await GlobalAPI.fetchUserMail(&quot;1234&quot;)).toUpperCase();
  console.log(&quot;All upper-cased mail: &quot; + mail + &quot;&quot;);
}
</code></pre>



</CodeTab>

Note how the original closure was removed in the final JS output. No extra allocations!

## Pattern matching on `await` calls

`await` calls are just another kind of expression, so you can use `switch` pattern matching for more complex logic.

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
@val external fetchUserMail: string => promise<string> = "GlobalAPI.fetchUserMail"

let fetchData = async () => {
  switch (await fetchUserMail("user1"), await fetchUserMail("user2")) {
  | (user1Mail, user2Mail) => {
      Js.log("user 1 mail: " ++ user1Mail)
      Js.log("user 2 mail: " ++ user2Mail)
    }

  | exception JsError(err) => Js.log2("Some error occurred", err)
  }
}

<pre class="codehilite"><code>```js
async function fetchData(param) {
  var val;
  var val$1;
  try {
    val = await GlobalAPI.fetchUserMail(&quot;user1&quot;);
    val$1 = await GlobalAPI.fetchUserMail(&quot;user2&quot;);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === &quot;JsError&quot;) {
      console.log(&quot;Some error occurred&quot;, err._1);
      return ;
    }
    throw err;
  }
  console.log(&quot;user 1 mail: &quot; + val);
  console.log(&quot;user 2 mail: &quot; + val$1);
}
</code></pre>



</CodeTab>

## `await` multiple promises

We can utilize the `Js.Promise2` module to handle multiple promises. E.g. let's use `Js.Promise2.all` to wait for multiple promises before continuing the program:


<pre class="codehilite"><code class="language-res">let pauseReturn = (value, timeout) =&gt; {
  Js.Promise2.make((~resolve, ~reject) =&gt; {
    Js.Global.setTimeout(() =&gt; {
      resolve(. value)
    }, timeout)-&gt;ignore
  })
}

let logMultipleValues = async () =&gt; {
  let promise1 = pauseReturn(&quot;value1&quot;, 2000)
  let promise2 = pauseReturn(&quot;value2&quot;, 1200)
  let promise3 = pauseReturn(&quot;value3&quot;, 500)

  let all = await Js.Promise2.all([promise1, promise2, promise3])

  switch all {
  | [v1, v2, v3] =&gt; Js.log(`All values: ${v1}, ${v2}, ${v3}`)
  | _ =&gt; Js.log(&quot;this should never happen&quot;)
  }
}
</code></pre>



## JS Interop with `async` functions

`async` / `await` practically works with any function that returns a `promise<'a>` value. Map your `promise` returning function via an `external`, and use it in an `async` function as usual.

Here's a full example of using the MDN `fetch` API, using `async` / `await` to simulate a login:


<pre class="codehilite"><code class="language-res">// A generic Response type for typing our fetch requests
module Response = {
  type t&lt;'data&gt;
  @send external json: t&lt;'data&gt; =&gt; promise&lt;'data&gt; = &quot;json&quot;
}

// A binding to our globally available `fetch` function. `fetch` is a
// standardized function to retrieve data from the network that is available in
// all modern browsers.
@val @scope(&quot;globalThis&quot;)
external fetch: (
  string,
  'params,
) =&gt; promise&lt;Response.t&lt;{&quot;token&quot;: Js.Nullable.t&lt;string&gt;, &quot;error&quot;: Js.Nullable.t&lt;string&gt;}&gt;&gt; =
  &quot;fetch&quot;

// We now use our asynchronous `fetch` function to simulate a login.
// Note how we use `await` with regular functions returning a `promise`.
let login = async (email: string, password: string) =&gt; {
  let body = {
    &quot;email&quot;: email,
    &quot;password&quot;: password,
  }

  let params = {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;headers&quot;: {
      &quot;Content-Type&quot;: &quot;application/json&quot;,
    },
    &quot;body&quot;: Js.Json.stringifyAny(body),
  }

  try {
    let response = await fetch(&quot;https://reqres.in/api/login&quot;, params)
    let data = await response-&gt;Response.json

    switch Js.Nullable.toOption(data[&quot;error&quot;]) {
    | Some(msg) =&gt; Error(msg)
    | None =&gt;
      switch Js.Nullable.toOption(data[&quot;token&quot;]) {
      | Some(token) =&gt; Ok(token)
      | None =&gt; Error(&quot;Didn't return a token&quot;)
      }
    }
  } catch {
  | _ =&gt; Error(&quot;Unexpected network error occurred&quot;)
  }
}
</code></pre><h1>bind-to-js-object</h1><hr />
<p>title: "Bind to JS Object"
description: "Interop with JS objects in ReScript"
canonical: "/docs/manual/latest/bind-to-js-object"</p>
<hr />
<h1>Bind to JS Object</h1>
<p>JavaScript objects are a combination of several use-cases:</p>
<ul>
<li>As a "record" or "struct" in other languages (like ReScript and C).</li>
<li>As a hash map.</li>
<li>As a class.</li>
<li>As a module to import/export.</li>
</ul>
<p>ReScript cleanly separates the binding methods for JS object based on these 4 use-cases. This page documents the first three. Binding to JS module objects is described in the <a href="import-from-export-to-js.md">Import from/Export to JS</a> section.</p>
<!-- TODO: mention scope here too? -->

<h2>Bind to Record-like JS Objects</h2>
<h3>Bind Using ReScript Record</h3>
<p>If your JavaScript object has fixed fields, then it's conceptually like a ReScript record. Since a ReScript record compiles to a clean JavaScript object, you can definitely type a JS object as a ReScript record!</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  name: string,
  friends: array<string>,
  age: int,
}</p>
<p>@module("MySchool") external john: person = "john"</p>
<p>let johnName = john.name</p>
<pre class="codehilite"><code>```js
var MySchool = require(&quot;MySchool&quot;);

var johnName = MySchool.john.name;
</code></pre>

<p></CodeTab></p>
<p>External is documented <a href="external.md">here</a>. <code>@module</code> is documented <a href="import-from-export-to-js.md">here</a>.</p>
<p>If you want or need to use different field names on the ReScript and the JavaScript side, you can use the <code>@as</code> decorator:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type action = {
  @as("type") type_: string
}</p>
<p>let action = {type_: "ADD_USER"}</p>
<pre class="codehilite"><code>```js
var action = {
  type: &quot;ADD_USER&quot;
};
</code></pre>

<p></CodeTab></p>
<p>This is useful to map to JavaScript attribute names that cannot be expressed in ReScript (such as keywords).</p>
<p>It is also possible to map a ReScript record to a JavaScript array by passing indices to the <code>@as</code> decorator:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type t = {
  @as(&quot;0&quot;) foo: int,
  @as(&quot;1&quot;) bar: string,
}

let value = {foo: 7, bar: &quot;baz&quot;}
</code></pre>

<pre class="codehilite"><code class="language-js">var value = [
  7,
  &quot;baz&quot;
];
</code></pre>

<p></CodeTab></p>
<h3>Bind Using ReScript Object</h3>
<p>Alternatively, you can use <a href="object.md">ReScript object</a> to model a JS object too:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type person = {
  "name": string,
  "friends": array<string>,
  "age": int,
}</p>
<p>@module("MySchool") external john: person = "john"</p>
<p>let johnName = john["name"]</p>
<pre class="codehilite"><code>```js
var MySchool = require(&quot;MySchool&quot;);

var johnName = MySchool.john.name;
</code></pre>

<p></CodeTab></p>
<h3>Bind Using Special Getter and Setter Attributes</h3>
<p>Alternatively, you can use <code>get</code> and <code>set</code> to bind to individual fields of a JS object:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type textarea
@set external setName: (textarea, string) =&gt; unit = "name"
@get external getName: textarea =&gt; string = "name"</p>
<pre class="codehilite"><code>```js
</code></pre>

<p></CodeTab></p>
<p>You can also use <code>get_index</code> and <code>set_index</code> to access a dynamic property or an index:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type t
@new external create: int =&gt; t = "Int32Array"
@get_index external get: (t, int) =&gt; int = ""
@set_index external set: (t, int, int) =&gt; unit = ""</p>
<p>let i32arr = create(3)
i32arr-&gt;set(0, 42)
Js.log(i32arr-&gt;get(0))</p>
<pre class="codehilite"><code>```js
var i32arr = new Int32Array(3);
i32arr[0] = 42;
console.log(i32arr[0]);
</code></pre>

<p></CodeTab></p>
<h2>Bind to Hash Map-like JS Object</h2>
<p>If your JavaScript object:</p>
<ul>
<li>might or might not add/remove keys</li>
<li>contains only values that are of the same type</li>
</ul>
<p>Then it's not really an object, it's a hash map. Use <a href="api/js/dict">Js.Dict</a>, which contains operations like <code>get</code>, <code>set</code>, etc. and cleanly compiles to a JavaScript object still.</p>
<h2>Bind to a JS Object That's a Class</h2>
<p>Use <code>new</code> to emulate e.g. <code>new Date()</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type t
@new external createDate: unit =&gt; t = "Date"</p>
<p>let date = createDate()</p>
<pre class="codehilite"><code>```js
var date = new Date();
</code></pre>

<p></CodeTab></p>
<p>You can chain <code>new</code> and <code>module</code> if the JS module you're importing is itself a class:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type t
@new @module external book: unit =&gt; t = "Book"
let myBook = book()</p>
<pre class="codehilite"><code>```js
var Book = require(&quot;Book&quot;);
var myBook = new Book();
</code></pre>

<p></CodeTab></p><h1>extensible-variant</h1><hr />
<p>title: "Extensible Variant"
description: "Extensible Variants in ReScript"
canonical: "/docs/manual/latest/extensible-variant"</p>
<hr />
<h1>Extensible Variant</h1>
<p>Variant types are usually constrained to a fixed set of constructors. There may be very rare cases where you still want to be able to add constructors to a variant type even after its initial type declaration. For this, we offer extensible variant types.</p>
<h2>Definition and Usage</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type t = ..</p>
<p>type t += Other</p>
<p>type t +=
  | Point(float, float)
  | Line(float, float, float, float)</p>
<pre class="codehilite"><code>```js
var Caml_exceptions = require(&quot;./stdlib/caml_exceptions.js&quot;);

var Other = Caml_exceptions.create(&quot;Playground.Other&quot;);

var Point = Caml_exceptions.create(&quot;Playground.Point&quot;);

var Line = Caml_exceptions.create(&quot;Playground.Line&quot;);
</code></pre>

<p></CodeTab></p>
<p>The <code>..</code> in the type declaration above defines an extensible variant <code>type t</code>. The <code>+=</code> operator is then used to add constructors to the given type. </p>
<p><strong>Note:</strong> Don't forget the leading <code>type</code> keyword when using the <code>+=</code> operator!</p>
<h2>Pattern Matching Caveats</h2>
<p>Extensible variants are open-ended, so the compiler will not be able to exhaustively pattern match all available cases. You will always need to provide a default <code>_</code> case for every <code>switch</code> expression. </p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let print = v =&gt;
  switch v {
  | Point(x, y) =&gt; Js.log2(&quot;Point&quot;, (x, y))
  | Line(ax, ay, bx, by) =&gt; Js.log2(&quot;Line&quot;, (ax, ay, bx, by))
  | Other
  | _ =&gt; Js.log(&quot;Other&quot;)
  }
</code></pre>

<pre class="codehilite"><code class="language-js">function print(v) {
  if (v.RE_EXN_ID === Point) {
    console.log(&quot;Point&quot;, [v._1, v._2]);
  } else if (v.RE_EXN_ID === Line) {
    console.log(&quot;Line&quot;, [v._1, v._2, v._3, v._4]);
  } else {
    console.log(&quot;Other&quot;);
  } 
}
</code></pre>

<p></CodeTab></p>
<h2>Tips &amp; Tricks</h2>
<p><strong>Fun fact:</strong> In ReScript, <a href="./exception">exceptions</a> are actually extensible variants under the hood, so <code>exception UserError(string)</code> is equivalent to <code>type exn += UserError(string)</code>. It's one of the very few use-case where extensible variants make sense.</p>
<p>We usually recommend sticking with common <a href="./variant">variants</a> as much as possible to reap the benefits of exhaustive pattern matching.</p><h1>interop-cheatsheet</h1><hr />
<p>title: "Interop Cheatsheet"
description: "Cheatsheet for various interop scenarios in ReScript"
canonical: "/docs/manual/latest/interop-cheatsheet"</p>
<hr />
<h1>Interop Cheatsheet</h1>
<p>This is a glossary with examples. All the features are described by later pages.</p>
<h2>List of Decorators</h2>
<blockquote>
<p><strong>Note:</strong> In ReScript &lt; 8.3, all our attributes started with the <code>bs.</code> prefix. This is no longer needed and our formatter automatically removes them in newer ReScript versions.</p>
</blockquote>
<!-- Synced from https://github.com/rescript-lang/syntax/blob/123760c5a264da5288eeee5213ddd25eb86d62fe/src/res_printer.ml#L19-L51 -->

<h3>Attributes</h3>
<ul>
<li><code>@as</code>: <a href="attribute#usage">here</a>, <a href="bind-to-js-function#fixed-arguments">here</a>, <a href="bind-to-js-function#constrain-arguments-better">here</a> and <a href="generate-converters-accessors#usage-3">here</a></li>
<li><a href="generate-converters-accessors#generate-functions--plain-values-for-variants"><code>@deriving</code></a></li>
<li><a href="bind-to-js-object#bind-using-special-bs-getters--setters"><code>@get</code></a></li>
<li><a href="bind-to-js-object#bind-using-special-bs-getters--setters"><code>@get_index</code></a></li>
</ul>
<!-- - `@ignore` -->
<ul>
<li><a href="inlining-constants"><code>@inline</code></a></li>
<li><a href="bind-to-js-function#constrain-arguments-better"><code>@int</code></a></li>
</ul>
<!-- - `@meth` -->
<ul>
<li><a href="import-from-export-to-js#import-a-javascript-modules-content"><code>@module</code></a></li>
<li><a href="bind-to-js-object#bind-to-a-js-object-thats-a-class"><code>@new</code></a></li>
<li><a href="generate-converters-accessors#convert-external-into-js-object-creation-function"><code>@obj</code></a></li>
<li><a href="generate-converters-accessors#optional-labels"><code>@optional</code></a></li>
<li><a href="bind-to-js-function#function-nullable-return-value-wrapping"><code>@return</code></a></li>
<li><code>@send</code>: <a href="bind-to-js-function#object-method">here</a> and <a href="pipe#js-method-chaining">here</a></li>
<li><a href="bind-to-global-js-values#global-modules"><code>@scope</code></a></li>
<li><a href="bind-to-js-object#bind-using-special-bs-getters--setters"><code>@set</code></a></li>
<li><a href="bind-to-js-object#bind-using-special-bs-getters--setters"><code>@set_index</code></a></li>
<li><a href="bind-to-js-function#variadic-function-arguments"><code>@variadic</code></a></li>
<li><a href="bind-to-js-function#constrain-arguments-better"><code>@string</code></a></li>
<li><a href="bind-to-js-function#modeling-this-based-callbacks"><code>@this</code></a></li>
<li><a href="bind-to-js-function#extra-solution"><code>@uncurry</code></a></li>
<li><a href="bind-to-js-function#trick-2-polymorphic-variant--bsunwrap"><code>@unwrap</code></a></li>
<li>
<p><a href="bind-to-global-js-values#global-modules"><code>@val</code></a></p>
</li>
<li>
<p><a href="attribute#usage"><code>@deprecated</code></a></p>
</li>
<li><a href="https://github.com/reason-association/genType"><code>genType</code></a></li>
<li><a href="jsx"><code>@JSX</code></a></li>
<li><code>@react.component</code>: <a href="/docs/react/latest/introduction">here</a> and <a href="https://github.com/reasonml/reason-react">here</a></li>
<li><a href="attribute#usage"><code>@warning</code></a></li>
<li><a href="unboxed"><code>@unboxed</code></a></li>
</ul>
<h3>Extension Points</h3>
<ul>
<li><a href="embed-raw-javascript#debugger"><code>%debugger</code></a></li>
<li><a href="bind-to-global-js-values#special-global-values"><code>%external</code></a></li>
</ul>
<!-- - `%node` -->
<!-- - `%obj` -->
<ul>
<li><a href="embed-raw-javascript#paste-raw-js-code"><code>%raw</code></a></li>
<li><a href="primitive-types#regular-expression"><code>%re</code></a></li>
</ul>
<h2>Raw JS</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let add = %raw("(a, b) =&gt; a + b")
%%raw("const a = 1")</p>
<pre class="codehilite"><code>```js
var add = ((a, b) =&gt; a + b);
const a = 1
</code></pre>

<p></CodeTab></p>
<h2>Global Value</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val external setTimeout: (unit =&gt; unit, int) =&gt; float = "setTimeout"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Global Module's Value</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val @scope("Math")
external random: unit =&gt; float = "random"</p>
<p>let someNumber = random()</p>
<p>@val @scope(("window", "location", "ancestorOrigins"))
external length: int = "length"</p>
<pre class="codehilite"><code>```js
var someNumber = Math.random();
</code></pre>

<p></CodeTab></p>
<h2>Nullable</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let a = Some(5) // compiles to 5
let b = None // compiles to undefined</p>
<pre class="codehilite"><code>```js
var a = 5;
var b;
</code></pre>

<p></CodeTab></p>
<p>Handling a value that can be <code>undefined</code> and <code>null</code>, by ditching the <code>option</code> type and using <code>Js.Nullable.t</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let jsNull = Js.Nullable.null
let jsUndefined = Js.Nullable.undefined
let result1: Js.Nullable.t<string> = Js.Nullable.return("hello")
let result2: Js.Nullable.t<int> = Js.Nullable.fromOption(Some(10))
let result3: option<int> = Js.Nullable.toOption(Js.Nullable.return(10))</p>
<pre class="codehilite"><code>```js
var Caml_option = require(&quot;./stdlib/caml_option.js&quot;);
var Js_null_undefined = require(&quot;./stdlib/js_null_undefined.js&quot;);

var jsNull = null;
var jsUndefined;
var result1 = &quot;hello&quot;;
var result2 = Js_null_undefined.fromOption(10);
var result3 = Caml_option.nullable_to_opt(10);
</code></pre>

<p></CodeTab></p>
<h2>JS Object</h2>
<ul>
<li><a href="bind-to-js-object#bind-to-record-like-js-objects">Bind to a JS object as a ReScript record</a>.</li>
<li><a href="bind-to-js-object#bind-to-hash-map-like-js-object">Bind to a JS object that acts like a hash map</a>.</li>
<li><a href="bind-to-js-object#bind-to-a-js-object-thats-a-class">Bind to a JS object that's a class</a>.</li>
</ul>
<h2>Function</h2>
<h3>Object Method &amp; Chaining</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@send external map: (array&lt;'a&gt;, 'a =&gt; 'b) =&gt; array&lt;'b&gt; = "map"
@send external filter: (array&lt;'a&gt;, 'a =&gt; 'b) =&gt; array&lt;'b&gt; = "filter"
[1, 2, 3]
  -&gt;map(a =&gt; a + 1)
  -&gt;filter(a =&gt; mod(a, 2) == 0)
  -&gt;Js.log</p>
<pre class="codehilite"><code>```js
console.log(
  [1, 2, 3]
    .map(function (a) {
      return (a + 1) | 0;
    })
    .filter(function (a) {
      return a % 2 === 0;
    })
);
</code></pre>

<p></CodeTab></p>
<h3>Variadic Arguments</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("path") @variadic
external join: array<string> =&gt; string = "join"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h3>Polymorphic Function</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("Drawing") external drawCat: unit =&gt; unit = "draw"
@module("Drawing") external drawDog: (~giveName: string) =&gt; unit = "draw"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@val
external padLeft: (
  string,
  @unwrap [
    | #Str(string)
    | #Int(int)
  ])
  =&gt; string = "padLeft"</p>
<p>padLeft("Hello World", #Int(4))
padLeft("Hello World", #Str("Message from ReScript: "))</p>
<pre class="codehilite"><code>```js
padLeft(&quot;Hello World&quot;, 4);
padLeft(&quot;Hello World&quot;, &quot;Message from ReScript: &quot;);
</code></pre>

<p></CodeTab></p>
<h2>JS Module Interop</h2>
<p><a href="import-from-export-to-js.md">See here</a></p>
<h2>Dangerous Type Cast</h2>
<p>Final escape hatch converter. Do not abuse.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
external convertToFloat: int =&gt; float = "%identity"
let age = 10
let gpa = 2.1 +. convertToFloat(age)</p>
<pre class="codehilite"><code>```js
var age = 10;
var gpa = 2.1 + 10;
</code></pre>

<p></CodeTab></p><h1>array-and-list</h1><hr />
<p>title: "Array &amp; List"
description: "Arrays and List data structures"
canonical: "/docs/manual/latest/array-and-list"</p>
<hr />
<h1>Array and List</h1>
<h2>Array</h2>
<p>Arrays are our main ordered data structure. They work the same way as JavaScript arrays: they can be randomly accessed, dynamically resized, updated, etc.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myArray = ["hello", "world", "how are you"]</p>
<pre class="codehilite"><code>```js
var myArray = [&quot;hello&quot;, &quot;world&quot;, &quot;how are you&quot;];
</code></pre>

<p></CodeTab></p>
<p>ReScript arrays' items must have the same type, i.e. homogeneous.</p>
<h3>Usage</h3>
<p>See the <a href="api/js/array">Js.Array</a> API.</p>
<p>Access &amp; update an array item like so:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myArray = ["hello", "world", "how are you"]</p>
<p>let firstItem = myArray[0] // "hello"</p>
<p>myArray[0] = "hey" // now ["hey", "world", "how are you"]</p>
<p>let pushedValue = Js.Array2.push(myArray, "bye")</p>
<pre class="codehilite"><code>```js
var myArray = [&quot;hello&quot;, &quot;world&quot;, &quot;how are you&quot;];

var firstItem = myArray[0];

myArray[0] = &quot;hey&quot;;

var pushedValue = myArray.push(&quot;bye&quot;);
</code></pre>

<p></CodeTab></p>
<h2>List</h2>
<p>ReScript provides a singly linked list too. Lists are:</p>
<ul>
<li>immutable</li>
<li>fast at prepending items</li>
<li>fast at getting the head</li>
<li>slow at everything else</li>
</ul>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let myList = list{1, 2, 3}</p>
<pre class="codehilite"><code>```js
var myList = {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: 0
    }
  }
};
</code></pre>

<p></CodeTab></p>
<p>Like arrays, lists' items need to be of the same type.</p>
<h3>Usage</h3>
<p>You'd use list for its resizability, its fast prepend (adding at the head), and its fast split, all of which are immutable and relatively efficient.</p>
<p>Do <strong>not</strong> use list if you need to randomly access an item or insert at non-head position. Your code would end up obtuse and/or slow.</p>
<p>The standard lib provides a <a href="api/belt/list">List module</a>.</p>
<h4>Immutable Prepend</h4>
<p>Use the spread syntax:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
let myList = list{1, 2, 3}
let anotherList = list{0, ...myList}</p>
<pre class="codehilite"><code>```js
var myList = {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: 0
    }
  }
};

var anotherList = {
  hd: 0,
  tl: myList
};
</code></pre>

<p></CodeTab></p>
<p><code>myList</code> didn't mutate. <code>anotherList</code> is now <code>list{0, 1, 2, 3}</code>. This is efficient (constant time, not linear). <code>anotherList</code>'s last 3 elements are shared with <code>myList</code>!</p>
<p><strong>Note that <code>list{a, ...b, ...c}</code> was a syntax error</strong> before compiler v10.1. In general, the pattern should be used with care as its performance and allocation overhead are linear (<code>O(n)</code>).</p>
<h4>Access</h4>
<p><code>switch</code> (described in the <a href="pattern-matching-destructuring.md">pattern matching section</a>) is usually used to access list items:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let message =
  switch myList {
  | list{} =&gt; "This list is empty"
  | list{a, ...rest} =&gt; "The head of the list is the string " ++ Js.Int.toString(a)
  }</p>
<pre class="codehilite"><code>```js
var message = myList
  ? &quot;The head of the list is the string &quot; + (1).toString()
  : &quot;This list is empty&quot;;
</code></pre>

<p></CodeTab></p><h1>interop-with-js-build-systems</h1><hr />
<p>title: "Interop with JS Build Systems"
description: "Documentation on how to interact with existing JS build systems"
canonical: "/docs/manual/latest/interop-with-js-build-systems"</p>
<hr />
<h1>Interop with JS Build Systems</h1>
<p>If you come from JS, chances are that you already have a build system in your existing project. Here's an overview of the role <code>rescript</code> would play in your build pipeline, if you want to introduce some ReScript code.</p>
<blockquote>
<p><strong>Please</strong> try not to wrap <code>rescript</code> into your own incremental build framework. ReScript's compilation is very hard to get right, and you'll inevitably run into stale or badly performing builds (therefore erasing much of our value proposition) if you create your own meta layer on top.</p>
</blockquote>
<h2>Popular JS Build Systems</h2>
<p>The JS ecosystem uses a few build systems: <a href="http://browserify.org/">browserify</a>, <a href="https://github.com/rollup/rollup">rollup</a>, <a href="https://webpack.js.org/">webpack</a>, etc. The latter's probably the most popular of the three (as of 2019 =P). These build systems do both the compilation and the linking (aka, bundling many files into one or few files).</p>
<p><code>rescript</code> only take care of the compilation step; it maps one <code>.res</code>/<code>.resi</code> file into one JS output file. As such, in theory, no build system integration is needed from our side. From e.g. the webpack watcher's perspective, the JS files ReScript generates are almost equivalent to your hand-written JS files. We also recommend <strong>that you initially check in those ReScript-generated JS files</strong>, as this workflow means:</p>
<ul>
<li>You can introduce ReScript silently into your codebase without disturbing existing infra.</li>
<li>You have a <strong>visual</strong> diff of the performance &amp; correctness of your JS file when you update the <code>.res</code> files and the JS artifacts change.</li>
<li>You can let teammates hot-patch the JS files in emergency situations, without needing to first start learning ReScript.</li>
<li>You can remove ReScript completely from your codebase and things will still work (in case your company decides to stop using us for whatever reason).</li>
</ul>
<p>For what it's worth, you can also turn <code>rescript</code> into an automated step in your build pipeline, e.g. into a Webpack loader; but such approach is error-prone and therefore discouraged.</p>
<h3>Tips &amp; Tricks</h3>
<p>You can make ReScript JS files look even more idiomatic through the in-source + bs suffix config in <code>rescript.json</code>:</p>
<pre class="codehilite"><code class="language-json">{
  &quot;package-specs&quot;: {
    &quot;module&quot;: &quot;commonjs&quot;, // or whatever module system your project uses
    &quot;in-source&quot;: true
  },
  &quot;suffix&quot;: &quot;.bs.js&quot;
}
</code></pre>

<p>This will:</p>
<ul>
<li>Generate the JS files alongside your ReScript source files.</li>
<li>Use the file extension <code>.bs.js</code>, so that you can require these files on the JS side through <code>require('./MyFile.bs')</code>, without needing a loader.</li>
</ul>
<h2>Use Loaders on ReScript Side</h2>
<p>"What if my build system uses a CSS/png/whatever loader and I'd like to use it in ReScript?"</p>
<p>Loaders are indeed troublesome; in the meantime, please use e.g. <code>%raw("require('./myStyles.css')")</code> at the top of your file. This just uses <a href="embed-raw-javascript.md"><code>raw</code></a> to compile the snippet into an actual JS require.</p>
<h2>Getting Project's Dependencies</h2>
<p><code>rescript</code> generates one <code>MyFile.d</code> file per <code>MyFile</code> source file; you'll find them in <code>lib/bs</code>. These are human readable, machine-friendly list of the dependencies of said <code>MyFile</code>. You can read into them for your purpose (though mind the IO overhead). Use these files instead of creating your own dependency graph; we did the hard work of tracking the dependencies as best as possible (including inner modules, <code>open</code>s, module names overlap, etc).</p>
<h2>Run Script Per File Built</h2>
<p>See <a href="build-configuration#js-post-build">js-post-build</a>. Though please use it sparingly; if you hook up a node.js script after each file built, you'll incur the node startup time per file!</p><h1>use-illegal-identifier-names</h1><hr />
<p>title: "Use Illegal Identifier Names"
description: "Handling (JS) naming collisions in ReScript"
canonical: "/docs/manual/latest/use-illegal-identifier-names"</p>
<hr />
<h1>Use Illegal Identifier Names</h1>
<p>Sometime, for e.g. a let binding or a record field, you might want to use:
- A capitalized name.
- A name that contains illegal characters (e.g. emojis, hyphen, space).
- A name that's one of ReScript's reserved keywords.</p>
<p>We provide an escape hatch syntax for these cases:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let \"my-🍎" = 10</p>
<p>type element = {
  \"aria-label": string
}</p>
<p>let myElement = {
  \"aria-label": "close"
}</p>
<p>let label = myElement.\"aria-label"</p>
<p>let calculate = (~\"Props") =&gt; {
  \"Props" + 1
}</p>
<pre class="codehilite"><code>```js
var my$$unknown$unknown$unknown$unknown = 10;

var myElement = {
  &quot;aria-label&quot;: &quot;close&quot;
};

var label = myElement[&quot;aria-label&quot;];

function calculate(Props) {
  return Props + 1 | 0;
}
</code></pre>

<p></CodeTab></p>
<p>See the output. <strong>Use them only when necessary</strong>, for interop with JavaScript. This is a last-resort feature. If you abuse this, many of the compiler guarantees will go away.</p><h1>warning-numbers</h1><hr />
<p>title: "Warning Numbers"
description: "Available compiler warning numbers in ReScript"
canonical: "/docs/manual/latest/warning-numbers"</p>
<hr />
<p>import { make as WarningTable } from "src/components/WarningTable.mjs";</p>
<h1>Warning Numbers</h1>
<p>You can configure which warnings the ReScript compiler generates
<a href="/docs/manual/latest/build-configuration#warnings">in the build configuration</a> or
using the <a href="/syntax-lookup#expression-warning-decorator"><code>@warning()</code></a> or the <a href="/syntax-lookup#module-warning-decorator"><code>@@warning()</code></a> decorator.</p>
<p><WarningTable /></p><h1>import-export</h1><hr />
<p>title: "Import &amp; Export"
description: "Importing / exporting in ReScript modules"
canonical: "/docs/manual/latest/import-export"</p>
<hr />
<h1>Import &amp; Export</h1>
<h2>Import a Module/File</h2>
<p>Unlike JavaScript, ReScript doesn't have or need import statements:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Inside School.res
let studentMessage = Student.message
</code></pre>

<pre class="codehilite"><code class="language-js">var Student = require(&quot;./Student.bs&quot;);
var studentMessage = Student.message
</code></pre>

<p></CodeTab></p>
<p>The above code refers to the <code>message</code> binding in the file <code>Student.res</code>. Every ReScript file is also a module, so accessing another file's content is the same as accessing another module's content!</p>
<p>A ReScript project's file names need to be unique.</p>
<h2>Export Stuff</h2>
<p>By default, every file's type declaration, binding and module is exported, aka publicly usable by another file. <strong>This also means those values, once compiled into JS, are immediately usable by your JS code</strong>.</p>
<p>To only export a few selected things, use a <code>.resi</code> <a href="module.md#signatures">interface file</a>.</p>
<h2>Work with JavaScript Import &amp; Export</h2>
<p>To see how to import JS modules and export stuff for JS consumption, see the JavaScript Interop section's <a href="import-from-export-to-js.md">Import from/Export to JS</a>.</p><h1>module</h1><hr />
<p>title: "Module"
description: "ReScript modules, module signatures and interface files"
canonical: "/docs/manual/latest/module"</p>
<hr />
<h1>Module</h1>
<h2>Basics</h2>
<p><strong>Modules are like mini files</strong>! They can contain type definitions, <code>let</code>
bindings, nested modules, etc.</p>
<h3>Creation</h3>
<p>To create a module, use the <code>module</code> keyword. The module name must start with a
<strong>capital letter</strong>. Whatever you could place in a <code>.res</code> file, you may place
inside a module definition's <code>{}</code> block.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
module School = {
  type profession = Teacher | Director</p>
<p>let person1 = Teacher
  let getProfession = (person) =&gt;
    switch person {
    | Teacher =&gt; "A teacher"
    | Director =&gt; "A director"
    }
}</p>
<pre class="codehilite"><code>```js
function getProfession(person) {
  if (person) {
    return &quot;A director&quot;;
  } else {
    return &quot;A teacher&quot;;
  }
}

var School = {
  person1: /* Teacher */0,
  getProfession: getProfession
};
</code></pre>

<p></CodeTab></p>
<p>A module's contents (including types!) can be accessed much like a record's,
using the <code>.</code> notation. This demonstrates modules' utility for namespacing.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let anotherPerson: School.profession = School.Teacher
Js.log(School.getProfession(anotherPerson)) /* &quot;A teacher&quot; */
</code></pre>

<pre class="codehilite"><code class="language-js">var anotherPerson = /* Teacher */0;
console.log(&quot;A teacher&quot;);
</code></pre>

<p></CodeTab></p>
<p>Nested modules work too.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
module MyModule = {
  module NestedModule = {
    let message = "hello"
  }
}</p>
<p>let message = MyModule.NestedModule.message</p>
<pre class="codehilite"><code>```js
var NestedModule = {
  message: message
};

var MyModule = {
  NestedModule: NestedModule
};

var message = MyModule.NestedModule.message;
</code></pre>

<p></CodeTab></p>
<h3><code>open</code>ing a module</h3>
<p>Constantly referring to a value/type in a module can be tedious. Instead, we can "open" a module and refer to its contents without always prepending them with the
module's name. Instead of writing:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let p = School.getProfession(School.person1)
</code></pre>

<pre class="codehilite"><code class="language-js">var p = School.getProfession(School.person1);
</code></pre>

<p></CodeTab></p>
<p>We can write:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">open School
let p = getProfession(person1)
</code></pre>

<pre class="codehilite"><code class="language-js">var p = School.getProfession(School.person1);
</code></pre>

<p></CodeTab></p>
<p>The content of <code>School</code> module are made visible (<strong>not</strong> copied into the file, but simply made visible!) in scope. <code>profession</code>, <code>getProfession</code> and <code>person1</code> will thus correctly be found.</p>
<p><strong>Use <code>open</code> this sparingly, it's convenient, but makes it hard to know where some values come from</strong>. You should usually use <code>open</code> in a local scope:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let p = {
  open School
  getProfession(person1)
}
/* School's content isn't visible here anymore */
</code></pre>

<pre class="codehilite"><code class="language-js">var p = School.getProfession(School.person1);
</code></pre>

<p></CodeTab></p>
<h3>Use <code>open!</code> to ignore shadow warnings</h3>
<p>There are situations where <code>open</code> will cause a warning due to existing identifiers (bindings, types) being redefined. Use <code>open!</code> to explicitly tell the compiler that this is desired behavior.</p>
<pre class="codehilite"><code class="language-res">let map = (arr, value) =&gt; {
  value
}

// opening Js.Array2 would shadow our previously defined `map`
// `open!` will explicitly turn off the automatic warning
open! Js.Array2
let arr = map([1,2,3], (a) =&gt; { a + 1})
</code></pre>

<p><strong>Note:</strong> Same as with <code>open</code>, don't overuse <code>open!</code> statements if not necessary. Use (sub)modules to prevent shadowing issues.</p>
<h3>Destructuring modules</h3>
<p><strong>Since 9.0.2</strong></p>
<p>As an alternative to <code>open</code>ing a module, you can also destructure a module's functions and values into separate let bindings (similarly on how we'd destructure an object in JavaScript).</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">module User = {
  let user1 = &quot;Anna&quot;
  let user2 = &quot;Franz&quot;
}

// Destructure by name
let {user1, user2} = module(User)

// Destructure with different alias
let {user1: anna, user2: franz} = module(User)
</code></pre>

<pre class="codehilite"><code class="language-js">var user1 = &quot;Anna&quot;;

var user2 = &quot;Franz&quot;;

var User = {
  user1: user1,
  user2: user2
};
</code></pre>

<p></CodeTab></p>
<p><strong>Note:</strong> You can't extract types with module destructuring — use a type alias instead (<code>type user = User.myUserType</code>).</p>
<h3>Extending modules</h3>
<p>Using <code>include</code> in a module statically "spreads" a module's content into a new one, thus often fulfill the role of "inheritance" or "mixin".</p>
<p><strong>Note</strong>: this is equivalent to a compiler-level copy paste. <strong>We heavily discourage <code>include</code></strong>. Use it as last resort!</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
module BaseComponent = {
  let defaultGreeting = "Hello"
  let getAudience = (~excited) =&gt; excited ? "world!" : "world"
}</p>
<p>module ActualComponent = {
  /<em> the content is copied over </em>/
  include BaseComponent
  /<em> overrides BaseComponent.defaultGreeting </em>/
  let defaultGreeting = "Hey"
  let render = () =&gt; defaultGreeting ++ " " ++ getAudience(~excited=true)
}</p>
<pre class="codehilite"><code>```js
function getAudience(excited) {
  if (excited) {
    return &quot;world!&quot;;
  } else {
    return &quot;world&quot;;
  }
}

var BaseComponent = {
  defaultGreeting: &quot;Hello&quot;,
  getAudience: getAudience
};

var defaultGreeting = &quot;Hey&quot;;

function render(param) {
  return &quot;Hey world!&quot;;
}

var ActualComponent = {
  getAudience: getAudience,
  defaultGreeting: defaultGreeting,
  render: render
};
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: <code>open</code> and <code>include</code> are very different! The former brings a module's content into your current scope, so that you don't have to refer to a value by prefixing it with the module's name every time. The latter <strong>copies over</strong> the definition of a module statically, then also do an <code>open</code>.</p>
<h3>Every <code>.res</code> file is a module</h3>
<p>Every ReScript file is itself compiled to a module of the same name as the file name, capitalized. The file <code>React.res</code> implicitly forms a module <code>React</code>, which can be seen by other source files.</p>
<p><strong>Note</strong>: ReScript file names should, by convention, be capitalized so that their casing matches their module name. Uncapitalized file names are not invalid, but will be implicitly transformed into a capitalized module name. I.e. <code>file.res</code> will be compiled into the module <code>File</code>. To simplify and minimize the disconnect here, the convention is therefore to capitalize file names.</p>
<h2>Signatures</h2>
<p>A module's type is called a "signature", and can be written explicitly. If a
module is like a <code>.res</code> (implementation) file, then a module's signature is like
a <code>.resi</code> (interface) file.</p>
<h3>Creation</h3>
<p>To create a signature, use the <code>module type</code> keyword. The signature name must start with a
<strong>capital letter</strong>. Whatever you could place in a <code>.resi</code> file, you may place
inside a signature definition's <code>{}</code> block.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
/<em> Picking up previous section's example </em>/
module type EstablishmentType = {
  type profession
  let getProfession: profession =&gt; string
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>A signature defines the list of requirements that a module must satisfy in order
for that module to match the signature. Those requirements are of the form:</p>
<ul>
<li><code>let x: int</code> requires a <code>let</code> binding named <code>x</code>, of type <code>int</code>.</li>
<li><code>type t = someType</code> requires a type field <code>t</code> to be equal to <code>someType</code>.</li>
<li><code>type t</code> requires a type field <code>t</code>, but without imposing any requirements on the actual, concrete type of <code>t</code>. We'd use <code>t</code> in other entries in the signature to describe relationships, e.g. <code>let makePair: t =&gt; (t, t)</code> but we cannot, for example, assume that <code>t</code> is an <code>int</code>. This gives us great, enforced abstraction abilities.</li>
</ul>
<p>To illustrate the various kinds of type entries, consider the above signature
<code>EstablishmentType</code> which requires that a module:</p>
<ul>
<li>Declare a type named <code>profession</code>.</li>
<li>Must include a function that takes in a value of the type <code>profession</code> and returns a string.</li>
</ul>
<p><strong>Note</strong>:</p>
<p>Modules of the type <code>EstablishmentType</code> can contain more fields than the
signature declares, just like the module <code>School</code> in the previous section (if we
choose to assign it the type <code>EstablishmentType</code>. Otherwise, <code>School</code> exposes
every field). This effectively makes the <code>person1</code> field an enforced
implementation detail! Outsiders can't access it, since it's not present in the
signature; the signature <strong>constrained</strong> what others can access.</p>
<p>The type <code>EstablishmentType.profession</code> is <strong>abstract</strong>: it doesn't have a
concrete type; it's saying "I don't care what the actual type is, but it's used
as input to <code>getProfession</code>". This is useful to fit many modules under the same
interface:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">module Company: EstablishmentType = {
  type profession = CEO | Designer | Engineer | ...

  let getProfession = (person) =&gt; ...
  let person1 = ...
  let person2 = ...
}
</code></pre>

<pre class="codehilite"><code class="language-js">function getProfession(person) {
  ...
}

var person1 = ...

var person2 = ...

var Company = {
  getProfession: getProfession,
  person1: person1,
  person2: person2
};
</code></pre>

<p></CodeTab></p>
<p>It's also useful to hide the underlying type as an implementation detail others
can't rely on. If you ask what the type of <code>Company.profession</code> is, instead of
exposing the variant, it'll only tell you "it's <code>Company.profession</code>".</p>
<h3>Extending module signatures</h3>
<p>Like modules themselves, module signatures can also be extended by other module signatures using <code>include</code>. Again, <strong>heavily discouraged</strong>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
module type BaseComponent = {
  let defaultGreeting: string
  let getAudience: (~excited: bool) =&gt; string
}</p>
<p>module type ActualComponent = {
  /<em> the BaseComponent signature is copied over </em>/
  include BaseComponent
  let render: unit =&gt; string
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: <code>BaseComponent</code> is a module <strong>type</strong>, not an actual module itself!</p>
<p>If you do not have a defined module type, you can extract it from an actual module
using <code>include (module type of ActualModuleName)</code>. For example, we can extend the
<code>List</code> module from the standard library, which does not define a module
type.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
module type MyList = {
  include (module type of List)
  let myListFun: list&lt;'a&gt; =&gt; list&lt;'a&gt;
}</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<h3>Every <code>.resi</code> file is a signature</h3>
<p>Similar to how a <code>React.res</code> file implicitly defines a module <code>React</code>, a file
<code>React.resi</code> implicitly defines a signature for <code>React</code>. If <code>React.resi</code> isn't
provided, the signature of <code>React.res</code> defaults to exposing all the fields of the
module. Because they don't contain implementation files, <code>.resi</code> files are used
in the ecosystem to also document the public API of their corresponding modules.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
/<em> file React.res (implementation. Compiles to module React) </em>/
type state = int
let render = (str) =&gt; str</p>
<pre class="codehilite"><code>```js
function render(str) {
  return str;
}
</code></pre>

<p></CodeTab></p>
<p>```res sig
/<em> file React.resi (interface. Compiles to the signature of React.res) </em>/
type state = int
let render: string =&gt; string</p>
<pre class="codehilite"><code>## Module Functions (functors)

Modules can be passed to functions! It would be the equivalent of passing a file
as a first-class item. However, modules are at a different &quot;layer&quot; of the
language than other common concepts, so we can't pass them to *regular*
functions. Instead, we pass them to special functions called &quot;functors&quot;.

The syntax for defining and using functors is very much like the syntax
for defining and using regular functions. The primary differences are:

- Functors use the `module` keyword instead of `let`.
- Functors take modules as arguments and return a module.
- Functors *require* annotating arguments.
- Functors must start with a capital letter (just like modules/signatures).

Here's an example `MakeSet` functor, that takes in a module of the type
`Comparable` and returns a new set that can contain such comparable items.

&lt;CodeTab labels={[&quot;ReScript&quot;, &quot;JS Output&quot;]}&gt;

```res prelude
module type Comparable = {
  type t
  let equal: (t, t) =&gt; bool
}

module MakeSet = (Item: Comparable) =&gt; {
  // let's use a list as our naive backing data structure
  type backingType = list&lt;Item.t&gt;
  let empty = list{}
  let add = (currentSet: backingType, newItem: Item.t): backingType =&gt;
    // if item exists
    if currentSet-&gt;List.some(x =&gt; Item.equal(x, newItem)) {
      currentSet // return the same (immutable) set (a list really)
    } else {
      list{
        newItem,
        ...currentSet // prepend to the set and return it
      }
    }
}
</code></pre>

<pre class="codehilite"><code class="language-js">var List = require(&quot;./stdlib/list.js&quot;);

function MakeSet(Item) {
  var add = function(currentSet, newItem) {
    if (
      List.exists(function(x) {
        return Item.equal(x, newItem);
      }, currentSet)
    ) {
      return currentSet;
    } else {
      return {
        hd: newItem,
        tl: currentSet,
      };
    }
  };
  return {
    empty: /* [] */ 0,
    add: add,
  };
}
</code></pre>

<p></CodeTab></p>
<p>Functors can be applied using function application syntax. In this case, we're
creating a set, whose items are pairs of integers.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
module IntPair = {
  type t = (int, int)
  let equal = ((x1: int, y1: int), (x2, y2)) =&gt; x1 == x2 &amp;&amp; y1 == y2
  let create = (x, y) =&gt; (x, y)
}</p>
<p>/<em> IntPair abides by the Comparable signature required by MakeSet </em>/
module SetOfIntPairs = MakeSet(IntPair)</p>
<pre class="codehilite"><code>```js
function equal(param, param$1) {
  if (param[0] === param$1[0]) {
    return param[1] === param$1[1];
  } else {
    return false;
  }
}

function create(x, y) {
  return [x, y];
}

var IntPair = {
  equal: equal,
  create: create,
};

var SetOfIntPairs = {
  empty: /* [] */ 0,
  add: add,
};
</code></pre>

<p></CodeTab></p>
<h3>Module functions types</h3>
<p>Like with module types, functor types also act to constrain and hide what we may
assume about functors. The syntax for functor types are consistent with those
for function types, but with types capitalized to represent the signatures of
modules the functor accepts as arguments and return values. In the
previous example, we're exposing the backing type of a set; by giving <code>MakeSet</code>
a functor signature, we can hide the underlying data structure!</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">module type Comparable = ...

module type MakeSetType = (Item: Comparable) =&gt; {
  type backingType
  let empty: backingType
  let add: (backingType, Item.t) =&gt; backingType
}

module MakeSet: MakeSetType = (Item: Comparable) =&gt; {
  ...
}
</code></pre>

<pre class="codehilite"><code class="language-js">// Empty output
</code></pre>

<p></CodeTab></p>
<h2>Exotic Module Filenames</h2>
<p><strong>Since 8.3</strong></p>
<p>It is possible to use non-conventional characters in your filenames (which is sometimes needed for specific JS frameworks). Here are some examples:</p>
<ul>
<li><code>src/Button.ios.res</code></li>
<li><code>pages/[id].res</code></li>
</ul>
<p>Please note that modules with an exotic filename will not be accessible from other ReScript modules.</p>
<h2>Tips &amp; Tricks</h2>
<p>Modules and functors are at a different "layer" of language than the rest (functions, let bindings, data structures, etc.). For example, you can't easily pass them into a tuple or record. Use them judiciously, if ever! Lots of times, just a record or a function is enough.</p><h1>null-undefined-option</h1><hr />
<p>title: "Null, Undefined and Option"
description: "JS interop with nullable and optional values in ReScript"
canonical: "/docs/manual/latest/null-undefined-option"</p>
<hr />
<h1>Null, Undefined and Option</h1>
<p>ReScript itself doesn't have the notion of <code>null</code> or <code>undefined</code>. This is a <em>great</em> thing, as it wipes out an entire category of bugs. No more <code>undefined is not a function</code>, and <code>cannot access someAttribute of undefined</code>!</p>
<p>However, the <strong>concept</strong> of a potentially nonexistent value is still useful, and safely exists in our language.</p>
<p>We represent the existence and nonexistence of a value by wrapping it with the <code>option</code> type. Here's its definition from the standard library:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type option&lt;'a&gt; = None | Some('a)</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>It means "a value of type option is either None (representing nothing) or that actual value wrapped in a Some".</p>
<p><strong>Note</strong> how the <code>option</code> type is just a regular <a href="variant.md">variant</a>.</p>
<h2>Example</h2>
<p>Here's a normal value:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let licenseNumber = 5</p>
<pre class="codehilite"><code>```js
var licenseNumber = 5;
</code></pre>

<p></CodeTab></p>
<p>To represent the concept of "maybe null", you'd turn this into an <code>option</code> type by wrapping it. For the sake of a more illustrative example, we'll put a condition around it:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let licenseNumber =
  if personHasACar {
    Some(5)
  } else {
    None
  }
</code></pre>

<pre class="codehilite"><code class="language-js">var licenseNumber = personHasACar ? 5 : undefined;
</code></pre>

<p></CodeTab></p>
<p>Later on, when another piece of code receives such value, it'd be forced to handle both cases through <a href="pattern-matching-destructuring.md">pattern matching</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">switch licenseNumber {
| None =&gt;
  Js.log(&quot;The person doesn't have a car&quot;)
| Some(number) =&gt;
  Js.log(&quot;The person's license number is &quot; ++ Js.Int.toString(number))
}
</code></pre>

<pre class="codehilite"><code class="language-js">var number = licenseNumber;

if (number !== undefined) {
  console.log(&quot;The person's license number is &quot; + number.toString());
} else {
  console.log(&quot;The person doesn't have a car&quot;);
}
</code></pre>

<p></CodeTab></p>
<p>By turning your ordinary number into an <code>option</code> type, and by forcing you to handle the <code>None</code> case, the language effectively removed the possibility for you to mishandle, or forget to handle, a conceptual <code>null</code> value! <strong>A pure ReScript program doesn't have null errors</strong>.</p>
<h2>Interoperate with JavaScript <code>undefined</code> and <code>null</code></h2>
<p>The <code>option</code> type is common enough that we special-case it when compiling to JavaScript:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let x = Some(5)</p>
<pre class="codehilite"><code>```js
var x = 5;
</code></pre>

<p></CodeTab></p>
<p>simply compiles down to <code>5</code>, and</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let x = None</p>
<pre class="codehilite"><code>```js
var x;
</code></pre>

<p></CodeTab></p>
<p>compiles to <code>undefined</code>! If you've got e.g. a string in JavaScript that you know might be <code>undefined</code>, type it as <code>option&lt;string&gt;</code> and you're done! Likewise, you can send a <code>Some(5)</code> or <code>None</code> to the JS side and expect it to be interpreted correctly =)</p>
<h3>Caveat 1</h3>
<p>The option-to-undefined translation isn't perfect, because on our side, <code>option</code> values can be composed:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let x = Some(Some(Some(5)))</p>
<pre class="codehilite"><code>```js
var x = 5;
</code></pre>

<p></CodeTab></p>
<p>This still compiles to <code>5</code>, but this gets troublesome:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let x = Some(None)</p>
<pre class="codehilite"><code>```js
var Caml_option = require(&quot;./stdlib/caml_option.js&quot;);

var x = Caml_option.some(undefined);
</code></pre>

<p>(See output tab).</p>
<p></CodeTab></p>
<p>What's this <code>Caml_option.some</code> thing? Why can't this compile to <code>undefined</code>? Long story short, when dealing with a polymorphic <code>option</code> type (aka <code>option&lt;'a&gt;</code>, for any <code>'a</code>), many operations become tricky if we don't mark the value with some special annotation. If this doesn't make sense, don't worry; just remember the following rule:</p>
<ul>
<li><strong>Never, EVER, pass a nested <code>option</code> value (e.g. <code>Some(Some(Some(5)))</code>) into the JS side.</strong></li>
<li><strong>Never, EVER, annotate a value coming from JS as <code>option&lt;'a&gt;</code>. Always give the concrete, non-polymorphic type.</strong></li>
</ul>
<h3>Caveat 2</h3>
<p>Unfortunately, lots of times, your JavaScript value might be <em>both</em> <code>null</code> or <code>undefined</code>. In that case, you unfortunately can't type such value as e.g. <code>option&lt;int&gt;</code>, since our <code>option</code> type only checks for <code>undefined</code> and not <code>null</code> when dealing with a <code>None</code>.</p>
<h4>Solution: More Sophisticated <code>undefined</code> &amp; <code>null</code> Interop</h4>
<p>To solve this, we provide access to more elaborate <code>null</code> and <code>undefined</code> helpers through the <a href="api/js/nullable"><code>Js.Nullable</code></a> module. This somewhat works like an <code>option</code> type, but is different from it.</p>
<h4>Examples</h4>
<p>To create a JS <code>null</code>, use the value <code>Js.Nullable.null</code>. To create a JS <code>undefined</code>, use <code>Js.Nullable.undefined</code> (you can naturally use <code>None</code> too, but that's not the point here; the <code>Js.Nullable.*</code> helpers wouldn't work with it).</p>
<p>If you're receiving, for example, a JS string that can be <code>null</code> and <code>undefined</code>, type it as:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("MyConstant") external myId: Js.Nullable.t<string> = "myId"</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>To create such a nullable string from our side (presumably to pass it to the JS side, for interop purpose), do:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
@module("MyIdValidator") external validate: Js.Nullable.t<string> =&gt; bool = "validate"
let personId: Js.Nullable.t<string> = Js.Nullable.return("abc123")</p>
<p>let result = validate(personId)</p>
<pre class="codehilite"><code>```js
var MyIdValidator = require(&quot;MyIdValidator&quot;);
var personId = &quot;abc123&quot;;
var result = MyIdValidator.validate(personId);
</code></pre>

<p></CodeTab></p>
<p>The <code>return</code> part "wraps" a string into a nullable string, to make the type system understand and track the fact that, as you pass this value around, it's not just a string, but a string that can be <code>null</code> or <code>undefined</code>.</p>
<h4>Convert to/from <code>option</code></h4>
<p><code>Js.Nullable.fromOption</code> converts from a <code>option</code> to <code>Js.Nullable.t</code>. <code>Js.Nullable.toOption</code> does the opposite.</p><h1>build-performance</h1><hr />
<p>title: "Performance"
metaTitle: "Build Performance"
description: "ReScript build performance and measuring tools"
canonical: "/docs/manual/latest/build-performance"</p>
<hr />
<h1>Build Performance</h1>
<p>ReScript considers performance at install time, build time and run time as a serious feature; it's one of those things you don't notice until you realize it's missing.</p>
<h2>Profile Your Build</h2>
<p>Sometime your build can be slow due to some confused infra setups. We provide an interactive visualization of your build's performance via <code>bstracing</code>:</p>
<pre class="codehilite"><code class="language-sh">./node_modules/.bin/bstracing
</code></pre>

<p>Run the above command at your ReScript project's root; it'll spit out a JSON file you can drag and drop into <code>chrome://tracing</code>.</p>
<p>import Image from "src/components/Image";</p>
<p><Image withShadow={true} src="/static/img/bstracing.png" caption="Screenshot of bstracing result"/></p>
<h2>Under the Hood</h2>
<p>ReScript itself uses a build system under the hood, called <a href="https://ninja-build.org">Ninja</a>. Ninja is like Make, but cross-platform, minimal, focuses in perf and destined to be more of a low-level building block than a full-blown build system. In this regard, Ninja's a great implementation detail for <code>rescript</code>.</p>
<p>ReScript reads into <code>rescript.json</code> and generates the Ninja build file in <code>lib/bs</code>. The file contains the low-level compiler commands, namespacing rules, intermediate artifacts generation &amp; others. It then runs <code>ninja</code> for the actual build.</p>
<h2>The JS Wrapper</h2>
<p><code>rescript</code> itself is a Node.js wrapper which takes care of some miscellaneous tasks, plus the watcher. The lower-level, watcher-less, fast native <code>rescript</code> is called <code>rescript.exe</code>. It's located at <code>node_modules/rescript/{your-platform}/rescript.exe</code>.</p>
<p>If you don't need the watcher, you can run said <code>rescript.exe</code>. This side-steps Node.js' long startup time, which can be in the order of <code>100ms</code>. Our editor plugin finds and uses this native <code>rescript.exe</code> for better performance.</p>
<h2>Numbers</h2>
<p>Raw <code>rescript.exe</code> build on a small project should be around <code>70ms</code>. This doubles when you use the JS <code>rescript</code> wrapper which comes with a watcher, which is practically faster since you don't manually run the build at every change (though you should opt for the raw <code>rescript.exe</code> for programmatic usage, e.g. inserting rescript into your existing JS build pipeline).</p>
<p>No-op build (when no file's changed) should be around <code>15ms</code>. Incremental rebuild (described soon) of a single file in a project is around <code>70ms</code> too.</p>
<p>Cleaning the artifacts should be instantaneous.</p>
<h3>Extreme Test</h3>
<p>We've stress-tested <code>rescript.exe</code> on a big project of 10,000 files (2 directories, 5000 files each, first 5000 no dependencies, last 5000 10 dependencies on files from the former directory) using https://github.com/rescript-lang/build-benchmark, on a Retina Macbook Pro Early 2015 (3.1 GHz Intel Core i7).</p>
<!-- TODO: better repro -->

<ul>
<li>No-op build of 10k files: <code>800ms</code> (the minimum amount of time required to check the mtimes of 10k files).</li>
<li>Clean build: \&lt;3 minutes.</li>
<li>Incremental build: depends on the number of the dependents of the file. No dependent means <code>1s</code>.</li>
</ul>
<h3>Stability</h3>
<p><code>rescript</code> is a file-based build system. We don't do in-memory build, even if that speeds up the build a lot. In-memory builds risk memory leaks, out-of-memory errors, corrupt halfway build and others. Our watcher mode stays open for days or months with no leak.</p>
<p>The watcher is also just a thin file watcher that calls <code>rescript.exe</code>. We don't like babysitting daemon processes.</p>
<h2>Incrementality &amp; Correctness</h2>
<p>ReScript doesn't take whole seconds to run every time. The bulk of the build performance comes from incremental build, aka re-building a previously built project when a few files changed.</p>
<p>In short, thanks to our compiler and the build system's architecture, we're able to <strong>only build what's needed</strong>. E.g. if <code>MyFile.res</code> isn't changed, then it's not recompiled. You can roughly emulate such incrementalism in languages like JavaScript, but the degree of correctness is unfortunately low. For example, if you rename or move a JS file, then the watcher might get confused and not pick up the "new" file or fail to clean things up correctly, resulting in you needing to clean your build and restart anew, which defeats the purpose.</p>
<p>Say goodbye to stale build from your JavaScript ecosystem!</p>
<h2>Speed Up Incremental Build</h2>
<p>ReScript uses the concept of interface files (<code>.resi</code>) (or, equivalently, <a href="module.md#signatures">module signatures</a>). Exposing only what you need naturally speeds up incremental builds. E.g. if you change a <code>.res</code> file whose corresponding <code>.resi</code> file doesn't expose the changed part, then you've reduced the amount of dependent files you have to rebuild.</p>
<h2>Programmatic Usage</h2>
<p>Unfortunately, JS build systems are usually the bottleneck for building a JS project nowadays. Having parts of the build blazingly fast doesn't matter much if the rest of the build takes seconds or literally minutes. Here are a few suggestions:</p>
<ul>
<li>Convert more files into ReScript =). Fewer files going through fewer parts of the JS pipeline helps a ton.</li>
<li>Careful with bringing in more dependencies: libraries, syntax transforms (e.g. the unofficially supported PPX), build step loaders, etc. The bulk of these dragging down the editing &amp; building experience might out-weight the API benefits they provide.</li>
</ul>
<h2>Hot Reloading</h2>
<p>Hot reloading refers to maintaining a dev server and listening to file changes in a way that allows the server to pipe some delta changes right into the currently running browser page. This provides a relatively fast iteration workflow while working in specific frameworks.</p>
<p>However, hot reloading is fragile by nature, and counts on the occasional inconsistencies (bad state, bad eval, etc.) and the heavy devserver setup/config being less of a hassle than the benefits it provides. We err on the side of caution and stability in general, and decided not to provide a built-in hot reloading <em>yet</em>. <strong>Note</strong>: you can still use the hot reloading facility provided by your JS build pipeline.</p><h1>jsx</h1><hr />
<p>title: "JSX"
description: "JSX syntax in ReScript and React"
canonical: "/docs/manual/latest/jsx"</p>
<hr />
<h1>JSX</h1>
<p>Would you like some HTML syntax in your ReScript? If not, quickly skip over this section and pretend you didn't see anything!</p>
<p>ReScript supports the JSX syntax, with some slight differences compared to the one in <a href="https://facebook.github.io/react/docs/introducing-jsx.html">ReactJS</a>. ReScript JSX isn't tied to ReactJS; they translate to normal function calls:</p>
<p><strong>Note</strong> for <a href="https://rescript-lang.org/docs/react/latest/introduction">ReScriptReact</a> readers: this isn't what ReScriptReact turns JSX into, in the end. See Usage section for more info.</p>
<h2>Capitalized</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;MyComponent name={&quot;ReScript&quot;} /&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(MyComponent, {
  name: &quot;ReScript&quot;,
});
</code></pre>

<p></CodeTab></p>
<p>becomes</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">MyComponent.createElement(~name=&quot;ReScript&quot;, ~children=list{}, ())
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(MyComponent, {
  name: &quot;ReScript&quot;,
});
</code></pre>

<p></CodeTab></p>
<h2>Uncapitalized</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;div onClick={handler}&gt; child1 child2 &lt;/div&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(&quot;div&quot;, {
  onClick: handler
}, child1, child2);
</code></pre>

<p></CodeTab></p>
<p>becomes</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">div(~onClick=handler, ~children=list{child1, child2}, ())
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(&quot;div&quot;, {
  onClick: handler
}, child1, child2);
</code></pre>

<p></CodeTab></p>
<h2>Fragment</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;&gt; child1 child2 &lt;/&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(React.Fragment, undefined, child1, child2);
</code></pre>

<p></CodeTab></p>
<p>becomes</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">list{child1, child2}
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(React.Fragment, undefined, child1, child2);
</code></pre>

<p></CodeTab></p>
<h3>Children</h3>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;MyComponent&gt; child1 child2 &lt;/MyComponent&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(MyComponent, { children: null }, child1, child2);
</code></pre>

<p></CodeTab></p>
<p>This is the syntax for passing a list of two items, <code>child1</code> and <code>child2</code>, to the children position. It transforms to a list containing <code>child1</code> and <code>child2</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">MyComponent.createElement(~children=list{child1, child2}, ())
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(MyComponent.make, MyComponent.makeProps(null, undefined), child1, child2);
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong> again that this isn't the transform for ReScriptReact; ReScriptReact turns the final list into an array. But the idea still applies.</p>
<p>So naturally, <code>&lt;MyComponent&gt; myChild &lt;/MyComponent&gt;</code> is transformed to <code>MyComponent.createElement(~children=list{myChild}, ())</code>. I.e. whatever you do, the arguments passed to the children position will be wrapped in a list.</p>
<h2>Usage</h2>
<p>See <a href="https://rescript-lang.org/docs/react/latest/elements-and-jsx">ReScriptReact Elements &amp; JSX</a> for an example application of JSX, which transforms the above calls into a ReScriptReact-specific call.</p>
<p>Here's a JSX tag that shows most of the features.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;MyComponent
  booleanAttribute={true}
  stringAttribute=&quot;string&quot;
  intAttribute=1
  forcedOptional=?{Some(&quot;hello&quot;)}
  onClick={handleClick}&gt;
  &lt;div&gt; {React.string(&quot;hello&quot;)} &lt;/div&gt;
&lt;/MyComponent&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(MyComponent, {
  children: React.createElement(&quot;div&quot;, undefined, &quot;hello&quot;),
  booleanAttribute: true,
  stringAttribute: &quot;string&quot;,
  intAttribute: 1,
  forcedOptional: &quot;hello&quot;,
  onClick: handleClick
});
</code></pre>

<p></CodeTab></p>
<h2>Departures From JS JSX</h2>
<ul>
<li>Attributes and children don't mandate <code>{}</code>, but we show them anyway for ease of learning. Once you format your file, some of them go away and some turn into parentheses.</li>
<li>Props spread is supported, but there are some restrictions (see below).</li>
<li>Punning!</li>
</ul>
<h3>Spread Props</h3>
<p><strong>Since 10.1</strong></p>
<p>JSX props spread is supported now, but in a stricter way than in JS.</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;Comp {...props} a=&quot;a&quot; /&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(Comp, {
  a: &quot;a&quot;,
  b: &quot;b&quot;
});
</code></pre>

<p></CodeTab></p>
<p>Multiple spreads are not allowed:</p>
<p><CodeTab labels={["ReScript"]}></p>
<pre class="codehilite"><code class="language-res">&lt;NotAllowed {...props1} {...props2} /&gt;
</code></pre>

<p></CodeTab></p>
<p>The spread must be at the first position, followed by other props:</p>
<p><CodeTab labels={["ReScript"]}></p>
<pre class="codehilite"><code class="language-res">&lt;NotAllowed a=&quot;a&quot; {...props} /&gt;
</code></pre>

<p></CodeTab></p>
<h3>Punning</h3>
<p>"Punning" refers to the syntax shorthand for when a label and a value are the same. For example, in JavaScript, instead of doing <code>return {name: name}</code>, you can do <code>return {name}</code>.</p>
<p>JSX supports punning. <code>&lt;input checked /&gt;</code> is just a shorthand for <code>&lt;input checked=checked /&gt;</code>. The formatter will help you format to the punned syntax whenever possible. This is convenient in the cases where there are lots of props to pass down:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">&lt;MyComponent isLoading text onClick /&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">React.createElement(MyComponent, {
  isLoading: true,
  text: text,
  onClick: onClick
});
</code></pre>

<p></CodeTab></p>
<p>Consequently, a JSX component can cram in a few more props before reaching for extra libraries solutions that avoids props passing.</p>
<p><strong>Note</strong> that this is a departure from ReactJS JSX, which does <strong>not</strong> have punning. ReactJS' <code>&lt;input checked /&gt;</code> desugars to <code>&lt;input checked=true /&gt;</code>, in order to conform to DOM's idioms and for backward compatibility.</p>
<h2>Tip &amp; Tricks</h2>
<p>For library authors wanting to take advantage of the JSX: the <code>@JSX</code> attribute is a hook for potential ppx macros to spot a function wanting to format as JSX. Once you spot the function, you can turn it into any other expression.</p>
<p>This way, everyone gets to benefit the JSX syntax without needing to opt into a specific library using it, e.g. ReScriptReact.</p>
<p>JSX calls supports the features of <a href="function.md#labeled-arguments">labeled arguments</a>: optional, explicitly passed optional and optional with default.</p><h1>lazy-values</h1><hr />
<p>title: "Lazy Value"
description: "Data type for deferred computation in ReScript"
canonical: "/docs/manual/latest/lazy-values"</p>
<hr />
<h1>Lazy Value</h1>
<p>If you have some expensive computations you'd like to <strong>defer and cache</strong> subsequently, you can wrap it with <code>lazy</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
@module("node:fs")
external readdirSync: string =&gt; array<string> = "readdirSync"</p>
<p>// Read the directory, only once
let expensiveFilesRead = lazy({
  Js.log("Reading dir")
  readdirSync("./pages")
})</p>
<pre class="codehilite"><code>```js
var Fs = require(&quot;fs&quot;);

var expensiveFilesRead = {
  LAZY_DONE: false,
  VAL: (function () {
    console.log(&quot;Reading dir&quot;);
    return Fs.readdirSync(&quot;./pages&quot;);
  })
};
</code></pre>

<p></CodeTab></p>
<p>Check the JS Output tab: that <code>expensiveFilesRead</code>'s code isn't executed yet, even though you declared it! You can carry it around without fearing that it'll run the directory read.</p>
<p><strong>Note</strong>: a lazy value is <strong>not</strong> a <a href="shared-data-types.md">shared data type</a>. Don't rely on its runtime representation in your JavaScript code.</p>
<h2>Execute The Lazy Computation</h2>
<p>To actually run the lazy value's computation, use <code>Lazy.force</code> from the globally available <code>Lazy</code> module:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// First call. The computation happens
Js.log(Lazy.force(expensiveFilesRead)) // logs "Reading dir" and the directory content</p>
<p>// Second call. Will just return the already calculated result
Js.log(Lazy.force(expensiveFilesRead)) // logs the directory content</p>
<pre class="codehilite"><code>```js
console.log(CamlinternalLazy.force(expensiveFilesRead));

console.log(CamlinternalLazy.force(expensiveFilesRead));
</code></pre>

<p></CodeTab></p>
<p>The first time <code>Lazy.force</code> is called, the expensive computation happens and the result is <strong>cached</strong>. The second time, the cached value is directly used.</p>
<p><strong>You can't re-trigger the computation after the first <code>force</code> call</strong>. Make sure you only use a lazy value with computations whose results don't change (e.g. an expensive server request whose response is always the same).</p>
<p>Instead of using <code>Lazy.force</code>, you can also use <a href="pattern-matching-destructuring.md">pattern matching</a> to trigger the computation:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
switch expensiveFilesRead {
| lazy(result) =&gt; Js.log(result)
}</p>
<pre class="codehilite"><code>```js
var result = CamlinternalLazy.force(expensiveFilesRead);
</code></pre>

<p></CodeTab></p>
<p>Since pattern matching also works on a <code>let</code> binding, you can also do:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let lazy(result) = expensiveFilesRead
Js.log(result)</p>
<pre class="codehilite"><code>```js
var result = CamlinternalLazy.force(expensiveFilesRead);
console.log(result);
</code></pre>

<p></CodeTab></p>
<h2>Exception Handling</h2>
<p>For completeness' sake, our files read example might raise an exception because of <code>readdirSync</code>. Here's how you'd handle it:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let result = try {
  Lazy.force(expensiveFilesRead)
} catch {
| Not_found =&gt; [] // empty array of files
}</p>
<pre class="codehilite"><code>```js
var result;

try {
  result = CamlinternalLazy.force(expensiveFilesRead);
} catch (raw_exn) {
  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.RE_EXN_ID === &quot;Not_found&quot;) {
    result = [];
  } else {
    throw exn;
  }
}
</code></pre>

<p></CodeTab></p>
<p>Though you should probably handle the exception inside the lazy computation itself.</p><h1>unboxed</h1><hr />
<p>title: "Unboxed"
description: "Unbox a wrapper"
canonical: "/docs/manual/latest/unboxed"</p>
<hr />
<h1>Unboxed</h1>
<p>Consider a ReScript variant with a single payload, and a record with a single field:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type name = Name(string)
let studentName = Name(&quot;Joe&quot;)

type greeting = {message: string}
let hi = {message: &quot;hello!&quot;}
</code></pre>

<pre class="codehilite"><code class="language-js">var studentName = /* Name */{
  _0: &quot;Joe&quot;
};

var hi = {
  message: &quot;hello!&quot;
};
</code></pre>

<p></CodeTab></p>
<p>If you check the JavaScript output, you'll see the <code>studentName</code> and <code>hi</code> JS object, as expected (see the <a href="variant#javascript-output">variant JS output</a> and <a href="record#javascript-output">record JS output</a> sections for details).</p>
<p>For performance and certain JavaScript interop situations, ReScript offers a way to unwrap (aka unbox) the JS object wrappers from the output for records with a single field and variants with a single constructor and single payload. Annotate their type declaration with the attribute <code>@unboxed</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">@unboxed
type name = Name(string)
let studentName = Name(&quot;Joe&quot;)

@unboxed
type greeting = {message: string}
let hi = {message: &quot;hello!&quot;}
</code></pre>

<pre class="codehilite"><code class="language-js">var studentName = &quot;Joe&quot;;

var hi = &quot;hello!&quot;;
</code></pre>

<p></CodeTab></p>
<p>Check the new output! Clean.</p>
<h2>Usage</h2>
<p>Why would you ever want a variant or a record with a single payload? Why not just... pass the payload? Here's one use-case for variant.</p>
<p>Suppose you have a game with a local/global coordinate system:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type coordinates = {x: float, y: float}</p>
<p>let renderDot = (coordinates) =&gt; {
  Js.log3("Pretend to draw at:", coordinates.x, coordinates.y)
}</p>
<p>let toWorldCoordinates = (localCoordinates) =&gt; {
  {
    x: localCoordinates.x +. 10.,
    y: localCoordinates.x +. 20.,
  }
}</p>
<p>let playerLocalCoordinates = {x: 20.5, y: 30.5}</p>
<p>renderDot(playerLocalCoordinates)</p>
<pre class="codehilite"><code>```js
function renderDot(coordinates) {
  console.log(&quot;Pretend to draw at:&quot;, coordinates.x, coordinates.y);
}

function toWorldCoordinates(localCoordinates) {
  return {
    x: localCoordinates.x + 10,
    y: localCoordinates.x + 20
  };
}

var playerLocalCoordinates = {
  x: 20.5,
  y: 30.5
};

renderDot(playerLocalCoordinates);
</code></pre>

<p></CodeTab></p>
<p>Oops, that's wrong! <code>renderDot</code> should have taken global coordinates, not local ones... Let's prevent passing the wrong kind of coordinates:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type coordinates = {x: float, y: float}
@unboxed type localCoordinates = Local(coordinates)
@unboxed type worldCoordinates = World(coordinates)</p>
<p>let renderDot = (World(coordinates)) =&gt; {
  Js.log3("Pretend to draw at:", coordinates.x, coordinates.y)
}</p>
<p>let toWorldCoordinates = (Local(coordinates)) =&gt; {
  World({
    x: coordinates.x +. 10.,
    y: coordinates.x +. 20.,
  })
}</p>
<p>let playerLocalCoordinates = Local({x: 20.5, y: 30.5})</p>
<p>// This now errors!
// renderDot(playerLocalCoordinates)
// We're forced to do this instead:
renderDot(playerLocalCoordinates-&gt;toWorldCoordinates)</p>
<pre class="codehilite"><code>```js
function renderDot(coordinates) {
  console.log(&quot;Pretend to draw at:&quot;, coordinates.x, coordinates.y);
}

function toWorldCoordinates(coordinates) {
  return {
    x: coordinates.x + 10,
    y: coordinates.x + 20
  };
}

var playerLocalCoordinates = {
  x: 20.5,
  y: 30.5
};

renderDot(toWorldCoordinates(playerLocalCoordinates));
</code></pre>

<p></CodeTab></p>
<p>Now <code>renderDot</code> only takes <code>worldCoordinates</code>. Through a nice combination of using distinct variant types + argument destructuring, we've achieved better safety <strong>without compromising on performance</strong>: the <code>unboxed</code> attribute compiled to clean, variant-wrapper-less JS code! Check the output.</p>
<p>As for a record with a single field, the use-cases are a bit more edgy. We won't mention them here.</p><h1>installation</h1><hr />
<p>title: "Installation"
description: "ReScript installation and setup instructions"
canonical: "/docs/manual/latest/installation"</p>
<hr />
<h1>Installation</h1>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://nodejs.org/">Node.js</a> version &gt;= 14</li>
<li><a href="https://docs.npmjs.com/cli/">npm</a> (which comes with Node.js) or <a href="https://yarnpkg.com/">Yarn</a></li>
</ul>
<h2>New Project</h2>
<pre class="codehilite"><code class="language-sh">git clone https://github.com/rescript-lang/rescript-project-template
cd rescript-project-template
npm install
npm run res:build
node src/Demo.bs.js
</code></pre>

<p>or use the create-rescript-app tool:</p>
<pre class="codehilite"><code class="language-sh">npm create rescript-app // Select basic template
cd &lt;your-rescript-project-name&gt;
npm run res:build
node src/Demo.bs.js
</code></pre>

<p>That compiles your ReScript into JavaScript, then uses Node.js to run said JavaScript. <strong>We recommend you use our unique workflow of keeping a tab open for the generated <code>.bs.js</code> file</strong>, so that you can learn how ReScript transforms into JavaScript. Not many languages output clean JavaScript code you can inspect and learn from!</p>
<p>During development, instead of running <code>npm run res:build</code> each time to compile, use <code>npm run res:dev</code> to start a watcher that recompiles automatically after file changes.</p>
<h2>Integrate Into an Existing JS Project</h2>
<p>If you already have a JavaScript project into which you'd like to add ReScript:</p>
<ul>
<li>Install ReScript locally:
  <code>sh
  npm install rescript</code></li>
<li>Create a ReScript build configuration at the root:
  <code>json
  {
    "name": "your-project-name",
    "sources": [
      {
        "dir": "src", // update this to wherever you're putting ReScript files
        "subdirs": true
      }
    ],
    "package-specs": [
      {
        "module": "es6",
        "in-source": true
      }
    ],
    "suffix": ".bs.js",
    "bs-dependencies": []
  }</code>
  See <a href="build-configuration">Build Configuration</a> for more details on <code>rescript.json</code>.</li>
<li>Add convenience <code>npm</code> scripts to <code>package.json</code>:
  <code>json
  "scripts": {
    "res:build": "rescript",
    "res:dev": "rescript build -w"
  }</code></li>
</ul>
<p>Since ReScript compiles to clean readable JS files, the rest of your existing toolchain (e.g. Babel and Webpack) should just work!</p>
<p>Helpful guides:</p>
<ul>
<li><a href="converting-from-js">Converting from JS</a>.</li>
<li><a href="shared-data-types">Shared Data Types</a>.</li>
<li><a href="import-from-export-to-js">Import from/Export to JS</a>.</li>
</ul>
<h3>Integrate with a ReactJS Project</h3>
<p>To start a <a href="/docs/react/latest/introduction">rescript-react</a> app, or to integrate ReScript into an existing ReactJS app, follow the instructions <a href="/docs/react/latest/installation">here</a>.</p><h1>polymorphic-variant</h1><hr />
<p>title: "Polymorphic Variant"
description: "The Polymorphic Variant data structure in ReScript"
canonical: "/docs/manual/latest/polymorphic-variant"</p>
<hr />
<h1>Polymorphic Variant</h1>
<p>Polymorphic variants (or poly variant) are a cousin of <a href="variant">variant</a>. With these differences:</p>
<ul>
<li>They start with a <code>#</code> and the constructor name doesn't need to be capitalized.</li>
<li>They don't require an explicit type definition. The type is inferred from usage.</li>
<li>Values of different poly variant types can share the constructors they have in common (aka, poly variants are "structurally" typed, as opposed to <a href="variant#variant-types-are-found-by-field-name">"nominally" typed</a>).</li>
</ul>
<p>They're a convenient and useful alternative to regular variants, but should <strong>not</strong> be abused. See the drawbacks at the end of this page.</p>
<h2>Creation</h2>
<p>We provide 3 syntaxes for a poly variant's constructor:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let myColor = #red
let myLabel = #&quot;aria-hidden&quot;
let myNumber = #7
</code></pre>

<pre class="codehilite"><code class="language-js">var myColor = &quot;red&quot;;
var myLabel = &quot;aria-hidden&quot;;
var myNumber = 7;
</code></pre>

<p></CodeTab></p>
<p><strong>Take a look at the output</strong>. Poly variants are <em>great</em> for JavaScript interop. For example, you can use it to model JavaScript string and number enums like TypeScript, but without confusing their accidental usage with regular strings and numbers.</p>
<p><code>myColor</code> uses the common syntax. The second and third syntaxes are to support expressing strings and numbers more conveniently. We allow the second one because otherwise it'd be invalid syntax since symbols like <code>-</code> and others are usually reserved.</p>
<h2>Type Declaration</h2>
<p>Although <strong>optional</strong>, you can still pre-declare a poly variant type:</p>
<pre class="codehilite"><code class="language-res">// Note the surrounding square brackets, and # for constructors
type color = [#red | #green | #blue]
</code></pre>

<p>These types can also be inlined, unlike for regular variant:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let render = (myColor: [#red | #green | #blue]) =&gt; {
  switch myColor {
  | #blue =&gt; Js.log(&quot;Hello blue!&quot;)
  | #red
  | #green =&gt; Js.log(&quot;Hello other colors&quot;)
  }
}
</code></pre>

<pre class="codehilite"><code class="language-js">function render(myColor) {
  if (myColor === &quot;green&quot; || myColor === &quot;red&quot;) {
    console.log(&quot;Hello other colors&quot;);
  } else {
    console.log(&quot;Hello blue!&quot;);
  }
}
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: because a poly variant value's type definition is <strong>inferred</strong> and not searched in the scope, the following snippet won't error:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type color = [#red | #green | #blue]

let render = myColor =&gt; {
  switch myColor {
  | #blue =&gt; Js.log(&quot;Hello blue!&quot;)
  | #green =&gt; Js.log(&quot;Hello green!&quot;)
  // works!
  | #yellow =&gt; Js.log(&quot;Hello yellow!&quot;)
  }
}
</code></pre>

<pre class="codehilite"><code class="language-js">function render(myColor) {
  if (myColor === &quot;yellow&quot;) {
    console.log(&quot;Hello yellow!&quot;);
  } else if (myColor === &quot;green&quot;) {
    console.log(&quot;Hello green!&quot;);
  } else {
    console.log(&quot;Hello blue!&quot;);
  }
}
</code></pre>

<p></CodeTab></p>
<p>That <code>myColor</code> parameter's type is inferred to be <code>#red</code>, <code>#green</code> or <code>#yellow</code>, and is unrelated to the <code>color</code> type. If you intended <code>myColor</code> to be of type <code>color</code>, annotate it as <code>myColor: color</code> in any of the places.</p>
<h2>Constructor Arguments</h2>
<p>This is similar to a regular variant's <a href="variant#constructor-arguments">constructor arguments</a>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type account = [
  | #Anonymous
  | #Instagram(string)
  | #Facebook(string, int)
]

let me: account = #Instagram(&quot;Jenny&quot;)
let him: account = #Facebook(&quot;Josh&quot;, 26)
</code></pre>

<pre class="codehilite"><code class="language-js">var me = {
  NAME: &quot;Instagram&quot;,
  VAL: &quot;Jenny&quot;
};

var him = {
  NAME: &quot;Facebook&quot;,
  VAL: [
    &quot;Josh&quot;,
    26
  ]
};
</code></pre>

<p></CodeTab></p>
<h3>Combine Types and Pattern Match</h3>
<p>You can use poly variant types within other poly variant types to create a sum of all constructors:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type red = [#Ruby | #Redwood | #Rust]
type blue = [#Sapphire | #Neon | #Navy]

// Contains all constructors of red and blue.
// Also adds #Papayawhip
type color = [red | blue | #Papayawhip]

let myColor: color = #Ruby
</code></pre>

<pre class="codehilite"><code class="language-js">var myColor = &quot;Ruby&quot;;
</code></pre>

<p></CodeTab></p>
<p>There's also some special <a href="./pattern-matching-destructuring">pattern matching</a> syntax to match on constructors defined in a specific poly variant type:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Continuing the previous example above...

switch myColor {
| #...blue =&gt; Js.log(&quot;This blue-ish&quot;)
| #...red =&gt; Js.log(&quot;This red-ish&quot;)
| other =&gt; Js.log2(&quot;Other color than red and blue: &quot;, other)
}
</code></pre>

<pre class="codehilite"><code class="language-js">var other = myColor;

if (other === &quot;Neon&quot; || other === &quot;Navy&quot; || other === &quot;Sapphire&quot;) {
  console.log(&quot;This is blue-ish&quot;);
} else if (other === &quot;Rust&quot; || other === &quot;Ruby&quot; || other === &quot;Redwood&quot;) {
  console.log(&quot;This is red-ish&quot;);
} else {
  console.log(&quot;Other color than red and blue: &quot;, other);
}
</code></pre>

<p></CodeTab></p>
<p>This is a shorter version of:</p>
<pre class="codehilite"><code class="language-res">switch myColor {
| #Sapphire | #Neon | #Navy =&gt; Js.log(&quot;This is blue-ish&quot;)
| #Ruby | #Redwood | #Rust =&gt; Js.log(&quot;This is red-ish&quot;)
| other =&gt; Js.log2(&quot;Other color than red and blue: &quot;, other)
}
</code></pre>

<h2>Structural Sharing</h2>
<p>Since poly variants value don't have a source of truth for their type, you can write such code:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type preferredColors = [#white | #blue]

let myColor: preferredColors = #blue

let displayColor = v =&gt; {
  switch v {
  | #red =&gt; &quot;Hello red&quot;
  | #green =&gt; &quot;Hello green&quot;
  | #white =&gt; &quot;Hey white!&quot;
  | #blue =&gt; &quot;Hey blue!&quot;
  }
}

Js.log(displayColor(myColor))
</code></pre>

<pre class="codehilite"><code class="language-js">var myColor = &quot;blue&quot;;

function displayColor(v) {
  if (v === &quot;white&quot;) {
    return &quot;Hey white!&quot;;
  } else if (v === &quot;red&quot;) {
    return &quot;Hello red&quot;;
  } else if (v === &quot;green&quot;) {
    return &quot;Hello green&quot;;
  } else {
    return &quot;Hey blue!&quot;;
  }
}

console.log(displayColor(&quot;blue&quot;));
</code></pre>

<p></CodeTab></p>
<p>With a regular variant, the line <code>displayColor(myColor)</code> would fail, since it'd complain that the type of <code>myColor</code> doesn't match the type of <code>v</code>. No problem with poly variant.</p>
<h2>JavaScript Output</h2>
<p>Poly variants are great for JavaScript interop! You can share their values to JS code, or model incoming JS values as poly variants.</p>
<ul>
<li><code>#red</code> and <code>#"I am red 😃"</code> compile to JavaScipt <code>"red"</code> and <code>"I am red 😃"</code>.</li>
<li><code>#1</code> compiles to JavaScript <code>1</code>.</li>
<li>Poly variant constructor with 1 argument, like <code>Instagram("Jenny")</code> compile to a straightforward <code>{NAME: "Instagram", VAL: "Jenny"}</code>. 2 or more arguments like <code>#Facebook("Josh", 26)</code> compile to a similar object, but with <code>VAL</code> being an array of the arguments.</li>
</ul>
<h3>Bind to Functions</h3>
<p>For example, let's assume we want to bind to <code>Intl.NumberFormat</code> and want to make sure that our users only pass valid locales, we could define an external binding like this:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type t

@scope(&quot;Intl&quot;) @val
external makeNumberFormat: ([#&quot;de-DE&quot; | #&quot;en-GB&quot; | #&quot;en-US&quot;]) =&gt; t = &quot;NumberFormat&quot;

let intl = makeNumberFormat(#&quot;de-DE&quot;)
</code></pre>

<pre class="codehilite"><code class="language-js">var intl = Intl.NumberFormat(&quot;de-DE&quot;);
</code></pre>

<p></CodeTab></p>
<p>The JS output is identical to handwritten JS, but we also get to enjoy type errors if we accidentally write <code>makeNumberFormat(#"de-DR")</code>.</p>
<p>More advanced usage examples for poly variant interop can be found in <a href="bind-to-js-function#constrain-arguments-better">Bind to JS Function</a>.</p>
<h3>Bind to String Enums</h3>
<p>Let's assume we have a TypeScript module that expresses following enum export:</p>
<pre class="codehilite"><code class="language-js">// direction.js
enum Direction {
  Up = &quot;UP&quot;,
  Down = &quot;DOWN&quot;,
  Left = &quot;LEFT&quot;,
  Right = &quot;RIGHT&quot;,
}

export const myDirection = Direction.Up
</code></pre>

<p>For this particular example, we can also inline poly variant type definitions to design the type for the imported <code>myDirection</code> value:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type direction = [ #UP | #DOWN | #LEFT | #RIGHT ]
@module(&quot;./direction.js&quot;) external myDirection: direction = &quot;myDirection&quot;
</code></pre>

<pre class="codehilite"><code class="language-js">var DirectionJs = require(&quot;./direction.js&quot;);

var myDirection = DirectionJs.myDirection;
</code></pre>

<p></CodeTab></p>
<p>Again: since we were using poly variants, the JS Output is practically zero-cost and doesn't add any extra code!</p>
<h2>Extra Constraints on Types</h2>
<p>The previous poly variant type annotations we've looked at are the regular "closed" kind. However, there's a way to express "I want at least these constructors" (lower bound) and "I want at most these constructors" (upper bound):</p>
<pre class="codehilite"><code class="language-res">// Only #Red allowed. Closed.
let basic: [#Red] = #Red

// May contain #Red, or any other value. Open
// here, foreground will actually be inferred as [&gt; #Red | #Green]
let foreground: [&gt; #Red] = #Green

// The value must be, at most, one of #Red or #Blue
// Only #Red and #Blue are valid values
let background: [&lt; #Red | #Blue] = #Red
</code></pre>

<p><strong>Note:</strong> We added this info for educational purposes. In most cases you will not want to use any of this stuff, since it makes your APIs pretty unreadable / hard to use.</p>
<h3>Closed <code>[</code></h3>
<p>This is the simplest poly variant definition, and also the most practical one. Like a common variant type, this one defines an exact set of constructors.</p>
<pre class="codehilite"><code class="language-res">type rgb = [ #Red | #Green | #Blue ]

let color: rgb = #Green
</code></pre>

<p>In the example above, <code>color</code> will only allow one of the three constructors that are defined in the <code>rgb</code> type. This is usually the way how poly variants should be defined.</p>
<p>In case you want to define a type that is extensible, you'll need to use the lower / upper bound syntax.</p>
<h3>Lower Bound <code>[&gt;</code></h3>
<p>A lower bound defines the minimum set of constructors a poly variant type is aware of. It is also considered an "open poly variant type", because it doesn't restrict any additional values.</p>
<p>Here is an example on how to make a minimum set of <code>basicBlueTones</code> extensible for a new <code>color</code> type:</p>
<pre class="codehilite"><code class="language-res">type basicBlueTone&lt;'a&gt; = [&gt; #Blue | #DeepBlue | #LightBlue ] as 'a
type color = basicBlueTone&lt;[#Blue | #DeepBlue | #LightBlue | #Purple]&gt;

let color: color = #Purple

// This will fail due to missing minimum constructors:
type notWorking = basicBlueTone&lt;[#Purple]&gt;
</code></pre>

<p>Here, the compiler will enforce the user to define <code>#Blue | #DeepBlue | #LightBlue</code> as the minimum set of constructors when trying to extend <code>basicBlueTone&lt;'a&gt;</code>.</p>
<p><strong>Note:</strong> Since we want to define an extensible poly variant, we need to provide a type placeholder <code>&lt;'a&gt;</code>, and also add <code>as 'a</code> after the poly variant declaration, which essentially means: "Given type <code>'a</code> is constraint to the minimum set of constructors (<code>#Blue | #DeepBlue | #LightBlue</code>) defined in <code>basicBlueTone</code>".</p>
<h3>Upper Bound <code>[&lt;</code></h3>
<p>The upper bound works in the opposite way than a lower bound: the extending type may only use constructors that are stated in the upper bound constraint.</p>
<p>Here another example, but with red colors:</p>
<pre class="codehilite"><code class="language-res">type validRed&lt;'a&gt; = [&lt; #Fire | #Crimson | #Ash] as 'a
type myReds = validRed&lt;[#Ash]&gt;

// This will fail due to unlisted constructor not defined by the lower bound
type notWorking = validRed&lt;[#Purple]&gt;
</code></pre>

<h2>Coercion</h2>
<p>You can convert a poly variant to a <code>string</code> or <code>int</code> at no cost:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type company = [#Apple | #Facebook]
let theCompany: company = #Apple

let message = &quot;Hello &quot; ++ (theCompany :&gt; string)
</code></pre>

<pre class="codehilite"><code class="language-js">var theCompany = &quot;Apple&quot;;
var message = &quot;Hello &quot; + theCompany;
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: for the coercion to work, the poly variant type needs to be closed; you'd need to annotate it, since otherwise, <code>theCompany</code> would be inferred as <code>[&gt; #Apple]</code>.</p>
<h2>Tips &amp; Tricks</h2>
<h3>Variant vs Polymorphic Variant</h3>
<p>One might think that polymorphic variants are superior to regular <a href="./variant">variants</a>. As always, there are trade-offs:</p>
<ul>
<li>Due to their "structural" nature, poly variant's type errors might be more confusing. If you accidentally write <code>#blur</code> instead of <code>#blue</code>, ReScript will still error but can't indicate the correct source as easily. Regular variants' source of truth is the type definition, so the error can't go wrong.</li>
<li>
<p>It's also harder to refactor poly variants. Consider this:
  <code>res
  let myFruit = #Apple
  let mySecondFruit = #Apple
  let myCompany = #Apple</code>
  Refactoring the first one to <code>#Orange</code> doesn't mean we should refactor the third one. Therefore, the editor plugin can't touch the second one either. Regular variant doesn't have such problem, as these 2 values presumably come from different variant type definitions.</p>
</li>
<li>
<p>You might lose some nice pattern match checks from the compiler:
  ```res
  let myColor = #red</p>
</li>
</ul>
<p>switch myColor {
  | #red =&gt; Js.log("Hello red!")
  | #blue =&gt; Js.log("Hello blue!")
  }
  <code>``
  Because there's no poly variant definition, it's hard to know whether the</code>#blue` case can be safely removed.</p>
<p>In most scenarios, we'd recommend to use regular variants over polymorphic variants, especially when you are writing plain ReScript code. In case you want to write zero-cost interop bindings or generate clean JS output, poly variants are oftentimes a better option.</p><h1>object</h1><hr />
<p>title: "Object"
description: "Interoping with JS objects in ReScript"
canonical: "/docs/manual/latest/object"</p>
<hr />
<h1>Object</h1>
<p>ReScript objects are like <a href="record.md">records</a>, but:</p>
<ul>
<li>No type declaration needed.</li>
<li>Structural and more polymorphic, <a href="record.md#record-types-are-found-by-field-name">unlike records</a>.</li>
<li>Doesn't support updates unless the object comes from the JS side.</li>
<li>Doesn't support <a href="pattern-matching-destructuring">pattern matching</a>.</li>
</ul>
<!-- TODO: support update man -->

<p>Although ReScript records compile to clean JavaScript objects, ReScript objects are a better candidate for emulating/binding to JS objects, as you'll see.</p>
<h2>Type Declaration</h2>
<p><strong>Optional</strong>, unlike for records. The type of an object is inferred from the value, so you never really need to write down its type definition. Nevertheless, here's its type declaration syntax:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res prelude
type person = {
  "age": int,
  "name": string
};</p>
<pre class="codehilite"><code>```js
// Empty output
</code></pre>

<p></CodeTab></p>
<p>Visually similar to record type's syntax, with the field names quoted.</p>
<!-- TODO: document {.} and {..} -->

<h2>Creation</h2>
<p>To create a new object:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
let me = {
  "age": 5,
  "name": "Big ReScript"
}</p>
<pre class="codehilite"><code>```js
var me = {
  &quot;age&quot;: 5,
  &quot;name&quot;: &quot;Big ReScript&quot;
};
</code></pre>

<p></CodeTab></p>
<p><strong>Note</strong>: as said above, unlike for record, this <code>me</code> value does <strong>not</strong> try to find a conforming type declaration with the field <code>"age"</code> and <code>"name"</code>; rather, the type of <code>me</code> is inferred as <code>{"age": int, "name": string}</code>. This is convenient, but also means this code passes type checking without errors:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">type person = {
  &quot;age&quot;: int
};

let me = {
  &quot;age&quot;: &quot;hello!&quot; // age is a string. No error.
}
</code></pre>

<pre class="codehilite"><code class="language-js">var me = {
  &quot;age&quot;: &quot;hello!&quot;
};
</code></pre>

<p></CodeTab></p>
<p>Since the type checker doesn't try to match <code>me</code> with the type <code>person</code>. If you ever want to force an object value to be of a predeclared object type, just annotate the value:</p>
<pre class="codehilite"><code class="language-res">let me: person = {
  &quot;age&quot;: &quot;hello!&quot;
}
</code></pre>

<p>Now the type system will error properly.</p>
<h2>Access</h2>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">let age = me[&quot;age&quot;]
</code></pre>

<pre class="codehilite"><code class="language-js">var age = me[&quot;age&quot;];
</code></pre>

<p></CodeTab></p>
<h2>Update</h2>
<p>Disallowed unless the object is a binding that comes from the JavaScript side. In that case, use <code>=</code></p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type student = {
  @set "age": int,
  @set "name": string,
}
@module("MyJSFile") external student1: student = "student1"</p>
<p>student1["name"] = "Mary"</p>
<pre class="codehilite"><code>```js
var MyJSFile = require(&quot;MyJSFile&quot;);
MyJSFile.student1.name = &quot;Mary&quot;;
</code></pre>

<p></CodeTab></p>
<h2>Combine Types</h2>
<p>You can spread one object type definition into another using <code>...</code>:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
type point2d = {
  "x": float,
  "y": float,
}
type point3d = {
  ...point2d,
  "z": float,
}</p>
<p>let myPoint: point3d = {
  "x": 1.0,
  "y": 2.0,
  "z": 3.0,
}</p>
<pre class="codehilite"><code>```js
var myPoint = {
  x: 1.0,
  y: 2.0,
  z: 3.0
};
</code></pre>

<p></CodeTab></p>
<p>This only works with object types, not object values!</p>
<h2>Tips &amp; Tricks</h2>
<p>Since objects don't require type declarations, and since ReScript infers all the types for you, you get to very quickly and easily (and dangerously) bind to any JavaScript API. Check the JS output tab:</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<p>```res example
// The type of document is just some random type 'a
// that we won't bother to specify
@val external document: 'a = "document"</p>
<p>// call a method
document<a href="." title="mouseup&quot;, _event =&gt; {   Js.log(&quot;clicked!">"addEventListener"</a>
})</p>
<p>// get a property
let loc = document["location"]</p>
<p>// set a property
document["location"]["href"] = "rescript-lang.org"</p>
<pre class="codehilite"><code>```js
document.addEventListener(&quot;mouseup&quot;, function(_event) {
  console.log(&quot;clicked!&quot;);
});
var loc = document.location;
document.location.href = &quot;rescript-lang.org&quot;;
</code></pre>

<p></CodeTab></p>
<p>The <code>external</code> feature and the usage of this trick are also documented in the <a href="external#tips--tricks">external</a> section later. It's an excellent way to start writing some ReScript code without worrying about whether bindings to a particular library exists.</p><h1>build-overview</h1><hr />
<p>title: "Overview"
metaTitle: "Build System Overview"
description: "Documentation about the ReScript build system and its toolchain"
canonical: "/docs/manual/latest/build-overview"</p>
<hr />
<h1>Build System Overview</h1>
<p>ReScript comes with a build system, <a href="https://www.npmjs.com/package/rescript"><code>rescript</code></a>, that's fast, lean and used as the authoritative build system of the community.</p>
<p>Every ReScript project needs a build description file, <code>rescript.json</code>.</p>
<h2>Options</h2>
<p>See <code>rescript -help</code>:</p>
<pre class="codehilite"><code>❯ rescript -help
Available flags
-v, -version  display version number
-h, -help     display help
Subcommands:
    build
    clean
    format
    convert
    help
Run rescript subcommand -h for more details,
For example:
    rescript build -h
    rescript format -h
The default `rescript` is equivalent to `rescript build` subcommand
</code></pre>

<h2>Build Project</h2>
<p>Each build will create build artifacts from your project's source files.</p>
<p><strong>To build a project (including its dependencies / pinned-dependencies)</strong>, run:</p>
<pre class="codehilite"><code class="language-sh">rescript
</code></pre>

<p>Which is an alias for <code>rescript build</code>.</p>
<p>To keep a build watcher, run:</p>
<pre class="codehilite"><code class="language-sh">rescript build -w
</code></pre>

<p>Any new file change will be picked up and the build will re-run.</p>
<p><strong>Note</strong>: third-party libraries (in <code>node_modules</code>, or via <code>pinned-dependencies</code>) aren't watched, as doing so may exceed the node.js watcher count limit.</p>
<p><strong>Note 2</strong>: In case you want to set up a project in a JS-monorepo-esque approach (<code>npm</code> and <code>yarn</code> workspaces) where changes in your sub packages should be noticed by the build, you will need to define pinned dependencies in your main project's <code>rescript.json</code>. More details <a href="./build-pinned-dependencies">here</a>.</p>
<h2>Clean Project</h2>
<p>If you ever get into a stale build for edge-case reasons, use:</p>
<pre class="codehilite"><code class="language-sh">rescript clean
</code></pre>

<p>This will clean your own project's build artifacts. To also clean the dependencies' artifacts:</p>
<pre class="codehilite"><code class="language-sh">rescript clean -with-deps
</code></pre><h1>shared-data-types</h1><hr />
<p>title: "Shared Data Types"
description: "Data types that share runtime presentation between JS and ReScript"
canonical: "/docs/manual/latest/shared-data-types"</p>
<hr />
<h1>Shared Data Types</h1>
<p>ReScript's built-in values of type <code>string</code>, <code>float</code>, <code>array</code> and a few others have a rather interesting property: they compile to the exact same value in JavaScript!</p>
<p>This means that if you're passing e.g. a ReScript string to the JavaScript side, the JS side can directly use it as a native JS string. It also means that you can import a JS string and pretend it's a native ReScript string.</p>
<p>Unlike most compiled-to-js languages, in ReScript, <strong>you don't need to write data converters back and forth for most of our values</strong>!</p>
<p><strong>Shared, bidirectionally usable types</strong>:
- String. ReScript strings are JavaScript strings, vice-versa. (Caveat: only our backtick string <code>`hello 👋 ${personName}`</code> supports unicode and interpolation).
- Float. ReScript floats are JS numbers, vice-versa.
- Array. In addition to the <a href="api/js/array">JS Array API</a>, we provide our own <a href="api/belt/array#set">Belt.Array</a> API too.
- Tuple. Compiles to a JS array. You can treat a fixed-sized, heterogenous JS array as ReScript tuple too.
- Boolean.
- Record. Record compiles to JS object. Therefore you can also treat JS objects as records. If they're too dynamic, consider modeling them on the ReScript side as a hashmap/dictionary <a href="api/js/dict"><code>Js.Dict</code></a> or a ReScript object.
- Object. ReScript objects are JavaScript objects, vice-versa.
- Function. They compile to clean JS functions.
- Module. ReScript files are considered top-level modules, and are compiled to JS files 1 to 1. Nested modules are compiled to JavaScript objects.
- Polymorphic variants.
- Unit. The <code>unit</code> type, which has a single value <code>()</code>, compiles to <code>undefined</code> too. Likewise, you can treat an incoming JS <code>undefined</code> as <code>()</code> if that's the only value it'll ever be.</p>
<p><strong>Types that are slightly different than JS, but that you can still use from JS</strong>:
- Int. <strong>Ints are 32-bits</strong>! Be careful, you can potentially treat them as JS numbers and vice-versa, but if the number's large, then you better treat JS numbers as floats. For example, we bind to Js.Date using <code>float</code>s.
- Option. The <code>option</code> type's <code>None</code> value compiles into JS <code>undefined</code>. The <code>Some</code> value, e.g. <code>Some(5)</code>, compiles to <code>5</code>. Likewise, you can treat an incoming JS <code>undefined</code> as <code>None</code>. <strong>JS <code>null</code> isn't handled here</strong>. If your JS value can be <code>null</code>, use <a href="api/js/nullable">Js.Nullable</a> helpers.
- Exception.
- Variant. Check the compiled JavaScript output of variant to see its shape. We don't recommend exporting a ReScript variant for pure JS usage, since they're harder to read as plain JS code, but you can do it.
- List, which is just a regular variant.</p>
<p><strong>Non-shared types (aka internal types)</strong>:</p>
<ul>
<li>Character.</li>
<li>Int64.</li>
<li>Lazy values.</li>
<li>Everything else.</li>
</ul>
<p>Many of these are stable, which means that you can still serialize/deserialize them as-is without manual conversions. But we discourage actively peeking into their structure otherwise.</p>
<p>These types require manual conversions if you want to export them for JS consumption. For a seamless JS/TypeScript/Flow integration experience, you might want to use <a href="https://github.com/cristianoc/gentype">genType</a> instead of doing conversions by hand.</p><h1>2022-08-25-release-10-0-0</h1><hr />
<p>author: rescript-team
date: "2022-08-25"
previewImg: static/blog/grid_0.jpeg
title: ReScript 10.0
badge: release
description: |
  The first community powered release.</p>
<hr />
<p>ReScript version 10 is available! Version 10 is a culmination of over a year's worth of work, bringing faster builds, improving JS interop, and including a bunch of bug fixes. It's also the first fully community powered release, with contributions from over 20 community members.</p>
<pre class="codehilite"><code>npm install rescript@10
</code></pre>

<p>All changes are listed <a href="https://github.com/rescript-lang/rescript-compiler/blob/10.0_release/CHANGELOG.md">here</a>. Let's take a tour of a few of the features we're extra excited about.</p>
<h2>Faster builds with native M1 support</h2>
<p>Users with M1 chips should see a notable speedup, as the new ReScript version has full native support for M1.</p>
<h2>Better ergonomics with Unicode support in regular strings</h2>
<p>You can now use Unicode characters directly in regular strings. This will now produce what you'd expect:</p>
<pre class="codehilite"><code class="language-res">let str = &quot;Σ&quot;
</code></pre>

<p>You can also pattern match on Unicode characters:</p>
<pre class="codehilite"><code class="language-res">switch someCharacter { 
  | 'Σ' =&gt; &quot;what a fine Unicode char&quot; 
  | _ =&gt; &quot;Unicode is fun&quot; 
}
</code></pre>

<h2>Experimental optional record fields</h2>
<p>Previously, a record would always have to define all its optional fields:</p>
<pre class="codehilite"><code class="language-res">type user = {
  name: string,
  age: option&lt;int&gt;
}

let userWithoutAge = {
  name: &quot;Name&quot;,
  age: None,
}

let userWithAge = {
  name: &quot;Name&quot;,
  age: Some(34),
}
</code></pre>

<p>For small records like the one above, this is typically fine. But for records with many fields, the friction of having to always set all optional fields explicitly adds up. This release has a new experimental feature called optional record fields, allowing you to rewrite the above to this instead:</p>
<pre class="codehilite"><code class="language-res">type user = {
  name: string,
  age?: int
}

// No need to set `age` unless it should have a value
let userWithoutAge = {
  name: &quot;Name&quot;,
}

let userWithAge = {
  name: &quot;Name&quot;,
  age: 34
}
</code></pre>

<p>Other than drastically improving the experience when working with large records with optional fields, this also has implications for bindings. For example, binding to JS APIs with large configuration objects is now more ergonomic.
This feature also paves the way for other exciting features coming in the next release, such as a more idiomatic representation of React components.</p>
<h2>What's next</h2>
<p>Version 10 brings the building blocks needed for a number of exciting new features that'll be available in the next version. Features ranging from native support for async/await, to a new version of the JSX integration, making it leaner and more flexible. You'll hear more about this soon.</p>
<h2>Upgrade guide</h2>
<p>Please see the detailed <a href="https://github.com/rescript-lang/rescript-compiler/blob/10.0_release/CHANGELOG.md">changelog</a> for a list of breaking changes.
Each breaking change lists suggestions on how to upgrade your project.
This can be out of your control in case of dependencies. In that case, please raise issues with the maintainers of those libraries.</p>
<p>One special word for PPXs, in particular for PPX authors: As mentioned in the changelog, some PPXs may give an error <code>"Attributes not allowed here"</code>. The solution is to adapt the PPXs following the example of <code>rescript-relay</code> in https://github.com/zth/rescript-relay/pull/372.</p>
<h2>Acknowledgements</h2>
<p>We would like to thank everyone from the community who volunteered their precious time to suport this project with contributions of any kind, from documentation, to PRs, to discussions in the forum.
In particular, thank you <a href="https://github.com/cknitt">@cknitt</a>, <a href="https://github.com/TheSpyder">@TheSpyder</a>, <a href="https://github.com/mattdamon108">@mattdamon108</a>, <a href="https://github.com/DZakh">@DZakh</a>, <a href="https://github.com/fhammerschmidt">@fhammerschmidt</a>, <a href="https://github.com/amiralies">@amiralies</a>, <a href="https://github.com/Minnozz">@Minnozz</a>, <a href="https://github.com/Zeta611">@Zeta611</a>, <a href="https://github.com/jchavarri">@jchavarri</a>, <a href="https://github.com/nkrkv">@nkrkv</a>, <a href="https://github.com/whitchapman">@whitchapman</a>, <a href="https://github.com/ostera">@ostera</a>, <a href="https://github.com/benadamstyles">@benadamstyles</a>, <a href="https://github.com/cannorin">@cannorin</a>, <a href="https://github.com/ClaireNeveu">@ClaireNeveu</a>, <a href="https://github.com/kevinbarabash">@kevinbarabash</a>, <a href="https://github.com/JsonKim">@JsonKim</a>, <a href="https://github.com/Sehun0819">@Sehun0819</a>, <a href="https://github.com/glennsl">@glennsl</a>, <a href="https://github.com/namenu">@namenu</a>, <a href="https://github.com/a-c-sreedhar-reddy">@a-c-sreedhar-reddy</a>.</p><h1>2023-05-17-enhanced-ergonomics-for-record-types</h1><hr />
<p>author: rescript-team
date: "2023-05-17"
title: Enhanced Ergonomics for Record Types
badge: roadmap
description: |
  A tour of new capabilities coming to ReScript v11</p>
<hr />
<blockquote>
<p>This is the second post covering new capabilities that'll ship in ReScript v11. You can check out the first post on <a href="https://rescript-lang.org/blog/improving-interop">better interop with customizable variants here</a>.</p>
</blockquote>
<p><a href="https://rescript-lang.org/docs/manual/latest/record">Records</a> are a fundamental part of ReScript, offering a clear and concise definition of complex data structures, immutability by default, great error messages, and support for exhaustive pattern matching.</p>
<p>Even though records are generally preferable for defining structured data, there are still a few ergonomic annoyances, such as...</p>
<ol>
<li>Existing record types can't be extended, which makes them hard to compose</li>
<li>Functions may only accept record arguments of the exact record type (no explicit sub-typing)</li>
</ol>
<p>To mitigate the limitations above, one would need to retreat to <a href="https://rescript-lang.org/docs/manual/latest/object#sidebar">structural objects</a> to allow more flexible object field sharing and sub-typing, at the cost of more complex type errors and no pattern matching capabilities.</p>
<p>We think that records are a much more powerful data structure though, so we want to encourage more record type usage for these scenarios. This is why ReScript v11 will come with two new big enhancements for record types: <strong>Record Type Spread</strong> and <strong>Record Type Coercion</strong>.</p>
<p>Let's dive right into the details and show-case the new language capabilities.</p>
<h2>Record Type Spread</h2>
<p>As stated above, there was no way to share subsets of record fields with other record types. This means one had to copy / paste all the fields between the different record definitions. This was often tedious, error-prone and made code harder to maintain, especially when working with records with many fields.</p>
<p>In ReScript v11, you can now spread one or more record types into a new record type. It looks like this:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  id: string,
  name: string,
}

type b = {
  age: int
}

type c = {
  ...a,
  ...b,
  active: bool
}
</code></pre>

<p><code>type c</code> will now be:</p>
<pre class="codehilite"><code class="language-rescript">type c = {
  id: string,
  name: string,
  age: int,
  active: bool,
}
</code></pre>

<p>Record type spreads act as a 'copy-paste' mechanism for fields from one or more records into a new record. This operation inlines the fields from the spread records directly into the new record definition, while preserving their original properties, such as whether they are optional or mandatory. It's important to note that duplicate field names are not allowed across the records being spread, even if the fields share the same type.</p>
<p>Needless to say, this feature offers a much better ergonomics when working with types with lots of fields, where variations of the same underlying type are needed.</p>
<h3>Use case: Extending the Built-in DOM Nodes</h3>
<p>This feature can be particularly useful when extending DOM nodes. For instance, in the case of the animation library Framer Motion, one could easily extend the native DOM types with additional properties specific to the library, leading to a more seamless and type-safe integration.</p>
<p>This is how you could bind to a <code>div</code> in Framer Motion with the new record type spreads:</p>
<pre class="codehilite"><code class="language-rescript">type animate = {} // definition omitted for brevity

type divProps = {
  // Note: JsxDOM.domProps is a built-in record type with all valid DOM node attributes
  ...JsxDOM.domProps,
  initial?: animate,
  animate?: animate,
  whileHover?: animate,
  whileTap?: animate,
}

module Div = {
  @module(&quot;framer-motion&quot;) external make: divProps =&gt; Jsx.element = &quot;div&quot;
}
</code></pre>

<p>You can now use <code>&lt;Div /&gt;</code> as a <code>&lt;motion.div /&gt;</code> component from Framer Motion and your type definition is quite simple and easy to maintain.</p>
<h2>Record Type Coercion</h2>
<p>Record type coercion gives us more flexibility when passing around records in our application code. In other words, we can now coerce a record <code>a</code> to be treated as a record <code>b</code> at the type level, as long as the original record <code>a</code> contains the same set of fields in <code>b</code>. Here's an example:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  name: string,
  age: int,
}

type b = {
  name: string,
  age: int,
}

let nameFromB = (b: b) =&gt; b.name

let a: a = {
  name: &quot;Name&quot;,
  age: 35,
}

let name = nameFromB(a :&gt; b)
</code></pre>

<p>Notice how we <em>coerced</em> the value <code>a</code> to type <code>b</code> using the coercion operator <code>:&gt;</code>. This works because they have the same record fields. This is purely at the type level, and does not involve any runtime operations.</p>
<p>Additionally, we can also coerce records from <code>a</code> to <code>b</code> whenever <code>a</code> is a super-set of <code>b</code> (i.e. <code>a</code> containing all the fields of <code>b</code>, and more). The same example as above, slightly altered:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  id: string,
  name: string,
  age: int,
  active: bool,
}

type b = {
  name: string,
  age: int,
}

let nameFromB = (b: b) =&gt; b.name

let a: a = {
  id: &quot;1&quot;,
  name: &quot;Name&quot;,
  age: 35,
  active: true,
}

let name = nameFromB(a :&gt; b)
</code></pre>

<p>Notice how <code>a</code> now has more fields than <code>b</code>, but we can still coerce <code>a</code> to <code>b</code> because <code>b</code> has a subset of the fields of <code>a</code>.</p>
<p>In combination with <a href="/docs/manual/latest/record#optional-record-fields">optional record fields</a>, one may coerce a mandatory field of an <code>option</code> type to an optional field:</p>
<pre class="codehilite"><code class="language-rescript">type a = {
  name: string,

  // mandatory, but explicitly typed as option&lt;int&gt;
  age: option&lt;int&gt;,
}

type b = {
  name: string,
  // optional field
  age?: int,
}

let nameFromB = (b: b) =&gt; b.name

let a: a = {
  name: &quot;Name&quot;,
  age: Some(35),
}

let name = nameFromB(a :&gt; b)
</code></pre>

<p>The last example was rather advanced; the full feature set of record type coercion will later on be covered in a dedicated document page.</p>
<h3>Record Type Coercion is Explicit</h3>
<p>Records are nominally typed, so it is not possible to pass a record <code>a</code> as record <code>b</code> without an explicit type coercion. This conscious design decision prevents accidental type matching on shapes rather than records, ensuring predictable and more robust type checking results.</p>
<h2>Try it out!</h2>
<p>Feel free to check out the v11 alpha version on our <a href="https://rescript-lang.org/try?version=v11.0.0-alpha.5&amp;code=LYewJgrgNgpgBAJRgYxAJzAFQJ4AcYDKuaMAhmAKIAepwuscAvHAN4BQccALnvKU6w6c4AO1owAXHADOXNAEsRAcwA0QzqSWS4irms4BfNkJ744AIwHtho8VNkLl+4Zu27nRobC63gMAGJoIMAAQgIAFOZS5gCUTAB8FgB0Yn7GnN5wpFL8zNbCqdoARABy4kXOGlpSAMwArB7pcJmFAoWBwSHh4fwSibExbJ6gkAxIqBg4+ADCIDBoyPIgItS09PB5JrxZVuo6YPZyiqp7hYeOJzauUu57pMhc8gBu2uYgIFCNW2aWmzZnMiOTju1R0Ij0Qk8GRgPnaQVCESiFjijH6KXETUy2R2f2E8gOcCKAEYKqc7ISyn5SVdQfVKlkHs9tHIIDAvtDYeI2uIOqFur1+jFBkYgA">online playground</a>, or install the alpha release via npm: <code>npm i rescript@11.0.0-alpha.6</code>.</p>
<p>This release is mainly for feedback purposes and not intended for production usage.</p>
<h2>Conclusion</h2>
<p>The introduction of Record Type Spreads and Coercion in ReScript v11 will greatly improve the handling of record types. We're eager to see how you'll leverage these new language features in your ReScript projects.</p>
<p>Happy coding!</p><h1>2023-04-17-improving-interop</h1><hr />
<p>author: rescript-team
date: "2023-04-17"
title: Better interop with customizable variants
badge: roadmap
description: |
  A tour of new capabilities coming in ReScript v11</p>
<hr />
<p>ReScript v11 is around the corner, and it comes packed with new features that will improve interop with JavaScript/TypeScript. Recently we've made some changes to the runtime representation of variants that'll allow you to use variants for a large number of new interop scenarios, zero cost. This is important, because variants are <em>the</em> feature of ReScript, enabling great data modeling, pattern matching and more.</p>
<ul>
<li><strong>Customizable runtime representation.</strong> We're making the runtime representation of variants customizable. This will allow you to cleanly map variants to external data and APIs in many more cases than before.</li>
<li><strong>Zero cost bindings to discriminated unions.</strong> Variants with inline records will map cleanly to JavaScript/TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions">discriminated unions</a>.</li>
<li><strong>Unboxed (untagged) variants.</strong> We also introduce untagged variants - variants where the underlying runtime representation can be a primitive, without a specific discriminator. This will let you cleanly map to things like heterogenous array items, nullable values, and more.</li>
</ul>
<p>Let's dive into the details.</p>
<h2>Tagged variants</h2>
<p>Variants with payloads have always been represented as a tagged union at runtime. Here's an example:</p>
<pre class="codehilite"><code class="language-rescript">type entity = User({name: string}) | Group({workingName: string})

let user = User({name: &quot;Hello&quot;})
</code></pre>

<p>This is represented as:</p>
<pre class="codehilite"><code class="language-javascript">var user = {
  TAG: /* User */ 0,
  name: &quot;Hello&quot;,
};
</code></pre>

<p>However, this has been problematic when binding to external data because there has been no way to customize the discriminator (the <code>TAG</code> property) or how its value is represented for each variant case (<code>0</code> representing <code>User</code> here). This means that unless your external data is modeled the exact same way as above, which is unlikely, you'd be forced to convert to the structure ReScript expects at runtime.</p>
<p>To illustrate this, let's imagine we're binding to an external union that looks like this in TypeScript:</p>
<pre class="codehilite"><code class="language-typescript">type LoadingState =
  | { state: &quot;loading&quot;; ready: boolean }
  | { state: &quot;error&quot;; message: string }
  | { state: &quot;done&quot;; data: Data };
</code></pre>

<p>Currently, there's no good way to use a ReScript variant to represent this type without resorting to manual and error-prone runtime conversion. However, with the new functionality, binding to the above with no additional runtime cost is easy:</p>
<pre class="codehilite"><code class="language-rescript">@tag(&quot;state&quot;)
type loadingState = | @as(&quot;loading&quot;) Loading({ready: bool}) | @as(&quot;error&quot;) Error({message: string}) | @as(&quot;done&quot;) Done({data: data})

let state = Error({message: &quot;Something went wrong!&quot;})
</code></pre>

<p>This will compile to:</p>
<pre class="codehilite"><code class="language-javascript">var state = {
  state: &quot;error&quot;,
  message: &quot;Something went wrong!&quot;,
};
</code></pre>

<p>Let's break down what we've done to make this work:</p>
<ul>
<li>The <code>@tag</code> attribute lets you customize the discriminator (default: <code>TAG</code>). We're setting that to <code>"state"</code> so we map to what the external data looks like.</li>
<li>Each variant case has an <code>@as</code> attribute. That controls what each variant case is discriminated on (default: the variant case name as string). We're setting all of the cases to their lowercase equivalent, because that's what the external data looks like.</li>
</ul>
<p>The end result is clean and zero cost bindings to the external data, in a way that previously would require manual runtime conversion.</p>
<p>Now, let's look at a few more real-world examples.</p>
<h3>Binding to TypeScript enums</h3>
<pre class="codehilite"><code class="language-typescript">// direction.ts
/** Direction of the action. */
enum Direction {
  /** The direction is up. */
  Up = &quot;UP&quot;,

  /** The direction is down. */
  Down = &quot;DOWN&quot;,

  /** The direction is left. */
  Left = &quot;LEFT&quot;,

  /** The direction is right. */
  Right = &quot;RIGHT&quot;,
}

export const myDirection = Direction.Up;
</code></pre>

<p>Previously, you'd be forced to use a polymorphic variant for this if you wanted clean, zero-cost interop:</p>
<pre class="codehilite"><code class="language-rescript">type direction = [#UP | #DOWN | #LEFT | #RIGHT]
@module(&quot;./direction.js&quot;) external myDirection: direction = &quot;myDirection&quot;
</code></pre>

<p>Notice a few things:</p>
<ul>
<li>We're forced to use the names of the enum payload, meaning it won't fully map to what you'd use in TypeScript</li>
<li>There's no way to bring over the documentation strings, because polymorphic variants are structural, so there's no one source definition for them to look for docstrings on. This is true <em>even</em> if you annotate with your explicitly written out polymorphic variant definition.</li>
</ul>
<p>With the new runtime representation, this is how you'd bind to the above enum instead:</p>
<pre class="codehilite"><code class="language-rescript">/** Direction of the action. */
type direction =
  | /** The direction is up. */
  @as(&quot;UP&quot;)
  Up

  | /** The direction is down. */
  @as(&quot;DOWN&quot;)
  Down

  | /** The direction is left. */
  @as(&quot;LEFT&quot;)
  Left

  | /** The direction is right. */
  @as(&quot;RIGHT&quot;)
  Right

@module(&quot;./direction.js&quot;) external myDirection: direction = &quot;myDirection&quot;
</code></pre>

<p>Now, this maps 100% to the TypeScript code, including letting us bring over the documentation strings so we get a nice editor experience.</p>
<h3>String literals</h3>
<p>The same logic is easily applied to string literals from TypeScript, only here the benefit is even larger, because string literals have the same limitations in TypeScript that polymorphic variants have in ReScript.</p>
<pre class="codehilite"><code class="language-typescript">// direction.ts
type direction = &quot;UP&quot; | &quot;DOWN&quot; | &quot;LEFT&quot; | &quot;RIGHT&quot;;
</code></pre>

<p>There's no way to attach documentation strings to string literals in TypeScript, and you only get the actual value to interact with.</p>
<p>With the new customizable variants, you could bind to the above string literal type easily, but add documentation, and change the name you interact with in ReScript. And there's no runtime cost.</p>
<h3>Untagged variants</h3>
<p>We've also implemented support for <em>untagged variants</em>. This will let you use variants to represent values that are primitives and literals in a way that hasn't been possible before.</p>
<p>We'll explain what this is and why it's useful by showing a number of real world examples. Let's start with a simple one on how we can now represent a heterogenous array.</p>
<pre class="codehilite"><code class="language-rescript">@unboxed type listItemValue = String(string) | Boolean(bool) | Number(float)

let myArray = [String(&quot;Hello&quot;), Boolean(true), Boolean(false), Number(13.37)]
</code></pre>

<p>Here, each value will be <em>unboxed</em> at runtime. That means that the variant payload will be all that's left, the variant case name wrapping the payload itself will be stripped out and the payload will be all that remains.</p>
<p>It, therefore, compiles to this JS:</p>
<pre class="codehilite"><code class="language-javascript">var myArray = [&quot;hello&quot;, true, false, 13.37];
</code></pre>

<p>This was previously possible to do, leveraging a few tricks, when you didn't need to potentially read the values from the array again in ReScript. But, if you wanted to read back the values, you'd have to do a number of manual steps.</p>
<p>In the above example, reaching back into the values is as simple as pattern matching on them.</p>
<p>Let's look at a few more examples of what untagged variants enable.</p>
<h3>Pattern matching on nullable values</h3>
<p>Previously, any value that might be <code>null</code> would need to be explicitly converted to an option by using for example <code>Null.toOption</code> before you could use pattern matching on it. Here's a typical example of how that could look:</p>
<pre class="codehilite"><code class="language-rescript">type userAge = {ageNum: Null.t&lt;int&gt;}

type rec user = {
  name: string,
  age: Null.t&lt;userAge&gt;,
  bestFriend: Null.t&lt;user&gt;,
}

let getBestFriendsAge = user =&gt;
  switch user.bestFriend-&gt;Null.toOption {
  | Some({age}) =&gt;
    switch age-&gt;Null.toOption {
    | None =&gt; None
    | Some({ageNum}) =&gt; ageNum-&gt;Null.toOption
    }
  | None =&gt; None
  }
</code></pre>

<p>As you can see, you need to convert each level of nullables explicitly, which makes it hard to fully utilize pattern matching. With the new unboxed variant representation, we'll instead be able to do this:</p>
<pre class="codehilite"><code class="language-rescript">// The type definition below is inlined here to examplify, but this definition will live in [Core](https://github.com/rescript-association/rescript-core) and be easily accessible
module Null = {
  @unboxed type t&lt;'a&gt; = Present('a) | @as(null) Null
}

type userAge = {ageNum: Null.t&lt;int&gt;}

type rec user = {
  name: string,
  age: Null.t&lt;userAge&gt;,
  bestFriend: Null.t&lt;user&gt;,
}

let getBestFriendsAge = user =&gt;
  switch user.bestFriend {
  | Present({age: Present({ageNum: Present(ageNum)})}) =&gt; Some(ageNum)
  | _ =&gt; None
  }
</code></pre>

<blockquote>
<p>Notice how <code>@as</code> now allows us to say that an unboxed variant case should map to a specific underlying <em>primitive</em>. <code>Present</code> has a type variable, so it can hold any type. And since it's an unboxed type, only the payloads <code>'a</code> or <code>null</code> will be kept at runtime. That's where the magic comes from.</p>
</blockquote>
<p>We can now utilize pattern matching fully without needing to do any conversion.</p>
<p>This has a few implications:</p>
<ul>
<li>Dealing with external data, that is often nullable and seldom guaranteed to map cleanly to <code>option</code> without needing conversion, becomes much easier and zero cost.</li>
<li>Special handling like <a href="https://rescript-lang.org/syntax-lookup#return-decorator">@return(nullable)</a> becomes redundant. This is good also because the current functionality does not work in all cases. The new functionality will work anywhere.</li>
</ul>
<h3>Decoding and encoding JSON idiomatically</h3>
<p>With unboxed variants, we have everything we need to define a JSON type:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type rec json =
  | @as(false) False
  | @as(true) True
  | @as(null) Null
  | String(string)
  | Number(float)
  | Object(Js.Dict.t&lt;json&gt;)
  | Array(array&lt;json&gt;)

let myValidJsonValue = Array([String(&quot;Hi&quot;), Number(123.)])
</code></pre>

<p>Here's an example of how you could write your own JSON decoders easily using the above, leveraging pattern matching:</p>
<pre class="codehilite"><code class="language-rescript">@unboxed
type rec json =
  | @as(false) False
  | @as(true) True
  | @as(null) Null
  | String(string)
  | Number(float)
  | Object(Js.Dict.t&lt;json&gt;)
  | Array(array&lt;json&gt;)

type rec user = {
  name: string,
  age: int,
  bestFriend: option&lt;user&gt;,
}

let rec decodeUser = json =&gt;
  switch json {
  | Object(userDict) =&gt;
    switch (
      userDict-&gt;Dict.get(&quot;name&quot;),
      userDict-&gt;Dict.get(&quot;age&quot;),
      userDict-&gt;Dict.get(&quot;bestFriend&quot;),
    ) {
    | (Some(String(name)), Some(Number(age)), Some(maybeBestFriend)) =&gt;
      Some({
        name,
        age: age-&gt;Float.toInt,
        bestFriend: maybeBestFriend-&gt;decodeUser,
      })
    | _ =&gt; None
    }
  | _ =&gt; None
  }

let decodeUsers = json =&gt;
  switch json {
  | Array(array) =&gt; array-&gt;Array.map(decodeUser)-&gt;Array.keepSome
  | _ =&gt; []
  }
</code></pre>

<p>Encoding that same structure back into JSON is also easy:</p>
<pre class="codehilite"><code class="language-rescript">let rec userToJson = user =&gt; Object(
  Dict.fromArray([
    (&quot;name&quot;, String(user.name)),
    (&quot;age&quot;, Number(user.age-&gt;Int.toFloat)),
    (
      &quot;bestFriend&quot;,
      switch user.bestFriend {
      | None =&gt; Null
      | Some(friend) =&gt; userToJson(friend)
      },
    ),
  ]),
)

let usersToJson = users =&gt; Array(users-&gt;Array.map(userToJson))
</code></pre>

<p>This can be extrapolated to many more cases.</p>
<h2>Wrapping up</h2>
<p>We hope you'll enjoy using these new capabilities. Some of them are a big leap forward for ReScript's interop with JavaScript and TypeScript, and we hope they will simplify many scenarios and open up a few new doors.</p>
<p>And last but not least, you can try ReScript v11 today by installing <code>npm i rescript@next</code>.</p><h1>2023-09-18-uncurried-mode</h1><hr />
<p>author: rescript-team
date: "2023-09-18"
title: Uncurried Mode
badge: roadmap
description: |
  A tour of new capabilities coming to ReScript v11</p>
<hr />
<blockquote>
<p>This is the fourth post covering new capabilities that'll ship in ReScript v11. You can check out the first post on <a href="/blog/improving-interop">Better Interop with Customizable Variants</a>, the second post on <a href="/blog/enhanced-ergonomics-for-record-types">Enhanced Ergonomics for Record Types</a> and the third post on <a href="/blog/first-class-dynamic-import-support">First-class Dynamic Import Support</a>.</p>
</blockquote>
<h2>Introduction</h2>
<p>ReScript is a language that strives to keep its users free from experiencing runtime errors. Usually, when a program compiles, it will already do what the user described.
But there is still a concept in the language that makes it easy to let some errors slip through. Currying! </p>
<p>Because of currying, partial application of functions is possible. That feature is always advertised as something really powerful. For instance, </p>
<pre class="codehilite"><code class="language-rescript">let add = (a, b) =&gt; a + b
let addFive = add(5)
</code></pre>

<p>is shorter than having to write all remaining parameters again </p>
<pre class="codehilite"><code class="language-rescript">let add = (a, b) =&gt; a + b
let addFive = (b) =&gt; add(5, b)
</code></pre>

<p>This comes at a price though. Here are some examples to show the drawbacks of currying: </p>
<ul>
<li>Errors because of changed function signatures have their impact at the use site. Consider this example, where the signature of the onChange function is extended with
a labeled argument 
  ```diff
    @react.component</li>
<li>let make = (~onChange: string =&gt; option<unit => unit&gt;) =&gt; {</li>
<li>let make = (~onChange: (~a: int, string) =&gt; option<unit => unit&gt;) =&gt; {
      React.useEffect(() =&gt; {
        // As partial application is allowed, there is no error here.
        let cleanup = onChange("change") <pre class="codehilite"><code>// Here it errors with &quot;This call is missing an argument of type (~a: int)&quot;
cleanup
</code></pre>

<p>})
}
  <code>* If you wanted explicitly uncurry a function, you needed to annotate it with the uncurried dot.</code>rescript
  (. param) =&gt; ()
  <code>* As ReScript could not fully statically analyze when to automatically uncurry a function over multiple files, it led to unnecessary `Curry.` calls in the emitted JavaScript code. 
* In the standard library (`Belt`), there are both curried and uncurried versions of the same function so you were required to think for yourself when to use the uncurried version and when only the curried one will work.
* In combination with `ignore` / `let _ = ...`, curried can lead to unexpected behavior at runtime after adding a parameter to a function, because you are accidentally ignoring the result of a partial evaluation so that the function is not called at all.
  1. Have a look at this simple function. It is assigned to `_` because we ignore the resulting `string` value.</code>res
let myCurriedFn = (~first) =&gt; first
let _ = myCurriedFn(~first="Hello!")
//  ^ string
<code>2. Now the function got a second parameter `~second`. Here, the resulting value is a function, which means it is not fully applied and thus never executed.</code>res
let myCurriedFn = (~first, ~second) =&gt; first ++ " " ++ second
let _ = myCurriedFn(~first="Hello!")
//  ^ (~second: string) =&gt; string
<code>3. One way to prevent such errors is to annotate the underscore with the function's return type:</code>res
let _: string = myCurriedFn(~first="Hello!")
<code>4. However, the same issue arises when using the built-in ignore function, which cannot be annotated:</code>res
myCurriedFn(~first="Hello!")-&gt;ignore
```</p>
</li>
</ul>
<p>Those are all only some small paper cuts, but all of them are intricacies that make the language harder to learn. </p>
<h2>Uncurried mode</h2>
<p>Starting with ReScript 11, your code will be compiled in uncurried mode. Yes, there is still a way to turn it off (<a href="#how-to-switch-back-to-curried-mode">see below</a>), but we have decided to already default to this behavior to make it easier for newcomers.
In uncurried mode, the introductory example yields an error:</p>
<pre class="codehilite"><code class="language-rescript">let add = (a, b) =&gt; a + b
let addFive = add(5) // &lt;-- Error:
// This uncurried function has type (. int, int) =&gt; int
// It is applied with 1 arguments but it requires 2.
</code></pre>

<p>to fix it, you have two options:</p>
<ol>
<li>state the remaining parameters explicitly 
  <code>rescript
  let add = (a, b) =&gt; a + b
  let addFive = (b) =&gt; add(5, b)</code></li>
<li>or use the new explicit syntax for partial application 
  <code>rescript
  let add = (a, b) =&gt; a + b
  let addFive = add(5, ...)</code></li>
</ol>
<p>The former approach helps library authors support both ReScript 11 and earlier versions.</p>
<h3>No final unit anymore</h3>
<p>We are happy to announce that with uncurried mode the "final unit" pattern is not necessary anymore, while you still can use optional or default parameters.</p>
<pre class="codehilite"><code class="language-res">// old 
let myFun = (~name=?, ())

// new
let myFun = (~name=?)
</code></pre>

<h3>More wins</h3>
<p>Furthermore, function calls in uncurried mode are now guaranteed to get compiled as simple JavaScript function calls, which is quite nice for readability of the generated code. 
It may also give you some (negligible) performance gains. </p>
<h3>How to switch back to curried mode</h3>
<p>While we strongly encourage all users to switch to the new uncurried mode, it is still possible to opt out. Just add a</p>
<pre class="codehilite"><code class="language-json">{
  &quot;uncurried&quot;: false
}
</code></pre>

<p>to your <code>bsconfig.json</code>, and your project will be compiled in curried mode again.</p>
<p>If you have uncurried mode off and still want to try it on a per-file basis, you can turn it on via </p>
<pre class="codehilite"><code class="language-rescript">@@uncurried
</code></pre>

<p>at the top of a <code>.res</code> file.</p>
<h2>Conclusion</h2>
<p>Many thoughts have led to this decision, but we think this change is a great fit for a compile-to-JS language overall. If you are interested in the details, have a look at the corresponding <a href="https://forum.rescript-lang.org/t/uncurried-by-default/">forum post</a> and its comments.</p>
<p>We hope that this new way of writing ReScript will make it both easier for beginners and also more enjoyable for the seasoned developers.</p>
<p>As always, we're eager to hear about your experiences with our new features. Feel free to share your thoughts and feedback with us on our <a href="https://github.com/rescript-lang/rescript-compiler/issues">issue tracker</a> or on the <a href="https://forum.rescript-lang.org">forum</a>.</p>
<p>Happy hacking!</p><h1>2023-06-05-first-class-dynamic-import-support</h1><hr />
<p>author: rescript-team
date: "2023-06-05"
title: First-class Dynamic Import Support
badge: roadmap
description: |
  A tour of new capabilities coming to ReScript v11</p>
<hr />
<blockquote>
<p>This is the third post covering new capabilities that'll ship in ReScript v11. You can check out the first post on <a href="/blog/improving-interop">Better Interop with Customizable Variants</a> and the second post on <a href="/blog/enhanced-ergonomics-for-record-types">Enhanced Ergonomics for Record Types</a>.</p>
</blockquote>
<h2>Introduction</h2>
<p>When developing apps in JavaScript, every line of code eventually needs to be bundled up and shipped to the browser. As the app grows, it's usually a good idea to split up and load parts of the app code on demand as separate JS modules to prevent bundle bloat.</p>
<p>To accomplish this, browsers provide support for dynamic loading via the globally available <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"><code>import()</code></a> function to allow code splitting and lazy loading and ultimately reducing initial load times for our applications.</p>
<p>Even though ReScript has been able to bind to <code>import</code> calls via <code>external</code> bindings, doing so was quite hard to maintain for to the following reasons:</p>
<ol>
<li>An <code>import</code> call requires a path to a JS file. The ReScript compiler doesn't directly expose file paths for compiled modules, so the user has to manually find and rely on compiled file paths.</li>
<li>The return type of an <code>import</code> call needs to be defined manually; a quite repetitive task with lots of potential bugs when the imported module has changed.</li>
</ol>
<p>Arguably, these kind of problems should ideally be tackled on the compiler level, since the ReScript compiler knows best about module structures and compiled JS file locations — so we finally decided to fix this.</p>
<p>Today we're happy to announce that ReScript v11 will ship with first-class support for dynamic imports as part of the language.</p>
<p>Let's have a look!</p>
<h2>Import Parts of a Module</h2>
<p>We can now use the <code>Js.import</code> function to dynamically import a value or function from a ReScript module. The import call will return a promise, resolving to the dynamically loaded value.</p>
<p>For example, imagine the following file <code>MathUtils.res</code>:</p>
<pre class="codehilite"><code class="language-rescript">// MathUtils.res
let add = (a, b) =&gt; a + b
let sub = (a, b) =&gt; a - b
</code></pre>

<p>Now let's dynamically import the <code>add</code> function in another module, e.g. <code>App.res</code>:</p>
<pre class="codehilite"><code class="language-rescript">// App.res
let main = async () =&gt; {
  let add = await Js.import(MathUtils.add)
  let onePlusOne = add(1, 1)

  RescriptCore.Console.log(onePlusOne)
}
</code></pre>

<p>This compiles to:</p>
<pre class="codehilite"><code class="language-javascript">async function main() {
  var add = await import(&quot;./MathUtils.mjs&quot;).then(function(m) {
    return m.add;
  });

  var onePlusOne = add(1, 1);
  console.log(onePlusOne);
}
</code></pre>

<p>Notice how the compiler keeps track of the relative path to the module you're importing, as well as plucking out the value you want to use from the imported module.</p>
<p>Quite a difference compared to doing both of those things manually, right? Now let's have a look at a more concrete use-case with React components.</p>
<h3>Use-case: Importing a React component</h3>
<blockquote>
<p><strong>Note:</strong> This section requires the latest <a href="https://github.com/rescript-lang/rescript-react">@rescript/react</a> bindings to be installed (<em>0.12.0-alpha.2 and above</em>).</p>
</blockquote>
<p>Our dynamic import makes tasks like <a href="https://react.dev/reference/react/lazy#lazy">lazy loading React components</a> a simple one-liner. First let's define a simple component as an example:</p>
<pre class="codehilite"><code class="language-rescript">// Title.res
@react.component
let make = (~text) =&gt; {
  &lt;div className=&quot;title&quot;&gt;{text-&gt;React.string}&lt;/div&gt;
}
</code></pre>

<p>Now let's dynamically import the <code>&lt;Title/&gt;</code> component by passing the result of our dynamic import to <code>React.lazy_</code>:</p>
<pre class="codehilite"><code class="language-rescript">module LazyTitle = {
  let make = React.lazy_(() =&gt; Js.import(Title.make))
}

let titleJsx = &lt;LazyTitle text=&quot;Hello!&quot; /&gt;
</code></pre>

<p>That's all the code we need! The new <code>&lt;LazyTitle /&gt;</code> component behaves exactly the same as the wrapped <code>&lt;Title /&gt;</code> component, but will be lazy loaded via React's built in lazy mechanism.</p>
<p>Needless to say, all the code examples you've seen so far are fully type-safe.</p>
<h2>Import a Whole Module</h2>
<p>Sometimes it is useful to dynamically import the whole module instead. For example, you might have a collection of utility functions in a dedicated module that tend to be used together.</p>
<p>The syntax for importing a whole module looks a little different, since we are operating on the module syntax level; instead of using <code>Js.import</code>, you may simply <code>await</code> the module itself:</p>
<pre class="codehilite"><code class="language-rescript">// App.res
let main = async () =&gt; {
  module Utils = await MathUtils

  let twoPlusTwo = Utils.add(2, 2)
  RescriptCore.Console.log(twoPlusTwo)
}
</code></pre>

<p>And, the generated JavaScript will look like this:</p>
<pre class="codehilite"><code class="language-js">async function main() {
  var Utils = await import(&quot;./MathUtils.mjs&quot;);

  var twoPlusTwo = Utils.add(2, 2);
  console.log(twoPlusTwo);
}
</code></pre>

<p>The compiler correctly inserts the module's import path and stores the result in a <code>Utils</code> variable.</p>
<h2>Try it out!</h2>
<p>Feel free to try out our new dynamic import feature with the latest beta release:</p>
<p><code>npm install rescript@11.0.0-beta.1</code></p>
<p>Please note that this release is only intended for experiments and feedback purposes.</p>
<h2>Conclusion</h2>
<p>The most important take away of the new dynamic imports functionality in ReScript is that you'll never need to care about <em>where</em> what you're importing is located on the file system - the compiler already does it for you.</p>
<p>We hope that it will help shipping software with better end-user experience with faster load times and quicker app interaction, especially on slower network connections.</p>
<p>As always, we're eager to hear about your experiences with our new features. Feel free to share your thoughts and feedback with us on our <a href="https://github.com/rescript-lang/rescript-compiler/issues">issue tracker</a> or on the <a href="https://forum.rescript-lang.org">forum</a>.</p>
<p>Happy hacking!</p><h1>2023-02-02-release-10-1</h1><hr />
<p>author: rescript-team
date: "2023-02-02"
title: ReScript 10.1
badge: release
description: |
  Async/await &amp; better Promise support, JSX v4, and more!</p>
<hr />
<h2>Introduction</h2>
<p>We are happy to announce ReScript 10.1!</p>
<p>ReScript is a robustly typed language that compiles to efficient and human-readable JavaScript. It comes with one of the fastest build toolchains and offers first class support for interoperating with ReactJS and other existing JavaScript code.</p>
<p>Use <code>npm</code> to install the newest <a href="https://www.npmjs.com/package/rescript/v/10.1.2">10.1 release</a>:</p>
<pre class="codehilite"><code>npm install rescript

# or

npm install rescript@10.1
</code></pre>

<p>This version comes with two major language improvements we've all been waiting for. <strong>async/await support</strong> for an easy way to write asynchronous code in a synchronous manner, and a <strong>new JSX transform</strong> with better ergonomics, code generation and React 18 support.</p>
<p>Alongside the major changes, there have been many bugfixes and other improvements that won't be covered in this post.</p>
<p>Feel free to check the <a href="https://github.com/rescript-lang/rescript-compiler/blob/master/CHANGELOG.md#1011">Changelog</a> for all the details.</p>
<h2>New <code>async</code> / <code>await</code> syntax</h2>
<p>Async / await has arrived. Similar to its JS counterparts, you are now able to define <code>async</code> functions and use the <code>await</code> operator to unwrap a promise value. This allows writing asynchronous code in a synchronous fashion.</p>
<p><strong>Example:</strong></p>
<pre class="codehilite"><code class="language-res">// Some fictive functionality that offers asynchronous network actions
@val external fetchUserMail: string =&gt; promise&lt;string&gt; = &quot;GlobalAPI.fetchUserMail&quot;
@val external sendAnalytics: string =&gt; promise&lt;unit&gt; = &quot;GlobalAPI.sendAnalytics&quot;

// We use the `async` keyword to allow the use of `await` in the function body
let logUserDetails = async (userId: string) =&gt; {
  // We use `await` to fetch the user email from our fictive user endpoint
  let email = await fetchUserMail(userId)

  await sendAnalytics(`User details have been logged for ${userId}`)

  Js.log(`Email address for user ${userId}: ${email}`)
}
</code></pre>

<p>To learn more about our async / await feature, check out the relevant <a href="/docs/manual/latest/async-await">manual section</a>.</p>
<h2>New <code>promise</code> builtin type and <code>Js.Promise2</code> module</h2>
<p>In previous versions of ReScript, promises were expressed as a <code>Js.Promise.t&lt;'a&gt;</code> type, which was a little tedious to type. From now on, users may use the <code>promise&lt;'a&gt;</code> type instead.</p>
<p>Quick example of a <code>.resi</code> file using the new <code>promise</code> type:</p>
<pre class="codehilite"><code class="language-resi">// User.resi
type user

let fetchUser: string =&gt; promise&lt;user&gt;
</code></pre>

<p>Way easier on the eyes, don't you think? Note that the new <code>promise</code> type is fully compatible with <code>Js.Promise.t</code> (no breaking changes).</p>
<p>Additionally, we also introduced the <code>Js.Promise2</code> module as a stepping stone to migrate <code>Js.Promise</code> based code to a first-pipe (-&gt;) friendly solution. For the daily practise you'll almost always want to use <code>async</code> / <code>await</code> to handle promises.</p>
<p>(<em>Sidenote</em>: We are also well aware that our users want a solution to unify <code>Belt</code>, <code>Js</code> and <code>Js.xxx2</code> and have a fully featured "standard library" instead of adding more <code>Js.xxx2</code> modules. Good news is that we have a solution in the pipeline to fix this. <code>Js.Promise2</code> was introduced to ease the process later on and is not supposed to be the panacea of promise handling.)</p>
<p>If you are already using a third-party promise library like <a href="https://github.com/ryyppy/rescript-promise">ryyppy/rescript-promise</a> or similar, there's no need to migrate any existing code. Introduce <code>async</code> / <code>await</code> gradually in your codebase as you go.</p>
<h2>New JSX v4 syntax</h2>
<p>ReScript 10.1 now ships with JSX v4. Here's what's new:</p>
<ul>
<li><strong>Cleaner interop.</strong> Due to recent improvements in the type checker, the <code>@react.component</code> transformation doesn't require any <code>makeProps</code> convention anymore. <code>make</code> functions will now be transformed into a <code>prop</code> type and a component function. That's it.</li>
<li><strong>Two new transformation modes</strong>. JSX v4 comes with a <code>classic</code> mode (= <code>React.createElement</code>) and <code>automatic</code> mode (= <code>jsx-runtime</code> calls). The latter is the new default, moving forward with <code>rescript/react@0.11</code> and <code>React@18</code>.</li>
<li><strong>Allow mixing JSX configurations on the project and module level.</strong> Gradually mix and match JSX transformations and modes without migrating any old code!</li>
<li><strong>Pass <code>prop</code> types</strong> to <code>@react.component</code>. You can now fine tune <code>@react.component</code> with your specific prop type needs. Very useful for libraries and frameworks to define component interfaces.</li>
<li><strong>Less boilerplate when using <code>React.Context</code></strong>. Check out our <a href="/docs/react/latest/migrate-react#reactcontext">example</a> for comparison. </li>
<li><strong>Revisited props spread operator.</strong> This will allow users to spread records in JSX without sacrificing their sanity. Note that this implementation has harder constraints than its JS counterpart. (requires <code>rescript/react@0.11</code> or higher)</li>
<li><strong>Better type inference of props.</strong> Type inference when passing e.g. variants that are defined in the same module as the component is much improved. With the earlier JSX version, you'd often need to write code like this in order for the compiler to understand which variant you're passing: <code>&lt;Button variant=Button.Primary text="Click" /&gt;</code>. With JSX v4, you won't need to tell the compiler where the variant you're passing is located: <code>&lt;Button variant=Primary text="Click" /&gt;</code>.</li>
</ul>
<p>Code tells more than words, so here's a non-exhaustive code example to highlight the different JSX features. Make sure to also check out the JS output and play around with the code in our newest playground!</p>
<p><CodeTab labels={["ReScript", "JS Output"]}></p>
<pre class="codehilite"><code class="language-res">// Set the jsx configuration per module
@@jsxConfig({version: 4, mode: &quot;automatic&quot;})

module AutomaticModeExample = {
  // &quot;automatic&quot; mode will compile jsx to the React 18 compatible
  // jsx-runtime calls
  @@jsxConfig({version: 4, mode: &quot;automatic&quot;})

  @react.component
  let make = (~name) =&gt; {
    &lt;div&gt; {React.string(`Hello ${name}`)} &lt;/div&gt;
  }
}

module ClassicModeExample = {
  // &quot;classic&quot; mode will compile jsx to React.createElement calls
  @@jsxConfig({version: 4, mode: &quot;classic&quot;})

  @react.component
  let make = (~name) =&gt; {
    &lt;div&gt; {React.string(`Hello ${name}`)} &lt;/div&gt;
  }
}

module NoAttributeExample = {
  // No need for `makeProps` anymore
  type props = {name: string}

  let make = (props: props) =&gt; {
    &lt;div&gt; {React.string(`Hello ${props.name}`)} &lt;/div&gt;
  }
}

module ReactInterfaceExample: {
  @react.component
  let make: (~name: string, ~age: int=?) =&gt; React.element
} = {
  @react.component
  let make = (~name, ~age=0) =&gt; {
    &lt;div&gt;
      {React.string(
        `Hello ${name}, you are ${Belt.Int.toString(age)} years old.`,
      )}
    &lt;/div&gt;
  }
}

module PropTypeInjectionExample = {
  // Let's assume we have a prop type that we wanna enforce
  // as our labeled arguments
  type someoneElsesProps = {isHuman: bool}

  // Here we tell the `react.component` decorator what props to infer.
  // Useful for e.g. NextJS usage, or to create components that should
  // comply to certain library component interfaces
  @react.component(: someoneElsesProps)
  let make = (~isHuman) =&gt; {
    let msg = switch isHuman {
    | true =&gt; &quot;hello human&quot;
    | false =&gt; &quot;hello fellow computer&quot;
    }
    &lt;div&gt; {React.string(msg)} &lt;/div&gt;
  }
}

module PropSpreadExample = {
  // Note: This will require @rescript/react 0.11 or later
  @@jsxConfig({version: 4, mode: &quot;automatic&quot;})

  @react.component
  let make = () =&gt; {
    let props = {NoAttributeExample.name: &quot;World&quot;}

    &lt;NoAttributeExample {...props} /&gt;
  }
}

let root =
  &lt;div&gt;
    &lt;AutomaticModeExample name=&quot;Automatic&quot; /&gt;
    &lt;ClassicModeExample name=&quot;Classic&quot; /&gt;
    &lt;NoAttributeExample name=&quot;NoAttribute&quot; /&gt;
    &lt;ReactInterfaceExample name=&quot;Interface&quot; /&gt;
    &lt;PropTypeInjectionExample isHuman=true /&gt;
    &lt;PropSpreadExample /&gt;
  &lt;/div&gt;
</code></pre>

<pre class="codehilite"><code class="language-js">import * as React from &quot;react&quot;;
import * as JsxRuntime from &quot;react/jsx-runtime&quot;;

function Playground$AutomaticModeExample(props) {
  return JsxRuntime.jsx(&quot;div&quot;, {
              children: &quot;Hello &quot; + props.name + &quot;&quot;
            });
}

var AutomaticModeExample = {
  make: Playground$AutomaticModeExample
};

function Playground$ClassicModeExample(props) {
  return React.createElement(&quot;div&quot;, undefined, &quot;Hello &quot; + props.name + &quot;&quot;);
}

var ClassicModeExample = {
  make: Playground$ClassicModeExample
};

function make(props) {
  return JsxRuntime.jsx(&quot;div&quot;, {
              children: &quot;Hello &quot; + props.name + &quot;&quot;
            });
}

var NoAttributeExample = {
  make: make
};

function Playground$ReactInterfaceExample(props) {
  var age = props.age;
  var age$1 = age !== undefined ? age : 0;
  return JsxRuntime.jsx(&quot;div&quot;, {
              children: &quot;Hello &quot; + props.name + &quot;, you are &quot; + String(age$1) + &quot; years old.&quot;
            });
}

var ReactInterfaceExample = {
  make: Playground$ReactInterfaceExample
};

function Playground$PropTypeInjectionExample(props) {
  var msg = props.isHuman ? &quot;hello human&quot; : &quot;hello fellow computer&quot;;
  return JsxRuntime.jsx(&quot;div&quot;, {
              children: msg
            });
}

var PropTypeInjectionExample = {
  make: Playground$PropTypeInjectionExample
};

function Playground$PropSpreadExample(props) {
  return JsxRuntime.jsx(make, {
              name: &quot;World&quot;
            });
}

var PropSpreadExample = {
  make: Playground$PropSpreadExample
};

var root = JsxRuntime.jsxs(&quot;div&quot;, {
      children: [
        JsxRuntime.jsx(Playground$AutomaticModeExample, {
              name: &quot;Automatic&quot;
            }),
        JsxRuntime.jsx(Playground$ClassicModeExample, {
              name: &quot;Classic&quot;
            }),
        JsxRuntime.jsx(make, {
              name: &quot;NoAttribute&quot;
            }),
        JsxRuntime.jsx(Playground$ReactInterfaceExample, {
              name: &quot;Interface&quot;
            }),
        JsxRuntime.jsx(Playground$PropTypeInjectionExample, {
              isHuman: true
            }),
        JsxRuntime.jsx(Playground$PropSpreadExample, {})
      ]
    });

export {
  AutomaticModeExample ,
  ClassicModeExample ,
  NoAttributeExample ,
  ReactInterfaceExample ,
  PropTypeInjectionExample ,
  PropSpreadExample ,
  root ,
}
</code></pre>

<p></CodeTab></p>
<h3>How to migrate to JSX v4?</h3>
<p>We provide a full <a href="/docs/react/latest/migrate-react">migration guide</a> with all the details of an migration.</p>
<p>Make sure to also check out the <a href="https://github.com/rescript-lang/rescript-react/blob/master/CHANGELOG.md">rescript-react changelog</a> as well.</p>
<h2>What's next?</h2>
<p>Our contributors are already one step ahead and are currently working on improvements for the next major v11 release. Things that are currently being explored:</p>
<ul>
<li>Make uncurried functions the default. This will be a huge change in terms of how we do interop and will open completely new ways to interact with existing codebases. It will also allow us to improve tooling in ways that wouldn't have been possible in a curried language.</li>
<li>Explorations for a community "standard library" that goes beyond <code>Belt</code> and <code>Js.*</code>. This will also involve disabling / removing global "Stdlib" modules that shouldn't be used (e.g. <code>Array</code>, <code>List</code>, etc). </li>
<li>New tooling to generate markdown from docstrings (module, type and value level). This will be super simple, but very effective.</li>
<li>Explorations for a <a href="https://forum.rescript-lang.org/t/translation-project-rescript-lang-org/4022">localized documentation page</a> (currently in a slowed-down exploration phase, but we will be getting there)</li>
</ul>
<p>Check out the <a href="https://github.com/rescript-lang/rescript-compiler/issues?q=is%3Aopen+is%3Aissue+milestone%3Av11.0">v11</a> milestone on our <code>rescript-lang</code> repo for more details on future improvements.</p>
<h2>Acknowledgements</h2>
<p>As always, we want to thank our <a href="https://github.com/rescript-lang/rescript-compiler/graphs/contributors?from=2019-11-24&amp;to=2023-02-02&amp;type=c">contributors</a> for building an amazing platform. Special thanks go out to <a href="https://github.com/mununki">mununki</a> for building the new JSX v4 syntax. Amazing work!</p>
<h2>That's it</h2>
<p>We hope you enjoy the newest improvements as much as we do.</p>
<p>In case there's any issues / problems, make sure to report bugs to <a href="https://github.com/rescript-lang/rescript-compiler">rescript-lang/rescript-compiler</a> (language / syntax / jsx), <a href="https://github.com/rescript-lang/rescript-react">rescript-lang/rescript-react</a> (React 16 / 18 binding) or <a href="https://github.com/rescript-association/rescript-lang.org">rescript-association/rescript-lang.org</a> (documentation) repositories.</p>
<p>Also feel free to visit the <a href="https://forum.rescript-lang.org/">ReScript forum</a> to ask questions and connect with other ReScripters.</p>